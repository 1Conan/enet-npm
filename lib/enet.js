;(function () {

    var root = this;

// -- code generated by emscripten will follow ---
var events, util, Queue, DGRAM;

var ENET_HOST_SERVICE_INTERVAL = 30;//milli-seconds

var global_packet_filter;

if (typeof exports !== 'undefined') {

    events = require("events");
    util = require("util");
    Queue = require("./Queue");
    DGRAM = require("dgram");

    module.exports.init = function( pf_func){
        if(pf_func){
             _jsapi_init(1);
            global_packet_filter = pf_func;
        }else{
            _jsapi_init(0);
        }
    };
    module.exports.Host = ENetHost;
    module.exports.Address = ENetAddress;
    module.exports.Packet = ENetPacket;
    module.exports.inet_ip2long=ip2long;
    module.exports.inet_long2ip=long2ip;

  } else {

    Queue = root.Queue;

    root.ENET = {   
        init : _jsapi_init,
        Host : ENetHost,
        Address : ENetAddress,
        Packet : ENetPacket,
        inet_ip2long : ip2long,
        inet_long2ip : long2ip
    }  
}

if(events && util ) util.inherits(ENetHost, events.EventEmitter);

function ENetHost(address,maxchannels,maxpeers){
   if(events){
      events.EventEmitter.call(this);
   }else{
       this._events = {};
   }

   var self = this;
   var pointer = ccall('jsapi_enet_host_create', 'number', 
			['number','number','number','number','number','number'],
			[address.host(), address.port(),maxpeers || 128, maxchannels || 5, 0, 0]);
   if(pointer==0){
	throw('failed to create ENet host');
   }
   self._event = new ENetEvent();//allocate memory for - free it when we destroy the host
   self._pointer = pointer;
   self._socket_bound = false;
}

if(!events){
    ENetHost.prototype.on = function(e,cb){
        this._events[e] ? this._events[e].push(cb) : this._events[e]=[cb];
    };
    ENetHost.prototype.emit = function(){
        //used internally to fire events
        //'apply' event handler function  to 'this' channel pass eventname and Object O
        var self = this;
        var e = arguments[0];
        var params = Array.prototype.slice.apply(arguments,[1]);
        if(this._events && this._events[e]){
            this._events[e].forEach(function(cb){
                cb.apply(self,params);
            });
        }
    };
}

ENetHost.prototype.__service = cwrap('enet_host_service','number',['number','number','number']);
ENetHost.prototype.service = function(){
   var self = this;
  try{
	if(!self._socket_bound){
                //keep checking until the port is non 0
                if(self.address().port()!=0){
                    self._socket_bound=true;
                    self.emit('ready');
                }
         }

   var err = self.__service(self._pointer,self._event._pointer,0);
   while( err > 0){
	switch(self._event.type()){
		case 0:	//none
			break;
		case 1: //connect
			self.emit("connect",
			  self._event.peer(),
			  self._event.data()
			);
			break;			
		case 2: //disconnect
			self.emit("disconnect",
			  self._event.peer(),
			  self._event.data()
			);
			break;
		case 3: //receive
			self.emit("message",
			  self._event.peer(),
			  self._event.packet(),
			  self._event.channelID(),
			  self._event.data()
			);
			self._event.packet().destroy();
			break;
		case 100: //rawpacket
			try{
			JSON.parse(self._event.packet().data().toString());
			self.emit("telex",
			  self._event.packet().data(),{
			    'address':self.receivedAddress().address(),
			    'port':self.receivedAddress().port()
 			  }
			);
			}catch(E){}
			self._event.packet().destroy();
			break;
	}
	err = self.__service(self._pointer,self._event._pointer,0);
   }
  }catch(e){
   console.log(e);
   if(err < 0) console.error("error servicing host: ",err);
  }
};

ENetHost.prototype.destroy = function(){
   var self = this;
   self.stop();
   self._event.free();
   ccall("enet_host_destroy",'',['number'],[this._pointer]);
};
ENetHost.prototype.receivedAddress = function(){
	var ptr = ccall("jsapi_host_get_receivedAddress",'number',['number'],[this._pointer]);
	return new ENetAddress(ptr);
};
ENetHost.prototype.address = function(){
	//get node udp dgram.address()
	var socket = ccall('jsapi_host_get_socket',"number",['number'],[this._pointer]);
	var addr = udp_sockets[socket].address();
	return new ENetAddress(addr.address,addr.port);
};
ENetHost.prototype.send = function(ip, port,buff){
	var socket = ccall('jsapi_host_get_socket',"number",['number'],[this._pointer]);
	udp_sockets[socket].send(buff,0,buff.length,port,ip);
};
ENetHost.prototype.connect = function(address,channelCount,data){
	var ptr=ccall("jsapi_enet_host_connect","number",['number','number','number','number','number'],
		[this._pointer,address.host(),address.port(),channelCount||5,data||0]);

	return new ENetPeer(ptr);
};
ENetHost.prototype.start_watcher = function(){
   if(this._io_loop) return;
   var self=this;
   self._io_loop = setInterval(function(){
	self.service();
   },ENET_HOST_SERVICE_INTERVAL);
};
ENetHost.prototype.stop_watcher = function(){
  if(this._io_loop){
	clearInterval(this._io_loop);	
  }
};
ENetHost.prototype.start = ENetHost.prototype.start_watcher;
ENetHost.prototype.stop = ENetHost.prototype.stop_watcher;

function ENetPacket(pointer){
  if(arguments.length==1 && typeof arguments[0]=='number'){
	this._pointer = arguments[0];
	//console.log("Wrapping ENetPacket Pointer", this._pointer);
	return this;
  }
  if(arguments.length>0 && typeof arguments[0]=='object'){
	//construct a new packet from node buffer
	var buf = arguments[0];
	var flags = arguments[1] || 0;
	this._pointer = ccall("enet_packet_create","number",['number','number','number'],[0,buf.length,flags]);
	//console.log("ENetPacket malloc'ed",this._pointer);
        var begin = ccall("jsapi_packet_get_data","number",["number"],[this._pointer]);
        var end = begin + buf.length;
	var c=0,i=begin;
	for(;i<end;i++,c++){
		HEAPU8[i]=buf.readUInt8(c);
	}
	return this;
  }
  if(arguments.length>0 && typeof arguments[0]=='string'){
	return new ENetPacket( new Buffer(arguments[0]), arguments[1]||0);
  }
};
ENetPacket.prototype.data = function(){
	var begin = ccall("jsapi_packet_get_data","number",["number"],[this._pointer]);
	var end = begin + ccall("jsapi_packet_get_dataLength","number",["number"],[this._pointer]);
	return new Buffer(HEAPU8.subarray(begin,end),"byte");
	//return HEAPU8.subarray(begin,end);
};
ENetPacket.prototype.dataLength = function(){
	return ccall("jsapi_packet_get_dataLength","number",["number"],[this._pointer]);
};
ENetPacket.prototype.destroy = function(){
	ccall("enet_packet_destroy",'',['number'],[this._pointer]);
};

ENetPacket.prototype.FLAG_RELIABLE = 1;

function ENetEvent(){
   this._pointer = ccall('jsapi_event_new','number');
};

ENetEvent.prototype.free = function(){
   ccall('jsapi_event_free','',['number'],[this._pointer]);
};

ENetEvent.prototype.type = function(){
   return ccall('jsapi_event_get_type','number',['number'],[this._pointer]);
};
ENetEvent.prototype.peer = function(){
   var ptr = ccall('jsapi_event_get_peer','number',['number'],[this._pointer]);
   return new ENetPeer(ptr);
};
ENetEvent.prototype.packet = function(){
   var ptr = ccall('jsapi_event_get_packet','number',['number'],[this._pointer]);
   return new ENetPacket(ptr);
};
ENetEvent.prototype.data = function(){
  return ccall('jsapi_event_get_data','number',['number'],[this._pointer]);
};
ENetEvent.prototype.channelID = function(){
 return ccall('jsapi_event_get_channelID','number',['number'],[this._pointer]);
};

function ENetAddress(){
   if(arguments.length==1 && typeof arguments[0]=='object'){
	this._host = arguments[0].host();
	this._port = arguments[0].port();
	return this;
   }
   if(arguments.length==1 && typeof arguments[0]=='number'){
	this._pointer = arguments[0];
	return this;
   }
   if(arguments.length==1 && typeof arguments[0]=='string'){
	var ipp =arguments[0].split(':');
	this._host = ip2long(ipp[0]);
	this._port = ipp[1]||0;
	return this;
   }
   if(arguments.length==2){
	if(typeof arguments[0] == 'string'){
		this._host = ip2long((arguments[0]));
	}else{
		this._host = arguments[0];
	}
	this._port = arguments[1];
	return this;
   }
   throw("bad parameters creating ENetAddress");
};
ENetAddress.prototype.host = function(){
  if(this._pointer){
	var hostptr = ccall('jsapi_address_get_host','number',['number'],[this._pointer]);
	return HEAPU32[hostptr>>2];
  }else{
	return this._host;
  }
};
ENetAddress.prototype.port = function(){
  if(this._pointer){
    return ccall('jsapi_address_get_port','number',['number'],[this._pointer]);
  }else{
    return this._port;
  }
};
ENetAddress.prototype.address = function(){ 
  if(this._pointer) return long2ip(this.host(),'ENetAddress.prototype.address from pointer');
  return long2ip(this.host(),'ENetAddress.prototype.address from local');
}

function ENetPeer(pointer){
  if(pointer) this._pointer = pointer; else throw("improper use of ENetPeer");
};
ENetPeer.prototype.send = function(channel,packet){
	var ret = ccall('enet_peer_send','number',['number','number','number'],[this._pointer,channel,packet._pointer]);
	if(ret < 0) throw("enet.Peer send error");
	//console.log("enet_peer_send return value:",ret);
};
ENetPeer.prototype.receive = function(){
};
ENetPeer.prototype.reset = function(){
  ccall('enet_peer_reset','',['number'],[this._pointer]);
};
ENetPeer.prototype.ping = function(){
  ccall('enet_peer_ping','',['number'],[this._pointer]);
};
ENetPeer.prototype.disconnect = function(data){
  ccall('enet_peer_disconnect','',['number','number'],[this._pointer, data||0]);
};
ENetPeer.prototype.disconnectNow = function(data){
  ccall('enet_peer_disconnect_now','',['number','number'],[this._pointer,data||0]);
};
ENetPeer.prototype.disconnectLater = function(data){
  ccall('enet_peer_disconnect_later','',['number','number'],[this._pointer,data||0]);
};
ENetPeer.prototype.address = function(){
 var ptr = ccall('jsapi_peer_get_address','number',['number'],[this._pointer]);
 return new ENetAddress(ptr);
};

var udp_sockets_count=0;
var udp_sockets = {};

var global_udp_callback = function(msg,rinfo,sfd){
    //que each packet it will be de-queed when recvmsg() is called
    var udpsocket = udp_sockets[sfd];
    if(udpsocket){
        udpsocket.packets.enqueue({
            data:msg,
            dataLength:msg.length,
            ip:rinfo.address,
            port:rinfo.port
        });
    }
}

function long2ip(l, source) {
    if(l<0){
	 throw('long2ip got a negative number!');
    }
    with (Math) {   
        var ip1 = floor(l/pow(256,3));
        var ip2 = floor((l%pow(256,3))/pow(256,2));
        var ip3 = floor(((l%pow(256,3))%pow(256,2))/pow(256,1));
        var ip4 = floor((((l%pow(256,3))%pow(256,2))%pow(256,1))/pow(256,0));
    }
    return ip1 + '.' + ip2 + '.' + ip3 + '.' + ip4;
}
function ip2long(ip) {
    var ips = ip.split('.');
    var iplong = 0;
    with (Math) {
        iplong = ips[0]*pow(256,3)+ips[1]*pow(256,2)+ips[2]*pow(256,1)+ips[3]*pow(256,0);
    }
    if(iplong<0) throw ('ip2long produced a negative number! '+iplong);
    return iplong;
}

function BufferConcat( buffers ){
    var totalLength = 0;
    buffers.forEach(function(B){
        totalLength = totalLength + B.length;
    });    
    var buf = new Buffer(totalLength);
    var i = 0;
    buffers.forEach(function(B){
        for(var b=0; b<B.length;b++){
            buf[i]=B[b];
            i++;
        }
    });
    return buf;
}

function C_String_to_JS_String(ptr){
    var str = "";
    var i = 0;
    while (HEAP8[((ptr)+(i))]){         
         str = str + String.fromCharCode(HEAPU8[((ptr)+(i))]);
         i++; // Note: should be |!= 0|, technically.
    }
    return str;
}
function JS_String_to_CString(jstr, ptr){
    var i=0;
    for(;i<jstr.length;){
        HEAPU8[(((ptr+i)|0))]=jstr.charCodeAt(i);
        i++;
    }
    HEAPU8[(((ptr+i)|0))]=0;//terminating null
}


var Module = {};

Module["preRun"]=[];

Module['preRun'].push(function(){

    	_gethostbyname = _gehostbyname_r = function(){ return 0; }
        _fcntl=function(){return -1;}
        _ioctl=function(){return -1;}
        
        //enet API functions from unix.c
        _enet_socket_create =function(){
            //console.log("enet_socket_create()",arguments);
            var sfd;
            try{
                udp_sockets_count++;
                sfd = udp_sockets_count;
                udp_sockets[sfd]=DGRAM.createSocket("udp4",function(msg,rinfo){
                    global_udp_callback(msg,rinfo,sfd);
                });
                udp_sockets[sfd].packets = new Queue();

            }catch(e){
                sfd=-1;
            }            
            return sfd;
        };
        
        _enet_socket_bind = function($socket,$address){
          var $host;
          var $port;
          $host = HEAPU32[(($address)>>2)];
          $port = HEAP16[(($address+4)>>1)];

          if(udp_sockets[$socket]){
              console.error("binding to port",$port);
              udp_sockets[$socket].bind($port,long2ip($host,'_enet_socket_bind'));
              return 0;
          }
          return -1;//todo: set error number
        };
        
        _enet_socket_listen = function($socket, $backlog){
          //console.error("enet_socket_listen()",arguments);
        };        
        _enet_socket_set_option = function(){
            //console.log("enet_socket_set_option()",arguments);
            return 0;
        };
        
        _recvmsg = function($sockfd, $msgHdr, $flags) {
          var udpsocket = udp_sockets[$sockfd];
          if(!udpsocket) return -1;
          if(!udpsocket.packets.getLength()) return 0;
          //dequeue
          var packet = udpsocket.packets.dequeue();
          if(!packet) return 0;

          var $sin=HEAP32[(($msgHdr)>>2)];
          var $buffer=HEAP32[(($msgHdr+8)>>2)];
          HEAP32[(($buffer+4)>>2)]=packet.dataLength;//dataLength
          var $data=HEAP32[($buffer)>>2];

          //Copy Node Buffer packet.data into HEAP8[($data)|0],HEAP8[($data+1)|0]
          //MAX_MTU?
          for(var i=0;i<packet.dataLength;i++){
            HEAPU8[($data+i)|0]=packet.data[i];
          }

          HEAP16[(($sin)>>1)]=1;
          HEAPU32[(($sin+4)>>2)]=ip2long(packet.ip);
          HEAP16[(($sin+2)>>1)]=_htons(packet.port);

          return packet.dataLength;//truncation??
        };
        
        _sendmsg = function($sockfd, $msgHdr, $flags) {
          var udpsocket = udp_sockets[$sockfd];
          if(!udpsocket) return -1;
          var chunks = [];
          var chunk;
          var chunkLength;
          var $sin=HEAP32[(($msgHdr)>>2)];
          var $buffers=HEAP32[(($msgHdr+8)>>2)];

          for( var $x=0; $x <  HEAPU32[($msgHdr+12)>>2] ; $x++ ){
              chunkLength = HEAP32[(($buffers+($x<<3)+4)>>2)];
              chunk = new Buffer(chunkLength);
              $data=HEAP32[($buffers+($x<<3))>>2]

              //Copy HEAP into node Buffer
              for(var i=0;i<chunkLength;i++){
                chunk[i] = HEAP8[($data+i)|0];
              }
              chunks.push(chunk);
           }

              HEAP16[(($sin)>>1)]=1;
              var packet = {};
              packet.ip = long2ip(HEAPU32[(($sin+4)>>2)],'_sendmsg');
              packet.port=_ntohs(HEAP16[(($sin+2)>>1)]);
              packet.data = BufferConcat(chunks);
              packet.dataLength = packet.data.length;
              udpsocket.send(packet.data,0,packet.data.length,packet.port,packet.ip,function(){
                 //console.log("Sent Packet:",packet);
              });
                  
              return packet.data.length;
        };

        _enet_socket_wait = function(){
            //console.error("enet_socket_wait()",arguments);
            return -1;//don't wait
        };
        _enet_socket_destroy = function($socket){
            //console.log("enet_socket_destroy()",arguments);
            if(udp_sockets[$socket]){
                udp_sockets[$socket].close();
                delete udp_sockets[$socket];
            }
        };

});//preRun


function __packet_filter (host_ptr){
   var ip,port,data;
   return global_packet_filter(ip,port,data);
}


// Note: For maximum-speed code, see "Optimizing Code" on the Emscripten wiki, https://github.com/kripken/emscripten/wiki/Optimizing-Code
// Note: Some Emscripten settings may limit the speed of the generated code.
// TODO: " u s e   s t r i c t ";

try {
  this['Module'] = Module;
} catch(e) {
  this['Module'] = Module = {};
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  Module['print'] = function(x) {
    process['stdout'].write(x + '\n');
  };
  Module['printErr'] = function(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function(filename) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename).toString();
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename).toString();
    }
    return ret;
  };

  Module['load'] = function(f) {
    globalEval(read(f));
  };

  if (!Module['arguments']) {
    Module['arguments'] = process['argv'].slice(2);
  }
}

if (ENVIRONMENT_IS_SHELL) {
  Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  // Polyfill over SpiderMonkey/V8 differences
  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function(f) { snarf(f) };
  }

  if (!Module['arguments']) {
    if (typeof scriptArgs != 'undefined') {
      Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER) {
  if (!Module['print']) {
    Module['print'] = function(x) {
      console.log(x);
    };
  }

  if (!Module['printErr']) {
    Module['printErr'] = function(x) {
      console.log(x);
    };
  }
}

if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (!Module['arguments']) {
    if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WORKER) {
  // We can do very little here...
  var TRY_USE_DUMP = false;
  if (!Module['print']) {
    Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  Module['load'] = importScripts;
}

if (!ENVIRONMENT_IS_WORKER && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_SHELL) {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
if (!Module['preRun']) Module['preRun'] = [];
if (!Module['postRun']) Module['postRun'] = [];

  
// === Auto-generated preamble library stuff ===

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      var logg = log2(quantum);
      return '((((' +target + ')+' + (quantum-1) + ')>>' + logg + ')<<' + logg + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (/^\[\d+\ x\ (.*)\]/.test(type)) return true; // [15 x ?] blocks. Like structs
  if (/<?{ ?[^}]* ?}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  bitshift64: function (low, high, op, bits) {
    var ander = Math.pow(2, bits)-1;
    if (bits < 32) {
      switch (op) {
        case 'shl':
          return [low << bits, (high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits))];
        case 'ashr':
          return [(((low >>> bits ) | ((high&ander) << (32 - bits))) >> 0) >>> 0, (high >> bits) >>> 0];
        case 'lshr':
          return [((low >>> bits) | ((high&ander) << (32 - bits))) >>> 0, high >>> bits];
      }
    } else if (bits == 32) {
      switch (op) {
        case 'shl':
          return [0, low];
        case 'ashr':
          return [high, (high|0) < 0 ? ander : 0];
        case 'lshr':
          return [high, 0];
      }
    } else { // bits > 32
      switch (op) {
        case 'shl':
          return [0, low << (bits - 32)];
        case 'ashr':
          return [(high >> (bits - 32)) >>> 0, (high|0) < 0 ? ander : 0];
        case 'lshr':
          return [high >>>  (bits - 32) , 0];
      }
    }
    abort('unknown bitshift64 op: ' + [value, op, bits]);
  },
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type, quantumSize) {
    if (Runtime.QUANTUM_SIZE == 1) return 1;
    var size = {
      '%i1': 1,
      '%i8': 1,
      '%i16': 2,
      '%i32': 4,
      '%i64': 8,
      "%float": 4,
      "%double": 8
    }['%'+type]; // add '%' since float and double confuse Closure compiler as keys, and also spidermonkey as a compiler will remove 's from '_i8' etc
    if (!size) {
      if (type.charAt(type.length-1) == '*') {
        size = Runtime.QUANTUM_SIZE; // A pointer
      } else if (type[0] == 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 == 0);
        size = bits/8;
      }
    }
    return size;
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    type.flatIndexes = type.fields.map(function(field) {
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = size;
      } else if (Runtime.isStructType(field)) {
        size = Types.types[field].flatSize;
        alignSize = Types.types[field].alignSize;
      } else {
        throw 'Unclear type in struct: ' + field + ', in ' + type.name_ + ' :: ' + dump(Types.types[type.name_]);
      }
      alignSize = type.packed ? 1 : Math.min(alignSize, Runtime.QUANTUM_SIZE);
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  addFunction: function (func) {
    var ret = FUNCTION_TABLE.length;
    FUNCTION_TABLE.push(func);
    FUNCTION_TABLE.push(0);
    return ret;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func) {
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function() {
        FUNCTION_TABLE[func].apply(null, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xff;
      if (needed) {
        buffer.push(code);
        needed--;
      }
      if (buffer.length == 0) {
        if (code < 128) return String.fromCharCode(code);
        buffer.push(code);
        if (code > 191 && code < 224) {
          needed = 1;
        } else {
          needed = 2;
        }
        return '';
      }
      if (needed > 0) return '';
      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var ret;
      if (c1 > 191 && c1 < 224) {
        ret = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      } else {
        ret = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function(string) {
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  stackAlloc: function stackAlloc(size) { var ret = STACKTOP;STACKTOP += size;STACKTOP = ((((STACKTOP)+3)>>2)<<2); return ret; },
  staticAlloc: function staticAlloc(size) { var ret = STATICTOP;STATICTOP += size;STATICTOP = ((((STATICTOP)+3)>>2)<<2); if (STATICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function alignMemory(size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 4))*(quantum ? quantum : 4); return ret; },
  makeBigInt: function makeBigInt(low,high,unsigned) { var ret = (unsigned ? (((low)>>>0)+(((high)>>>0)*4294967296)) : (((low)>>>0)+(((high)|0)*4294967296))); return ret; },
  QUANTUM_SIZE: 4,
  __dummy__: 0
}



var CorrectionsMonitor = {
  MAX_ALLOWED: 0, // XXX
  corrections: 0,
  sigs: {},

  note: function(type, succeed, sig) {
    if (!succeed) {
      this.corrections++;
      if (this.corrections >= this.MAX_ALLOWED) abort('\n\nToo many corrections!');
    }
  },

  print: function() {
  }
};





//========================================
// Runtime essentials
//========================================

var __THREW__ = false; // Used in checking for thrown exceptions.

var ABORT = false;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD;
var tempI64, tempI64b;

function abort(text) {
  Module.print(text + ':\n' + (new Error).stack);
  ABORT = true;
  throw "Assertion: " + text;
}

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Adding
//
//         __attribute__((used))
//
//       to the function definition will prevent that.
//
// Note: Closure optimizations will minify function names, making
//       functions no longer callable. If you run closure (on by default
//       in -O2 and above), you should export the functions you will call
//       by calling emcc with something like
//
//         -s EXPORTED_FUNCTIONS='["_func1","_func2"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  return ccallFunc(getCFunc(ident), returnType, argTypes, args);
}
Module["ccall"] = ccall;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  try {
    var func = eval('_' + ident);
  } catch(e) {
    try {
      func = globalScope['Module']['_' + ident]; // closure exported function
    } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

// Internal function that does a C call using a function, not an identifier
function ccallFunc(func, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length+1);
      writeStringToMemory(value, ret);
      return ret;
    } else if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}

// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  var func = getCFunc(ident);
  return function() {
    return ccallFunc(func, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;

// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,Math.min(Math.floor((value)/4294967296), 4294967295)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': (tempDoubleF64[0]=value,HEAP32[((ptr)>>2)]=tempDoubleI32[0],HEAP32[(((ptr)+(4))>>2)]=tempDoubleI32[1]); break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;

// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return (tempDoubleI32[0]=HEAP32[((ptr)>>2)],tempDoubleI32[1]=HEAP32[(((ptr)+(4))>>2)],tempDoubleF64[0]);
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_NONE = 3; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
      _memset(ret, 0, size);
      return ret;
  }
  
  var i = 0, type;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);
    i += Runtime.getNativeTypeSize(type);
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  var utf8 = new Runtime.UTF8Processor();
  var nullTerminated = typeof(length) == "undefined";
  var ret = "";
  var i = 0;
  var t;
  while (1) {
    t = HEAPU8[((ptr)+(i))];
    if (nullTerminated && t == 0) break;
    ret += utf8.processCChar(t);
    i += 1;
    if (!nullTerminated && i == length) break;
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

function Array_stringify(array) {
  var ret = "";
  for (var i = 0; i < array.length; i++) {
    ret += String.fromCharCode(array[i]);
  }
  return ret;
}
Module['Array_stringify'] = Array_stringify;

// Memory management

var FUNCTION_TABLE; // XXX: In theory the indexes here can be equal to pointers to stacked or malloced memory. Such comparisons should
                    //      be false, but can turn out true. We should probably set the top bit to prevent such issues.

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return ((x+4095)>>12)<<12;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STACK_ROOT, STACKTOP, STACK_MAX;
var STATICTOP;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ( ' + TOTAL_MEMORY + '), (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}

var TOTAL_STACK = Module['TOTAL_STACK'] || 409600;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 1048576;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
  assert(!!Int32Array && !!Float64Array && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
         'Cannot fallback to non-typed array case: Code is too specialized');

  var buffer = new ArrayBuffer(TOTAL_MEMORY);
  HEAP8 = new Int8Array(buffer);
  HEAP16 = new Int16Array(buffer);
  HEAP32 = new Int32Array(buffer);
  HEAPU8 = new Uint8Array(buffer);
  HEAPU16 = new Uint16Array(buffer);
  HEAPU32 = new Uint32Array(buffer);
  HEAPF32 = new Float32Array(buffer);
  HEAPF64 = new Float64Array(buffer);

  // Endianness check (note: assumes compiler arch was little-endian)
  HEAP32[0] = 255;
  assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

STACK_ROOT = STACKTOP = Runtime.alignMemory(1);
STACK_MAX = STACK_ROOT + TOTAL_STACK;

var tempDoublePtr = Runtime.alignMemory(STACK_MAX, 8);
var tempDoubleI8  = HEAP8.subarray(tempDoublePtr);
var tempDoubleI32 = HEAP32.subarray(tempDoublePtr >> 2);
var tempDoubleF32 = HEAPF32.subarray(tempDoublePtr >> 2);
var tempDoubleF64 = HEAPF64.subarray(tempDoublePtr >> 3);
function copyTempFloat(ptr) { // functions, because inlining this code is increases code size too much
  tempDoubleI8[0] = HEAP8[ptr];
  tempDoubleI8[1] = HEAP8[ptr+1];
  tempDoubleI8[2] = HEAP8[ptr+2];
  tempDoubleI8[3] = HEAP8[ptr+3];
}
function copyTempDouble(ptr) {
  tempDoubleI8[0] = HEAP8[ptr];
  tempDoubleI8[1] = HEAP8[ptr+1];
  tempDoubleI8[2] = HEAP8[ptr+2];
  tempDoubleI8[3] = HEAP8[ptr+3];
  tempDoubleI8[4] = HEAP8[ptr+4];
  tempDoubleI8[5] = HEAP8[ptr+5];
  tempDoubleI8[6] = HEAP8[ptr+6];
  tempDoubleI8[7] = HEAP8[ptr+7];
}
STACK_MAX = tempDoublePtr + 8;

STATICTOP = alignMemoryPage(STACK_MAX);

assert(STATICTOP < TOTAL_MEMORY); // Stack must fit in TOTAL_MEMORY; allocations from here on may enlarge TOTAL_MEMORY

var nullString = allocate(intArrayFromString('(null)'), 'i8', ALLOC_STATIC);

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    var func = callback.func;
    if (typeof func === 'number') {
      func = FUNCTION_TABLE[func];
    }
    func(callback.arg === undefined ? null : callback.arg);
  }
}

var __ATINIT__ = []; // functions called during startup
var __ATMAIN__ = []; // functions called when main() is to be run
var __ATEXIT__ = []; // functions called during shutdown

function initRuntime() {
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);

  // Print summary of correction activity
  CorrectionsMonitor.print();
}

function String_len(ptr) {
  var i = ptr;
  while (HEAP8[(i++)]) { // Note: should be |!= 0|, technically. But this helps catch bugs with undefineds
  }
  return i - ptr - 1;
}
Module['String_len'] = String_len;

// Tools

// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[((buffer)+(i))]=chr
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[((buffer)+(i))]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function unSign(value, bits, ignore, sig) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
  // TODO: clean up previous line
}
function reSign(value, bits, ignore, sig) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyTracking = {};
var calledRun = false;
var runDependencyWatcher = null;
function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            Module.printErr('still waiting on run dependencies:');
          }
          Module.printErr('dependency: ' + dep);
        }
        if (shown) {
          Module.printErr('(end of list)');
        }
      }, 6000);
    }
  } else {
    Module.printErr('warning: run dependency added without ID');
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    Module.printErr('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    } 
    if (!calledRun) run();
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

// === Body ===



var _timeBase;
var _stderr;
var _mparams;
var _jsapi_init_callbacks;
var _initializedCRC32_b;
var _enet_peer_queue_incoming_command_dummyCommand;
var _crcTable;
var _commandSizes;
var _callbacks_3;
var _callbacks_2;
var _callbacks_1;
var _callbacks_0;
var __str41;
var __str3;
var __str243;
var __str2;
var __str142;
var __str14;
var __str1;
var __str;
var __gm_;
var __ZTVSt9exception;
var __ZTVSt9bad_alloc;
var __ZTVSt20bad_array_new_length;
var __ZTVN10__cxxabiv120__si_class_type_infoE;
var __ZTSSt9bad_alloc;
var __ZTSSt20bad_array_new_length;
var __ZTISt9exception;
var __ZTISt9bad_alloc;
var __ZTISt20bad_array_new_length;
var __ZSt7nothrow;
var __ZL13__new_handler;
var __ZNSt9bad_allocC1Ev;
var __ZNSt9bad_allocD1Ev;
var __ZNSt20bad_array_new_lengthC1Ev;
var __ZNSt20bad_array_new_lengthD1Ev;
var __ZNSt20bad_array_new_lengthD2Ev;
_timeBase=allocate(4, "i8", ALLOC_STATIC);
_mparams=allocate(24, "i8", ALLOC_STATIC);
_jsapi_init_callbacks=allocate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0], ["*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0], ALLOC_STATIC);
_initializedCRC32_b=allocate(4, "i8", ALLOC_STATIC);
_enet_peer_queue_incoming_command_dummyCommand=allocate(76, "i8", ALLOC_STATIC);
_crcTable=allocate(1024, "i8", ALLOC_STATIC);
_commandSizes=allocate([0, 0, 0, 0, 8, 0, 0, 0, 48, 0, 0, 0, 44, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 24, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0], ["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
_callbacks_3=allocate(4, "i8", ALLOC_STATIC);
_callbacks_2=allocate([16], ["void ()*",0,0,0], ALLOC_STATIC);
_callbacks_1=allocate([8], ["void (i8*)*",0,0,0], ALLOC_STATIC);
_callbacks_0=allocate([18], ["i8* (i32)*",0,0,0], ALLOC_STATIC);
__str41=allocate([109,97,120,32,115,121,115,116,101,109,32,98,121,116,101,115,32,61,32,37,49,48,108,117,10,0] /* max system bytes = % */, "i8", ALLOC_STATIC);
__str3=allocate([115,116,100,58,58,98,97,100,95,97,108,108,111,99,0] /* std::bad_alloc\00 */, "i8", ALLOC_STATIC);
__str243=allocate([105,110,32,117,115,101,32,98,121,116,101,115,32,32,32,32,32,61,32,37,49,48,108,117,10,0] /* in use bytes     = % */, "i8", ALLOC_STATIC);
__str2=allocate([69,114,114,111,114,32,114,101,99,101,105,118,105,110,103,32,105,110,99,111,109,105,110,103,32,112,97,99,107,101,116,115,0] /* Error receiving inco */, "i8", ALLOC_STATIC);
__str142=allocate([115,121,115,116,101,109,32,98,121,116,101,115,32,32,32,32,32,61,32,37,49,48,108,117,10,0] /* system bytes     = % */, "i8", ALLOC_STATIC);
__str14=allocate([98,97,100,95,97,114,114,97,121,95,110,101,119,95,108,101,110,103,116,104,0] /* bad_array_new_length */, "i8", ALLOC_STATIC);
__str1=allocate([69,114,114,111,114,32,115,101,110,100,105,110,103,32,111,117,116,103,111,105,110,103,32,112,97,99,107,101,116,115,0] /* Error sending outgoi */, "i8", ALLOC_STATIC);
__str=allocate([69,114,114,111,114,32,100,105,115,112,97,116,99,104,105,110,103,32,105,110,99,111,109,105,110,103,32,112,97,99,107,101,116,115,0] /* Error dispatching in */, "i8", ALLOC_STATIC);
__gm_=allocate(468, "i8", ALLOC_STATIC);
__ZTVSt9bad_alloc=allocate(20, "i8", ALLOC_STATIC);
allocate(1, "i8", ALLOC_STATIC);
__ZTVSt20bad_array_new_length=allocate(20, "i8", ALLOC_STATIC);
allocate(1, "i8", ALLOC_STATIC);
__ZTSSt9bad_alloc=allocate([83,116,57,98,97,100,95,97,108,108,111,99,0] /* St9bad_alloc\00 */, "i8", ALLOC_STATIC);
__ZTSSt20bad_array_new_length=allocate([83,116,50,48,98,97,100,95,97,114,114,97,121,95,110,101,119,95,108,101,110,103,116,104,0] /* St20bad_array_new_le */, "i8", ALLOC_STATIC);
__ZTISt9bad_alloc=allocate(12, "i8", ALLOC_STATIC);
__ZTISt20bad_array_new_length=allocate(12, "i8", ALLOC_STATIC);
__ZSt7nothrow=allocate(1, "i8", ALLOC_STATIC);
__ZL13__new_handler=allocate(4, "i8", ALLOC_STATIC);
HEAP32[(((__ZTVSt9bad_alloc)+(4))>>2)]=__ZTISt9bad_alloc;
HEAP32[(((__ZTVSt9bad_alloc)+(8))>>2)]=(26);
HEAP32[(((__ZTVSt9bad_alloc)+(12))>>2)]=(22);
HEAP32[(((__ZTVSt9bad_alloc)+(16))>>2)]=(12);
HEAP32[(((__ZTVSt20bad_array_new_length)+(4))>>2)]=__ZTISt20bad_array_new_length;
HEAP32[(((__ZTVSt20bad_array_new_length)+(8))>>2)]=(26);
HEAP32[(((__ZTVSt20bad_array_new_length)+(12))>>2)]=(6);
HEAP32[(((__ZTVSt20bad_array_new_length)+(16))>>2)]=(14);
__ZTVN10__cxxabiv120__si_class_type_infoE=allocate([2,0,0,0], ["i8*",0,0,0], ALLOC_STATIC);
HEAP32[((__ZTISt9bad_alloc)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[(((__ZTISt9bad_alloc)+(4))>>2)]=((__ZTSSt9bad_alloc)|0);
HEAP32[(((__ZTISt9bad_alloc)+(8))>>2)]=__ZTISt9exception;
HEAP32[((__ZTISt20bad_array_new_length)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[(((__ZTISt20bad_array_new_length)+(4))>>2)]=((__ZTSSt20bad_array_new_length)|0);
HEAP32[(((__ZTISt20bad_array_new_length)+(8))>>2)]=__ZTISt9bad_alloc;
__ZNSt9bad_allocC1Ev = 20;
__ZNSt9bad_allocD1Ev = 26;
__ZNSt20bad_array_new_lengthC1Ev = 2;
__ZNSt20bad_array_new_lengthD1Ev = (26);
__ZNSt20bad_array_new_lengthD2Ev = (26);
var __packet_filter; // stub for __packet_filter

  
  function _memcpy(dest, src, num, align) {
      if (num >= 20 && src % 2 == dest % 2) {
        // This is unaligned, but quite large, and potentially alignable, so work hard to get to aligned settings
        if (src % 4 == dest % 4) {
          var stop = src + num;
          while (src % 4) { // no need to check for stop, since we have large num
            HEAP8[dest++] = HEAP8[src++];
          }
          var src4 = src >> 2, dest4 = dest >> 2, stop4 = stop >> 2;
          while (src4 < stop4) {
            HEAP32[dest4++] = HEAP32[src4++];
          }
          src = src4 << 2;
          dest = dest4 << 2;
          while (src < stop) {
            HEAP8[dest++] = HEAP8[src++];
          }
        } else {
          var stop = src + num;
          if (src % 2) { // no need to check for stop, since we have large num
            HEAP8[dest++] = HEAP8[src++];
          }
          var src2 = src >> 1, dest2 = dest >> 1, stop2 = stop >> 1;
          while (src2 < stop2) {
            HEAP16[dest2++] = HEAP16[src2++];
          }
          src = src2 << 1;
          dest = dest2 << 1;
          if (src < stop) {
            HEAP8[dest++] = HEAP8[src++];
          }
        }
      } else {
        while (num--) {
          HEAP8[dest++] = HEAP8[src++];
        }
      }
    }var _llvm_memcpy_p0i8_p0i8_i32=_memcpy;

  function _abort() {
      ABORT = true;
      throw 'abort() at ' + (new Error().stack);
    }

  
  function _memset(ptr, value, num, align) {
      // TODO: make these settings, and in memcpy, {{'s
      if (num >= 20) {
        // This is unaligned, but quite large, so work hard to get to aligned settings
        var stop = ptr + num;
        while (ptr % 4) { // no need to check for stop, since we have large num
          HEAP8[ptr++] = value;
        }
        if (value < 0) value += 256; // make it unsigned
        var ptr4 = ptr >> 2, stop4 = stop >> 2, value4 = value | (value << 8) | (value << 16) | (value << 24);
        while (ptr4 < stop4) {
          HEAP32[ptr4++] = value4;
        }
        ptr = ptr4 << 2;
        while (ptr < stop) {
          HEAP8[ptr++] = value;
        }
      } else {
        while (num--) {
          HEAP8[ptr++] = value;
        }
      }
    }var _llvm_memset_p0i8_i32=_memset;

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret
      }
      return ret;
    }

  function _htons(value) {
      return ((value & 0xff) << 8) + ((value & 0xff00) >> 8);
    }

  function _htonl(value) {
      return ((value & 0xff) << 24) + ((value & 0xff00) << 8) +
             ((value & 0xff0000) >>> 8) + ((value & 0xff000000) >>> 24);
    }

  var _ntohl=_htonl;

  var _ntohs=_htons;

  
  
  
  
  
  var ERRNO_CODES={E2BIG:7,EACCES:13,EADDRINUSE:98,EADDRNOTAVAIL:99,EAFNOSUPPORT:97,EAGAIN:11,EALREADY:114,EBADF:9,EBADMSG:74,EBUSY:16,ECANCELED:125,ECHILD:10,ECONNABORTED:103,ECONNREFUSED:111,ECONNRESET:104,EDEADLK:35,EDESTADDRREQ:89,EDOM:33,EDQUOT:122,EEXIST:17,EFAULT:14,EFBIG:27,EHOSTUNREACH:113,EIDRM:43,EILSEQ:84,EINPROGRESS:115,EINTR:4,EINVAL:22,EIO:5,EISCONN:106,EISDIR:21,ELOOP:40,EMFILE:24,EMLINK:31,EMSGSIZE:90,EMULTIHOP:72,ENAMETOOLONG:36,ENETDOWN:100,ENETRESET:102,ENETUNREACH:101,ENFILE:23,ENOBUFS:105,ENODATA:61,ENODEV:19,ENOENT:2,ENOEXEC:8,ENOLCK:37,ENOLINK:67,ENOMEM:12,ENOMSG:42,ENOPROTOOPT:92,ENOSPC:28,ENOSR:63,ENOSTR:60,ENOSYS:38,ENOTCONN:107,ENOTDIR:20,ENOTEMPTY:39,ENOTRECOVERABLE:131,ENOTSOCK:88,ENOTSUP:95,ENOTTY:25,ENXIO:6,EOVERFLOW:75,EOWNERDEAD:130,EPERM:1,EPIPE:32,EPROTO:71,EPROTONOSUPPORT:93,EPROTOTYPE:91,ERANGE:34,EROFS:30,ESPIPE:29,ESRCH:3,ESTALE:116,ETIME:62,ETIMEDOUT:110,ETXTBSY:26,EWOULDBLOCK:11,EXDEV:18};
  
  function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      if (!___setErrNo.ret) ___setErrNo.ret = allocate([0], 'i32', ALLOC_STATIC);
      HEAP32[((___setErrNo.ret)>>2)]=value
      return value;
    }
  
  var _stdin=0;
  
  var _stdout=0;
  
  var _stderr=0;
  
  var __impure_ptr=0;var FS={currentPath:"/",nextInode:2,streams:[null],ignorePermissions:true,joinPath:function (parts, forceRelative) {
        var ret = parts[0];
        for (var i = 1; i < parts.length; i++) {
          if (ret[ret.length-1] != '/') ret += '/';
          ret += parts[i];
        }
        if (forceRelative && ret[0] == '/') ret = ret.substr(1);
        return ret;
      },absolutePath:function (relative, base) {
        if (typeof relative !== 'string') return null;
        if (base === undefined) base = FS.currentPath;
        if (relative && relative[0] == '/') base = '';
        var full = base + '/' + relative;
        var parts = full.split('/').reverse();
        var absolute = [''];
        while (parts.length) {
          var part = parts.pop();
          if (part == '' || part == '.') {
            // Nothing.
          } else if (part == '..') {
            if (absolute.length > 1) absolute.pop();
          } else {
            absolute.push(part);
          }
        }
        return absolute.length == 1 ? '/' : absolute.join('/');
      },analyzePath:function (path, dontResolveLastLink, linksVisited) {
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        path = FS.absolutePath(path);
        if (path == '/') {
          ret.isRoot = true;
          ret.exists = ret.parentExists = true;
          ret.name = '/';
          ret.path = ret.parentPath = '/';
          ret.object = ret.parentObject = FS.root;
        } else if (path !== null) {
          linksVisited = linksVisited || 0;
          path = path.slice(1).split('/');
          var current = FS.root;
          var traversed = [''];
          while (path.length) {
            if (path.length == 1 && current.isFolder) {
              ret.parentExists = true;
              ret.parentPath = traversed.length == 1 ? '/' : traversed.join('/');
              ret.parentObject = current;
              ret.name = path[0];
            }
            var target = path.shift();
            if (!current.isFolder) {
              ret.error = ERRNO_CODES.ENOTDIR;
              break;
            } else if (!current.read) {
              ret.error = ERRNO_CODES.EACCES;
              break;
            } else if (!current.contents.hasOwnProperty(target)) {
              ret.error = ERRNO_CODES.ENOENT;
              break;
            }
            current = current.contents[target];
            if (current.link && !(dontResolveLastLink && path.length == 0)) {
              if (linksVisited > 40) { // Usual Linux SYMLOOP_MAX.
                ret.error = ERRNO_CODES.ELOOP;
                break;
              }
              var link = FS.absolutePath(current.link, traversed.join('/'));
              ret = FS.analyzePath([link].concat(path).join('/'),
                                   dontResolveLastLink, linksVisited + 1);
              return ret;
            }
            traversed.push(target);
            if (path.length == 0) {
              ret.exists = true;
              ret.path = traversed.join('/');
              ret.object = current;
            }
          }
        }
        return ret;
      },findObject:function (path, dontResolveLastLink) {
        FS.ensureRoot();
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },createObject:function (parent, name, properties, canRead, canWrite) {
        if (!parent) parent = '/';
        if (typeof parent === 'string') parent = FS.findObject(parent);
  
        if (!parent) {
          ___setErrNo(ERRNO_CODES.EACCES);
          throw new Error('Parent path must exist.');
        }
        if (!parent.isFolder) {
          ___setErrNo(ERRNO_CODES.ENOTDIR);
          throw new Error('Parent must be a folder.');
        }
        if (!parent.write && !FS.ignorePermissions) {
          ___setErrNo(ERRNO_CODES.EACCES);
          throw new Error('Parent folder must be writeable.');
        }
        if (!name || name == '.' || name == '..') {
          ___setErrNo(ERRNO_CODES.ENOENT);
          throw new Error('Name must not be empty.');
        }
        if (parent.contents.hasOwnProperty(name)) {
          ___setErrNo(ERRNO_CODES.EEXIST);
          throw new Error("Can't overwrite object.");
        }
  
        parent.contents[name] = {
          read: canRead === undefined ? true : canRead,
          write: canWrite === undefined ? false : canWrite,
          timestamp: Date.now(),
          inodeNumber: FS.nextInode++
        };
        for (var key in properties) {
          if (properties.hasOwnProperty(key)) {
            parent.contents[name][key] = properties[key];
          }
        }
  
        return parent.contents[name];
      },createFolder:function (parent, name, canRead, canWrite) {
        var properties = {isFolder: true, isDevice: false, contents: {}};
        return FS.createObject(parent, name, properties, canRead, canWrite);
      },createPath:function (parent, path, canRead, canWrite) {
        var current = FS.findObject(parent);
        if (current === null) throw new Error('Invalid parent.');
        path = path.split('/').reverse();
        while (path.length) {
          var part = path.pop();
          if (!part) continue;
          if (!current.contents.hasOwnProperty(part)) {
            FS.createFolder(current, part, canRead, canWrite);
          }
          current = current.contents[part];
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        properties.isFolder = false;
        return FS.createObject(parent, name, properties, canRead, canWrite);
      },createDataFile:function (parent, name, data, canRead, canWrite) {
        if (typeof data === 'string') {
          var dataArray = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i) dataArray[i] = data.charCodeAt(i);
          data = dataArray;
        }
        var properties = {
          isDevice: false,
          contents: data.subarray ? data.subarray(0) : data // as an optimization, create a new array wrapper (not buffer) here, to help JS engines understand this object
        };
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
  
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
          var LazyUint8Array = function(chunkSize, length) {
            this.length = length;
            this.chunkSize = chunkSize;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          LazyUint8Array.prototype.get = function(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % chunkSize;
            var chunkNum = Math.floor(idx / chunkSize);
            return this.getter(chunkNum)[chunkOffset];
          }
          LazyUint8Array.prototype.setDataGetter = function(getter) {
            this.getter = getter;
          }
    
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var chunkSize = 1024*1024; // Chunk size in bytes
          if (!hasByteServing) chunkSize = datalength;
    
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
    
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
    
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
    
          var lazyArray = new LazyUint8Array(chunkSize, datalength);
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * lazyArray.chunkSize;
            var end = (chunkNum+1) * lazyArray.chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile) {
        Browser.ensureObjects();
        var fullname = FS.joinPath([parent, name], true);
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },createLink:function (parent, name, target, canRead, canWrite) {
        var properties = {isDevice: false, link: target};
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createDevice:function (parent, name, input, output) {
        if (!(input || output)) {
          throw new Error('A device must have at least one callback defined.');
        }
        var ops = {isDevice: true, input: input, output: output};
        return FS.createFile(parent, name, ops, Boolean(input), Boolean(output));
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },ensureRoot:function () {
        if (FS.root) return;
        // The main file system tree. All the contents are inside this.
        FS.root = {
          read: true,
          write: true,
          isFolder: true,
          isDevice: false,
          timestamp: Date.now(),
          inodeNumber: 1,
          contents: {}
        };
      },init:function (input, output, error) {
        // Make sure we initialize only once.
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureRoot();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        input = input || Module['stdin'];
        output = output || Module['stdout'];
        error = error || Module['stderr'];
  
        // Default handlers.
        var stdinOverridden = true, stdoutOverridden = true, stderrOverridden = true;
        if (!input) {
          stdinOverridden = false;
          input = function() {
            if (!input.cache || !input.cache.length) {
              var result;
              if (typeof window != 'undefined' &&
                  typeof window.prompt == 'function') {
                // Browser.
                result = window.prompt('Input: ');
                if (result === null) result = String.fromCharCode(0); // cancel ==> EOF
              } else if (typeof readline == 'function') {
                // Command line.
                result = readline();
              }
              if (!result) result = '';
              input.cache = intArrayFromString(result + '\n', true);
            }
            return input.cache.shift();
          };
        }
        var utf8 = new Runtime.UTF8Processor();
        function simpleOutput(val) {
          if (val === null || val === '\n'.charCodeAt(0)) {
            output.printer(output.buffer.join(''));
            output.buffer = [];
          } else {
            output.buffer.push(utf8.processCChar(val));
          }
        }
        if (!output) {
          stdoutOverridden = false;
          output = simpleOutput;
        }
        if (!output.printer) output.printer = Module['print'];
        if (!output.buffer) output.buffer = [];
        if (!error) {
          stderrOverridden = false;
          error = simpleOutput;
        }
        if (!error.printer) error.printer = Module['print'];
        if (!error.buffer) error.buffer = [];
  
        // Create the temporary folder, if not already created
        try {
          FS.createFolder('/', 'tmp', true, true);
        } catch(e) {}
  
        // Create the I/O devices.
        var devFolder = FS.createFolder('/', 'dev', true, true);
        var stdin = FS.createDevice(devFolder, 'stdin', input);
        var stdout = FS.createDevice(devFolder, 'stdout', null, output);
        var stderr = FS.createDevice(devFolder, 'stderr', null, error);
        FS.createDevice(devFolder, 'tty', input, output);
  
        // Create default streams.
        FS.streams[1] = {
          path: '/dev/stdin',
          object: stdin,
          position: 0,
          isRead: true,
          isWrite: false,
          isAppend: false,
          isTerminal: !stdinOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        FS.streams[2] = {
          path: '/dev/stdout',
          object: stdout,
          position: 0,
          isRead: false,
          isWrite: true,
          isAppend: false,
          isTerminal: !stdoutOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        FS.streams[3] = {
          path: '/dev/stderr',
          object: stderr,
          position: 0,
          isRead: false,
          isWrite: true,
          isAppend: false,
          isTerminal: !stderrOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        // Allocate these on the stack (and never free, we are called from ATINIT or earlier), to keep their locations low
        _stdin = allocate([1], 'void*', ALLOC_STACK);
        _stdout = allocate([2], 'void*', ALLOC_STACK);
        _stderr = allocate([3], 'void*', ALLOC_STACK);
  
        // Other system paths
        FS.createPath('/', 'dev/shm/tmp', true, true); // temp files
  
        // Newlib initialization
        for (var i = FS.streams.length; i < Math.max(_stdin, _stdout, _stderr) + 4; i++) {
          FS.streams[i] = null; // Make sure to keep FS.streams dense
        }
        FS.streams[_stdin] = FS.streams[1];
        FS.streams[_stdout] = FS.streams[2];
        FS.streams[_stderr] = FS.streams[3];
        __impure_ptr = allocate([ allocate(
          [0, 0, 0, 0, _stdin, 0, 0, 0, _stdout, 0, 0, 0, _stderr, 0, 0, 0],
          'void*', ALLOC_STATIC) ], 'void*', ALLOC_STATIC);
      },quit:function () {
        if (!FS.init.initialized) return;
        // Flush any partially-printed lines in stdout and stderr. Careful, they may have been closed
        if (FS.streams[2] && FS.streams[2].object.output.buffer.length > 0) FS.streams[2].object.output('\n'.charCodeAt(0));
        if (FS.streams[3] && FS.streams[3].object.output.buffer.length > 0) FS.streams[3].object.output('\n'.charCodeAt(0));
      },standardizePath:function (path) {
        if (path.substr(0, 2) == './') path = path.substr(2);
        return path;
      },deleteFile:function (path) {
        var path = FS.analyzePath(path);
        if (!path.parentExists || !path.exists) {
          throw 'Invalid path ' + path;
        }
        delete path.parentObject.contents[path.name];
      }};
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.streams[fildes];
      if (!stream || stream.object.isDevice) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isWrite) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (stream.object.isFolder) {
        ___setErrNo(ERRNO_CODES.EISDIR);
        return -1;
      } else if (nbyte < 0 || offset < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var contents = stream.object.contents;
        while (contents.length < offset) contents.push(0);
        for (var i = 0; i < nbyte; i++) {
          contents[offset + i] = HEAPU8[((buf)+(i))];
        }
        stream.object.timestamp = Date.now();
        return i;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.streams[fildes];
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isWrite) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (nbyte < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        if (stream.object.isDevice) {
          if (stream.object.output) {
            for (var i = 0; i < nbyte; i++) {
              try {
                stream.object.output(HEAP8[((buf)+(i))]);
              } catch (e) {
                ___setErrNo(ERRNO_CODES.EIO);
                return -1;
              }
            }
            stream.object.timestamp = Date.now();
            return i;
          } else {
            ___setErrNo(ERRNO_CODES.ENXIO);
            return -1;
          }
        } else {
          var bytesWritten = _pwrite(fildes, buf, nbyte, stream.position);
          if (bytesWritten != -1) stream.position += bytesWritten;
          return bytesWritten;
        }
      }
    }
  
  function _strlen(ptr) {
      return String_len(ptr);
    }function _fputs(s, stream) {
      // int fputs(const char *restrict s, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputs.html
      return _write(stream, s, _strlen(s));
    }
  
  function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[(_fputc.ret)]=chr
      var ret = _write(stream, _fputc.ret, 1);
      if (ret == -1) {
        if (FS.streams[stream]) FS.streams[stream].error = true;
        return -1;
      } else {
        return chr;
      }
    }function _puts(s) {
      // int puts(const char *s);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/puts.html
      // NOTE: puts() always writes an extra newline.
      var stdout = HEAP32[((_stdout)>>2)];
      var ret = _fputs(s, stdout);
      if (ret < 0) {
        return ret;
      } else {
        var newlineRet = _fputc('\n'.charCodeAt(0), stdout);
        return (newlineRet < 0) ? -1 : ret + 1;
      }
    }
  
  var _putc=_fputc;
  
  
  
  var ERRNO_MESSAGES={1:"Operation not permitted",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"Input/output error",6:"No such device or address",8:"Exec format error",9:"Bad file descriptor",10:"No child processes",11:"Resource temporarily unavailable",12:"Cannot allocate memory",13:"Permission denied",14:"Bad address",16:"Device or resource busy",17:"File exists",18:"Invalid cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Inappropriate ioctl for device",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read-only file system",31:"Too many links",32:"Broken pipe",33:"Numerical argument out of domain",34:"Numerical result out of range",35:"Resource deadlock avoided",36:"File name too long",37:"No locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many levels of symbolic links",42:"No message of desired type",43:"Identifier removed",60:"Device not a stream",61:"No data available",62:"Timer expired",63:"Out of streams resources",67:"Link has been severed",71:"Protocol error",72:"Multihop attempted",74:"Bad message",75:"Value too large for defined data type",84:"Invalid or incomplete multibyte or wide character",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Protocol not supported",95:"Operation not supported",97:"Address family not supported by protocol",98:"Address already in use",99:"Cannot assign requested address",100:"Network is down",101:"Network is unreachable",102:"Network dropped connection on reset",103:"Software caused connection abort",104:"Connection reset by peer",105:"No buffer space available",106:"Transport endpoint is already connected",107:"Transport endpoint is not connected",110:"Connection timed out",111:"Connection refused",113:"No route to host",114:"Operation already in progress",115:"Operation now in progress",116:"Stale NFS file handle",122:"Disk quota exceeded",125:"Operation canceled",130:"Owner died",131:"State not recoverable"};function _strerror_r(errnum, strerrbuf, buflen) {
      if (errnum in ERRNO_MESSAGES) {
        if (ERRNO_MESSAGES[errnum].length > buflen - 1) {
          return ___setErrNo(ERRNO_CODES.ERANGE);
        } else {
          var msg = ERRNO_MESSAGES[errnum];
          for (var i = 0; i < msg.length; i++) {
            HEAP8[((strerrbuf)+(i))]=msg.charCodeAt(i)
          }
          HEAP8[((strerrbuf)+(i))]=0
          return 0;
        }
      } else {
        return ___setErrNo(ERRNO_CODES.EINVAL);
      }
    }function _strerror(errnum) {
      if (!_strerror.buffer) _strerror.buffer = _malloc(256);
      _strerror_r(errnum, _strerror.buffer, 256);
      return _strerror.buffer;
    }
  
  function ___errno_location() {
      return ___setErrNo.ret;
    }function _perror(s) {
      // void perror(const char *s);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/perror.html
      if (s) {
        _puts(s);
        _putc(':'.charCodeAt(0));
        _putc(' '.charCodeAt(0));
      }
      var errnum = HEAP32[((___errno_location())>>2)];
      _puts(_strerror(errnum));
    }

  function _gettimeofday(ptr) {
      // %struct.timeval = type { i32, i32 }
      var indexes = Runtime.calculateStructAlignment({ fields: ['i32', 'i32'] });
      var now = Date.now();
      HEAP32[(((ptr)+(indexes[0]))>>2)]=Math.floor(now/1000) // seconds
      HEAP32[(((ptr)+(indexes[1]))>>2)]=Math.floor((now-1000*Math.floor(now/1000))*1000) // microseconds
      return 0;
    }

  
  var ___hostent_struct_layout={__size__:20,h_name:0,h_aliases:4,h_addrtype:8,h_length:12,h_addr_list:16};function _gethostbyname(name) {
      name = Pointer_stringify(name);
        if (!_gethostbyname.id) {
          _gethostbyname.id = 1;
          _gethostbyname.table = {};
        }
      var id = _gethostbyname.id++;
      assert(id < 65535);
      var fakeAddr = 172 | (29 << 8) | ((id & 0xff) << 16) | ((id & 0xff00) << 24);
      _gethostbyname.table[id] = name;
      // generate hostent
      var ret = _malloc(___hostent_struct_layout.__size__);
      var nameBuf = _malloc(name.length+1);
      writeStringToMemory(name, nameBuf);
      setValue(ret+___hostent_struct_layout.h_name, nameBuf, 'i8*');
      var aliasesBuf = _malloc(4);
      setValue(aliasesBuf, 0, 'i8*');
      setValue(ret+___hostent_struct_layout.h_aliases, aliasesBuf, 'i8**');
      setValue(ret+___hostent_struct_layout.h_addrtype, 1, 'i32');
      setValue(ret+___hostent_struct_layout.h_length, 4, 'i32');
      var addrListBuf = _malloc(12);
      setValue(addrListBuf, addrListBuf+8, 'i32*');
      setValue(addrListBuf+4, 0, 'i32*');
      setValue(addrListBuf+8, fakeAddr, 'i32');
      setValue(ret+___hostent_struct_layout.h_addr_list, addrListBuf, 'i8**');
      return ret;
    }

  
  function _inet_addr(ptr) {
      var b = Pointer_stringify(ptr).split(".");
      if (b.length !== 4) return -1; // we return -1 for error, and otherwise a uint32. this helps inet_pton differentiate
      return (Number(b[0]) | (Number(b[1]) << 8) | (Number(b[2]) << 16) | (Number(b[3]) << 24)) >>> 0;
    }function _inet_aton(cp, inp) {
      var addr = _inet_addr(cp);
      setValue(inp, addr, 'i32');
      if (addr < 0) return 0;
      return 1;
    }

  
  
  function __inet_ntop_raw(addr) {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    }function _inet_ntop(af, src, dst, size) {
      var addr = getValue(src, 'i32');
      var str = __inet_ntop_raw(addr);
      writeStringToMemory(str.substr(0, size), dst);
      return dst;
    }function _inet_ntoa(in_addr) {
      if (!_inet_ntoa.buffer) {
        _inet_ntoa.buffer = _malloc(1024);
      }
      return _inet_ntop(0, in_addr, _inet_ntoa.buffer, 1024);
    }

  function _strncpy(pdest, psrc, num) {
      var padding = false, curr;
      for (var i = 0; i < num; i++) {
        curr = padding ? 0 : HEAP8[((psrc)+(i))];
        HEAP8[((pdest)+(i))]=curr
        padding = padding || HEAP8[((psrc)+(i))] == 0;
      }
      return pdest;
    }
var _gethostbyaddr; // stub for _gethostbyaddr

  
  
  var Sockets={BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},sockaddr_in_layout:{__size__:16,sin_family:0,sin_port:2,sin_addr:4,sin_zero:8},msghdr_layout:{__size__:28,msg_name:0,msg_namelen:4,msg_iov:8,msg_iovlen:12,msg_control:16,msg_controllen:20,msg_flags:24}};function _connect(fd, addr, addrlen) {
      var info = Sockets.fds[fd];
      if (!info) return -1;
      info.connected = true;
      info.addr = getValue(addr + Sockets.sockaddr_in_layout.sin_addr, 'i32');
      info.port = _ntohs(getValue(addr + Sockets.sockaddr_in_layout.sin_port, 'i16'));
      info.host = __inet_ntop_raw(info.addr);
      // Support 'fake' ips from gethostbyname
      var parts = info.host.split('.');
      if (parts[0] == '172' && parts[1] == '29') {
        var low = Number(parts[2]);
        var high = Number(parts[3]);
        info.host = _gethostbyname.table[low + 0xff*high];
        assert(info.host, 'problem translating fake ip ' + parts);
      }
      console.log('opening ws://' + info.host + ':' + info.port);
      info.socket = new WebSocket('ws://' + info.host + ':' + info.port, ['binary']);
      info.socket.binaryType = 'arraybuffer';
      info.buffer = new Uint8Array(Sockets.BUFFER_SIZE);
      info.bufferWrite = info.bufferRead = 0;
      info.socket.onmessage = function (event) {
        assert(typeof event.data !== 'string' && event.data.byteLength); // must get binary data!
        var data = new Uint8Array(event.data); // make a typed array view on the array buffer
        var len = data.length;
        for (var i = 0; i < len; i++) { // TODO: typed array set, carefully with ranges, or other trick
          info.buffer[info.bufferWrite++] = data[i];
          if (info.bufferWrite == info.buffer.length) info.bufferWrite = 0;
          if (info.bufferWrite == info.bufferRead) {
            // grow the buffer
            var currLen = info.buffer.length;
            if (currLen > Sockets.MAX_BUFFER_SIZE) throw 'socket buffer overflow';
            var newBuffer = new Uint8Array(currLen*2);
            for (var j = 0; j < currLen; j++) {
              newBuffer[j] = info.buffer[(info.bufferRead + j)%currLen];
            }
            info.bufferRead = 0;
            info.bufferWrite = currLen;
            info.buffer = newBuffer;
          }
        }
      }
      info.sendQueue = new Uint8Array(1024);
      info.sendQueueUsed = 0;
      info.senderWaiting = false;
      info.sender = function(data, justQueue) {
        if (data) {
          if (info.sendQueueUsed + data.length >= info.sendQueue.length) {
            var newQueue = new Uint8Array(2*Math.max(info.sendQueue.length, data.length));
            newQueue.set(info.sendQueue);
            info.sendQueue = newQueue;
          }
          info.sendQueue.set(data, info.sendQueueUsed); // must copy, because while this waits memory can change!
          info.sendQueueUsed += data.length;
        } else {
          info.senderWaiting = false; // we are a setTimeout callback
          if (info.sendQueueUsed == 0) return;
        }
        if (info.socket.readyState != info.socket.OPEN) {
          if (!info.senderWaiting) {
            console.log('waiting for socket in order to send');
            setTimeout(info.sender, 100);
            info.senderWaiting = true;
          }
          return;
        }
        if (justQueue) return;
        info.socket.send(new Uint8Array(info.sendQueue.subarray(0, info.sendQueueUsed)).buffer); // TODO: if browser accepts views, can optimize this
        info.sendQueueUsed = 0;
      };
      return 0;
    }function _bind(fd, addr, addrlen) {
      return _connect(fd, addr, addrlen);
    }

  function _listen(fd, backlog) {
      return 0;
    }

  function _socket(family, type, protocol) {
      var fd = Sockets.nextFd++;
      Sockets.fds[fd] = {
        connected: false
      };
      return fd;
    }

  function _setsockopt(d, level, optname, optval, optlen) {
      console.log('ignoring setsockopt command');
      return 0;
    }


  var ___errno=___errno_location;

  function _accept(fd, addr, addrlen) {
      // TODO: webrtc queued incoming connections, etc.
      // For now, the model is that bind does a connect, and we "accept" that one connection,
      // which has host:port the same as ours. We also return the same socket fd.
      var info = Sockets.fds[fd];
      if (!info) return -1;
      if (addr) {
        setValue(addr + Sockets.sockaddr_in_layout.sin_addr, info.addr, 'i32');
        setValue(addr + Sockets.sockaddr_in_layout.sin_port, info.port, 'i32');
        setValue(addrlen, Sockets.sockaddr_in_layout.__size__, 'i32');
      }
      return fd;
    }

  function _shutdown(fd, how) {
      var info = Sockets.fds[fd];
      if (!info) return -1;
      info.socket.close();
      Sockets.fds[fd] = null;
    }

  function _close(fildes) {
      // int close(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/close.html
      if (FS.streams[fildes]) {
        if (FS.streams[fildes].currentEntry) {
          _free(FS.streams[fildes].currentEntry);
        }
        FS.streams[fildes] = null;
        return 0;
      } else {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
    }

  function _sendmsg(fd, msg, flags) {
      var info = Sockets.fds[fd];
      if (!info) return -1;
      // if we are not connected, use the address info in the message
      if (!info.connected) {
        var name = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_name))>>2)];
        assert(name, 'sendmsg on non-connected socket, and no name/address in the message');
        _connect(fd, name, HEAP32[(((msg)+(Sockets.msghdr_layout.msg_namelen))>>2)]);
      }
      var iov = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_iov))>>2)];
      var num = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_iovlen))>>2)];
      var ret = 0;
      for (var i = 0; i < num; i++) {
        var currNum = HEAP32[(((iov)+(8*i + 4))>>2)];
        if (!currNum) continue;
        var currBuf = HEAP32[(((iov)+(8*i))>>2)];
        info.sender(HEAPU8.subarray(currBuf, currBuf+currNum), true);
        ret += currNum;
      }
      info.sender(null); // flush all of these together. Important they get sent as a single socket message
      return ret;
    }

  
  function _recv(fd, buf, len, flags) {
      var info = Sockets.fds[fd];
      if (!info) return -1;
      if (info.bufferWrite == info.bufferRead) {
        ___setErrNo(ERRNO_CODES.EAGAIN); // no data, and all sockets are nonblocking, so this is the right behavior
        return 0; // should this be -1 like the spec says?
      }
      var ret = 0;
      while (info.bufferWrite != info.bufferRead && len > 0) {
        // write out a byte
        HEAP8[(buf++)]=info.buffer[info.bufferRead++];
        if (info.bufferRead == info.buffer.length) info.bufferRead = 0;
        len--;
        ret++;
      }
      return ret;
    }function _recvmsg(fd, msg, flags) {
      var info = Sockets.fds[fd];
      if (!info) return -1;
      // if we are not connected, use the address info in the message
      if (!info.connected) {
        var name = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_name))>>2)];
        assert(name, 'sendmsg on non-connected socket, and no name/address in the message');
        _connect(fd, name, HEAP32[(((msg)+(Sockets.msghdr_layout.msg_namelen))>>2)]);
      }
      var bytes = info.bufferWrite - info.bufferRead;
      if (bytes < 0) bytes += info.buffer.length;
      if (bytes == 0) {
        ___setErrNo(ERRNO_CODES.EWOULDBLOCK);
        return -1;
      }
      // write source
      var name = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_name))>>2)];
      HEAP32[(((name)+(Sockets.sockaddr_in_layout.sin_addr))>>2)]=info.addr;
      HEAP16[(((name)+(Sockets.sockaddr_in_layout.sin_port))>>1)]=_htons(info.port);
      // write data
      var ret = bytes;
      var iov = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_iov))>>2)];
      var num = HEAP32[(((msg)+(Sockets.msghdr_layout.msg_iovlen))>>2)];
      var data = '';
      for (var i = 0; i < num && bytes > 0; i++) {
        var currNum = HEAP32[(((iov)+(8*i + 4))>>2)];
        if (!currNum) continue;
        currNum = Math.min(currNum, bytes); // XXX what should happen when we partially fill a buffer..?
        bytes -= currNum;
        var currBuf = HEAP32[(((iov)+(8*i))>>2)];
        assert(_recv(fd, currBuf, currNum, 0) == currNum);
      }
      return ret;
    }
var _select; // stub for _select

  
  function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var bytesWritten = _write(stream, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        if (FS.streams[stream]) FS.streams[stream].error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }
  
  function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = (tempDoubleI32[0]=HEAP32[(((varargs)+(argIndex))>>2)],tempDoubleI32[1]=HEAP32[(((varargs)+((argIndex)+(4)))>>2)],tempDoubleF64[0]);
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[(textIndex+1)];
        if (curr == '%'.charCodeAt(0)) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          flagsLoop: while (1) {
            switch (next) {
              case '+'.charCodeAt(0):
                flagAlwaysSigned = true;
                break;
              case '-'.charCodeAt(0):
                flagLeftAlign = true;
                break;
              case '#'.charCodeAt(0):
                flagAlternative = true;
                break;
              case '0'.charCodeAt(0):
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[(textIndex+1)];
          }
  
          // Handle width.
          var width = 0;
          if (next == '*'.charCodeAt(0)) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[(textIndex+1)];
          } else {
            while (next >= '0'.charCodeAt(0) && next <= '9'.charCodeAt(0)) {
              width = width * 10 + (next - '0'.charCodeAt(0));
              textIndex++;
              next = HEAP8[(textIndex+1)];
            }
          }
  
          // Handle precision.
          var precisionSet = false;
          if (next == '.'.charCodeAt(0)) {
            var precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[(textIndex+1)];
            if (next == '*'.charCodeAt(0)) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[(textIndex+1)];
                if (precisionChr < '0'.charCodeAt(0) ||
                    precisionChr > '9'.charCodeAt(0)) break;
                precision = precision * 10 + (precisionChr - '0'.charCodeAt(0));
                textIndex++;
              }
            }
            next = HEAP8[(textIndex+1)];
          } else {
            var precision = 6; // Standard default.
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[(textIndex+2)];
              if (nextNext == 'h'.charCodeAt(0)) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[(textIndex+2)];
              if (nextNext == 'l'.charCodeAt(0)) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[(textIndex+1)];
  
          // Handle type specifier.
          if (['d', 'i', 'u', 'o', 'x', 'X', 'p'].indexOf(String.fromCharCode(next)) != -1) {
            // Integer.
            var signed = next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0);
            argSize = argSize || 4;
            var currArg = getNextArg('i' + (argSize * 8));
            var origArg = currArg;
            var argText;
            // Flatten i64-1 [low, high] into a (slightly rounded) double
            if (argSize == 8) {
              currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 'u'.charCodeAt(0));
            }
            // Truncate to requested size.
            if (argSize <= 4) {
              var limit = Math.pow(256, argSize) - 1;
              currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
            }
            // Format the number.
            var currAbsArg = Math.abs(currArg);
            var prefix = '';
            if (next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
              argText = reSign(currArg, 8 * argSize, 1).toString(10);
            } else if (next == 'u'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
              argText = unSign(currArg, 8 * argSize, 1).toString(10);
              currArg = Math.abs(currArg);
            } else if (next == 'o'.charCodeAt(0)) {
              argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
            } else if (next == 'x'.charCodeAt(0) || next == 'X'.charCodeAt(0)) {
              prefix = flagAlternative ? '0x' : '';
              if (argSize == 8 && i64Math) argText = (origArg[1]>>>0).toString(16) + (origArg[0]>>>0).toString(16); else
              if (currArg < 0) {
                // Represent negative numbers in hex as 2's complement.
                currArg = -currArg;
                argText = (currAbsArg - 1).toString(16);
                var buffer = [];
                for (var i = 0; i < argText.length; i++) {
                  buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                }
                argText = buffer.join('');
                while (argText.length < argSize * 2) argText = 'f' + argText;
              } else {
                argText = currAbsArg.toString(16);
              }
              if (next == 'X'.charCodeAt(0)) {
                prefix = prefix.toUpperCase();
                argText = argText.toUpperCase();
              }
            } else if (next == 'p'.charCodeAt(0)) {
              if (currAbsArg === 0) {
                argText = '(nil)';
              } else {
                prefix = '0x';
                argText = currAbsArg.toString(16);
              }
            }
            if (precisionSet) {
              while (argText.length < precision) {
                argText = '0' + argText;
              }
            }
  
            // Add sign if needed
            if (flagAlwaysSigned) {
              if (currArg < 0) {
                prefix = '-' + prefix;
              } else {
                prefix = '+' + prefix;
              }
            }
  
            // Add padding.
            while (prefix.length + argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad) {
                  argText = '0' + argText;
                } else {
                  prefix = ' ' + prefix;
                }
              }
            }
  
            // Insert the result into the buffer.
            argText = prefix + argText;
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (['f', 'F', 'e', 'E', 'g', 'G'].indexOf(String.fromCharCode(next)) != -1) {
            // Float.
            var currArg = getNextArg('double');
            var argText;
  
            if (isNaN(currArg)) {
              argText = 'nan';
              flagZeroPad = false;
            } else if (!isFinite(currArg)) {
              argText = (currArg < 0 ? '-' : '') + 'inf';
              flagZeroPad = false;
            } else {
              var isGeneral = false;
              var effectivePrecision = Math.min(precision, 20);
  
              // Convert g/G to f/F or e/E, as per:
              // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
              if (next == 'g'.charCodeAt(0) || next == 'G'.charCodeAt(0)) {
                isGeneral = true;
                precision = precision || 1;
                var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                if (precision > exponent && exponent >= -4) {
                  next = ((next == 'g'.charCodeAt(0)) ? 'f' : 'F').charCodeAt(0);
                  precision -= exponent + 1;
                } else {
                  next = ((next == 'g'.charCodeAt(0)) ? 'e' : 'E').charCodeAt(0);
                  precision--;
                }
                effectivePrecision = Math.min(precision, 20);
              }
  
              if (next == 'e'.charCodeAt(0) || next == 'E'.charCodeAt(0)) {
                argText = currArg.toExponential(effectivePrecision);
                // Make sure the exponent has at least 2 digits.
                if (/[eE][-+]\d$/.test(argText)) {
                  argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                }
              } else if (next == 'f'.charCodeAt(0) || next == 'F'.charCodeAt(0)) {
                argText = currArg.toFixed(effectivePrecision);
              }
  
              var parts = argText.split('e');
              if (isGeneral && !flagAlternative) {
                // Discard trailing zeros and periods.
                while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                       (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                  parts[0] = parts[0].slice(0, -1);
                }
              } else {
                // Make sure we have a period in alternative mode.
                if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                // Zero pad until required precision.
                while (precision > effectivePrecision++) parts[0] += '0';
              }
              argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
              // Capitalize 'E' if needed.
              if (next == 'E'.charCodeAt(0)) argText = argText.toUpperCase();
  
              // Add sign.
              if (flagAlwaysSigned && currArg >= 0) {
                argText = '+' + argText;
              }
            }
  
            // Add padding.
            while (argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                  argText = argText[0] + '0' + argText.slice(1);
                } else {
                  argText = (flagZeroPad ? '0' : ' ') + argText;
                }
              }
            }
  
            // Adjust case.
            if (next < 'a'.charCodeAt(0)) argText = argText.toUpperCase();
  
            // Insert the result into the buffer.
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (next == 's'.charCodeAt(0)) {
            // String.
            var arg = getNextArg('i8*') || nullString;
            var argLength = String_len(arg);
            if (precisionSet) argLength = Math.min(argLength, precision);
            if (!flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
            for (var i = 0; i < argLength; i++) {
              ret.push(HEAPU8[(arg++)]);
            }
            if (flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
          } else if (next == 'c'.charCodeAt(0)) {
            // Character.
            if (flagLeftAlign) ret.push(getNextArg('i8'));
            while (--width > 0) {
              ret.push(' '.charCodeAt(0));
            }
            if (!flagLeftAlign) ret.push(getNextArg('i8'));
          } else if (next == 'n'.charCodeAt(0)) {
            // Write the length written so far to the next parameter.
            var ptr = getNextArg('i32*');
            HEAP32[((ptr)>>2)]=ret.length
          } else if (next == '%'.charCodeAt(0)) {
            // Literal percent sign.
            ret.push(curr);
          } else {
            // Unknown specifiers remain untouched.
            for (var i = startTextIndex; i < textIndex + 2; i++) {
              ret.push(HEAP8[(i)]);
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 8: return PAGE_SIZE;
        case 54:
        case 56:
        case 21:
        case 61:
        case 63:
        case 22:
        case 67:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 69:
        case 28:
        case 101:
        case 70:
        case 71:
        case 29:
        case 30:
        case 199:
        case 75:
        case 76:
        case 32:
        case 43:
        case 44:
        case 80:
        case 46:
        case 47:
        case 45:
        case 48:
        case 49:
        case 42:
        case 82:
        case 33:
        case 7:
        case 108:
        case 109:
        case 107:
        case 112:
        case 119:
        case 121:
          return 200809;
        case 13:
        case 104:
        case 94:
        case 95:
        case 34:
        case 35:
        case 77:
        case 81:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 94:
        case 95:
        case 110:
        case 111:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 120:
        case 40:
        case 16:
        case 79:
        case 19:
          return -1;
        case 92:
        case 93:
        case 5:
        case 72:
        case 6:
        case 74:
        case 92:
        case 93:
        case 96:
        case 97:
        case 98:
        case 99:
        case 102:
        case 103:
        case 105:
          return 1;
        case 38:
        case 66:
        case 50:
        case 51:
        case 4:
          return 1024;
        case 15:
        case 64:
        case 41:
          return 32;
        case 55:
        case 37:
        case 17:
          return 2147483647;
        case 18:
        case 1:
          return 47839;
        case 59:
        case 57:
          return 99;
        case 68:
        case 58:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 14: return 32768;
        case 73: return 32767;
        case 39: return 16384;
        case 60: return 1000;
        case 106: return 700;
        case 52: return 256;
        case 62: return 255;
        case 2: return 100;
        case 65: return 64;
        case 36: return 20;
        case 100: return 16;
        case 20: return 6;
        case 53: return 4;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
  
      // We need to make sure no one else allocates unfreeable memory!
      // We must control this entirely. So we don't even need to do
      // unfreeable allocations - the HEAP is ours, from STATICTOP up.
      // TODO: We could in theory slice off the top of the HEAP when
      //       sbrk gets a negative increment in |bytes|...
      var self = _sbrk;
      if (!self.called) {
        STATICTOP = alignMemoryPage(STATICTOP); // make sure we start out aligned
        self.called = true;
        _sbrk.DYNAMIC_START = STATICTOP;
      }
      var ret = STATICTOP;
      if (bytes != 0) Runtime.staticAlloc(bytes);
      return ret;  // Previous break location.
    }

  function ___gxx_personality_v0() {
    }

  function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }

  
  function _llvm_eh_exception() {
      return HEAP32[((_llvm_eh_exception.buf)>>2)];
    }
  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
  
  
  
  function ___cxa_is_number_type(type) {
      var isNumber = false;
      try { if (type == __ZTIi) isNumber = true } catch(e){}
      try { if (type == __ZTIj) isNumber = true } catch(e){}
      try { if (type == __ZTIl) isNumber = true } catch(e){}
      try { if (type == __ZTIm) isNumber = true } catch(e){}
      try { if (type == __ZTIx) isNumber = true } catch(e){}
      try { if (type == __ZTIy) isNumber = true } catch(e){}
      try { if (type == __ZTIf) isNumber = true } catch(e){}
      try { if (type == __ZTId) isNumber = true } catch(e){}
      try { if (type == __ZTIe) isNumber = true } catch(e){}
      try { if (type == __ZTIc) isNumber = true } catch(e){}
      try { if (type == __ZTIa) isNumber = true } catch(e){}
      try { if (type == __ZTIh) isNumber = true } catch(e){}
      try { if (type == __ZTIs) isNumber = true } catch(e){}
      try { if (type == __ZTIt) isNumber = true } catch(e){}
      return isNumber;
    }function ___cxa_does_inherit(definiteType, possibilityType, possibility) {
      if (possibility == 0) return false;
      if (possibilityType == 0 || possibilityType == definiteType)
        return true;
      var possibility_type_info;
      if (___cxa_is_number_type(possibilityType)) {
        possibility_type_info = possibilityType;
      } else {
        var possibility_type_infoAddr = HEAP32[((possibilityType)>>2)] - 8;
        possibility_type_info = HEAP32[((possibility_type_infoAddr)>>2)];
      }
      switch (possibility_type_info) {
      case 0: // possibility is a pointer
        // See if definite type is a pointer
        var definite_type_infoAddr = HEAP32[((definiteType)>>2)] - 8;
        var definite_type_info = HEAP32[((definite_type_infoAddr)>>2)];
        if (definite_type_info == 0) {
          // Also a pointer; compare base types of pointers
          var defPointerBaseAddr = definiteType+8;
          var defPointerBaseType = HEAP32[((defPointerBaseAddr)>>2)];
          var possPointerBaseAddr = possibilityType+8;
          var possPointerBaseType = HEAP32[((possPointerBaseAddr)>>2)];
          return ___cxa_does_inherit(defPointerBaseType, possPointerBaseType, possibility);
        } else
          return false; // one pointer and one non-pointer
      case 1: // class with no base class
        return false;
      case 2: // class with base class
        var parentTypeAddr = possibilityType + 8;
        var parentType = HEAP32[((parentTypeAddr)>>2)];
        return ___cxa_does_inherit(definiteType, parentType, possibility);
      default:
        return false; // some unencountered type
      }
    }function ___cxa_find_matching_catch(thrown, throwntype, typeArray) {
      // If throwntype is a pointer, this means a pointer has been
      // thrown. When a pointer is thrown, actually what's thrown
      // is a pointer to the pointer. We'll dereference it.
      if (throwntype != 0 && !___cxa_is_number_type(throwntype)) {
        var throwntypeInfoAddr= HEAP32[((throwntype)>>2)] - 8;
        var throwntypeInfo= HEAP32[((throwntypeInfoAddr)>>2)];
        if (throwntypeInfo == 0)
          thrown = HEAP32[((thrown)>>2)];
      }
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (___cxa_does_inherit(typeArray[i], throwntype, thrown))
          return { f0:thrown, f1:typeArray[i] };
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      return { f0:thrown, f1 :throwntype };
    }function ___cxa_throw(ptr, type, destructor) {
      if (!___cxa_throw.initialized) {
        try {
          HEAP32[((__ZTVN10__cxxabiv119__pointer_type_infoE)>>2)]=0; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv117__class_type_infoE)>>2)]=1; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv120__si_class_type_infoE)>>2)]=2; // Workaround for libcxxabi integration bug
        } catch(e){}
        ___cxa_throw.initialized = true;
      }
      Module.printErr('Compiled code throwing an exception, ' + [ptr,type,destructor] + ', at ' + new Error().stack);
      HEAP32[((_llvm_eh_exception.buf)>>2)]=ptr
      HEAP32[(((_llvm_eh_exception.buf)+(4))>>2)]=type
      HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)]=destructor
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr;
    }

  function ___cxa_call_unexpected(exception) {
      ABORT = true;
      throw exception;
    }

  function ___cxa_begin_catch(ptr) {
      __ZSt18uncaught_exceptionv.uncaught_exception--;
      return ptr;
    }

  
  function ___cxa_free_exception(ptr) {
      return _free(ptr);
    }function ___cxa_end_catch() {
      if (___cxa_end_catch.rethrown) {
        ___cxa_end_catch.rethrown = false;
        return;
      }
      // Clear state flag.
      __THREW__ = false;
      // Clear type.
      HEAP32[(((_llvm_eh_exception.buf)+(4))>>2)]=0
      // Call destructor if one is registered then clear it.
      var ptr = HEAP32[((_llvm_eh_exception.buf)>>2)];
      var destructor = HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)];
      if (destructor) {
        FUNCTION_TABLE[destructor](ptr);
        HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)]=0
      }
      // Free ptr if it isn't null.
      if (ptr) {
        ___cxa_free_exception(ptr);
        HEAP32[((_llvm_eh_exception.buf)>>2)]=0
      }
    }
var __ZNSt9exceptionD2Ev; // stub for __ZNSt9exceptionD2Ev

  var _llvm_memset_p0i8_i64=_memset;





  var Browser={mainLoop:{scheduler:null,shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],ensureObjects:function () {
        if (Browser.ensured) return;
        Browser.ensured = true;
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : console.log("warning: cannot create object URLs");
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        function getMimetype(name) {
          return {
            'jpg': 'image/jpeg',
            'png': 'image/png',
            'bmp': 'image/bmp',
            'ogg': 'audio/ogg',
            'wav': 'audio/wav',
            'mp3': 'audio/mpeg'
          }[name.substr(-3)];
          return ret;
        }
  
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = [];
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function(name) {
          return name.substr(-4) in { '.jpg': 1, '.png': 1, '.bmp': 1 };
        };
        imagePlugin['handle'] = function(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = function() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function(name) {
          return name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            setTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
      },createContext:function (canvas, useWebGL, setInModule) {
        try {
          var ctx = canvas.getContext(useWebGL ? 'experimental-webgl' : '2d');
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas - ' + e);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
  
          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
        }
        return ctx;
      },requestFullScreen:function () {
        var canvas = Module['canvas'];
        function fullScreenChange() {
          var isFullScreen = false;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement']) === canvas) {
            canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                        canvas['mozRequestPointerLock'] ||
                                        canvas['webkitRequestPointerLock'];
            canvas.requestPointerLock();
            isFullScreen = true;
          }
          if (Module['onFullScreen']) Module['onFullScreen'](isFullScreen);
        }
  
        document.addEventListener('fullscreenchange', fullScreenChange, false);
        document.addEventListener('mozfullscreenchange', fullScreenChange, false);
        document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas;
        }
  
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
  
        canvas.requestFullScreen = canvas['requestFullScreen'] ||
                                   canvas['mozRequestFullScreen'] ||
                                   (canvas['webkitRequestFullScreen'] ? function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvas.requestFullScreen(); 
      },requestAnimationFrame:function (func) {
        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                         window['mozRequestAnimationFrame'] ||
                                         window['webkitRequestAnimationFrame'] ||
                                         window['msRequestAnimationFrame'] ||
                                         window['oRequestAnimationFrame'] ||
                                         window['setTimeout'];
        }
        window.requestAnimationFrame(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          if (xhr.status == 200) {
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        canvas.width = width;
        canvas.height = height;
        if (!noUpdates) Browser.updateResizeListeners();
      }};
__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___setErrNo(0);
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
_llvm_eh_exception.buf = allocate(12, "void*", ALLOC_STATIC);
Module["requestFullScreen"] = function() { Browser.requestFullScreen() };
  Module["requestAnimationFrame"] = function(func) { Browser.requestAnimationFrame(func) };
  Module["pauseMainLoop"] = function() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function() { Browser.mainLoop.resume() };
  

// Note: For maximum-speed code, see "Optimizing Code" on the Emscripten wiki, https://github.com/kripken/emscripten/wiki/Optimizing-Code
// Note: Some Emscripten settings may limit the speed of the generated code.

function _jsapi_event_get_type($event) {
  return HEAP32[$event >> 2];
}
function _jsapi_event_get_peer($event) {
  return HEAP32[$event + 4 >> 2];
}
function _jsapi_event_get_channelID($event) {
  return HEAP8[$event + 8 | 0] & 255;
}
function _jsapi_event_get_packet($event) {
  return HEAP32[$event + 16 >> 2];
}
function _jsapi_event_get_data($event) {
  return HEAP32[$event + 12 >> 2];
}
function _jsapi_address_get_host($address) {
  return $address | 0;
}
function _jsapi_address_get_port($address) {
  return HEAP16[$address + 4 >> 1] & 65535;
}
function _jsapi_packet_get_data($packet) {
  return HEAP32[$packet + 8 >> 2];
}
function _jsapi_packet_get_dataLength($packet) {
  return HEAP32[$packet + 12 >> 2];
}
function _jsapi_host_get_receivedAddress($host) {
  return $host + 10348 | 0;
}
function _jsapi_host_get_peerCount($host) {
  return HEAP32[$host + 40 >> 2];
}
function _jsapi_host_get_channelLimit($host) {
  return HEAP32[$host + 44 >> 2];
}
function _jsapi_host_get_receivedData($host) {
  return HEAP32[$host + 10356 >> 2];
}
function _jsapi_host_get_receivedDataLength($host) {
  return HEAP32[$host + 10360 >> 2];
}
function _jsapi_host_get_socket($host) {
  return HEAP32[$host >> 2];
}
function _jsapi_peer_get_address($peer) {
  return $peer + 24 | 0;
}
function _jsapi_peer_get_data($peer) {
  return HEAP32[$peer + 32 >> 2];
}
function _jsapi_peer_get_channelCount($peer) {
  return HEAP32[$peer + 44 >> 2];
}
function _enet_initialize_with_callbacks($version, $inits) {
  var label;
  if ($version >>> 0 < 66304) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $3 = $inits | 0;
  var $4 = HEAP32[$3 >> 2];
  do {
    if (($4 | 0) == 0) {
      if ((HEAP32[$inits + 4 >> 2] | 0) == 0) {
        break;
      }
      var $_pr = HEAP32[$3 >> 2];
      if (($_pr | 0) == 0) {
        var $_0 = -1;
      } else {
        var $12 = $_pr;
        label = 23;
        break;
      }
      var $_0;
      return $_0;
    } else {
      var $12 = $4;
      label = 23;
    }
  } while (0);
  do {
    if (label == 23) {
      var $12;
      var $13 = $inits + 4 | 0;
      if ((HEAP32[$13 >> 2] | 0) == 0) {
        var $_0 = -1;
        var $_0;
        return $_0;
      } else {
        HEAP32[_callbacks_0 >> 2] = $12;
        HEAP32[_callbacks_1 >> 2] = HEAP32[$13 >> 2];
        break;
      }
    }
  } while (0);
  var $20 = HEAP32[$inits + 8 >> 2];
  if (($20 | 0) != 0) {
    HEAP32[_callbacks_2 >> 2] = $20;
  }
  var $25 = HEAP32[$inits + 12 >> 2];
  if (($25 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  HEAP32[_callbacks_3 >> 2] = $25;
  var $_0 = 0;
  var $_0;
  return $_0;
}
function _packet_filter($host) {
  return __packet_filter($host);
}
function _jsapi_init($filter) {
  var $3$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 16;
  var $callbacks = __stackBase__;
  if (($filter | 0) == 0) {
    STACKTOP = __stackBase__;
    return;
  }
  var $3$s2 = $callbacks >> 2;
  HEAP32[$3$s2] = HEAP32[_jsapi_init_callbacks >> 2];
  HEAP32[$3$s2 + 1] = HEAP32[_jsapi_init_callbacks + 4 >> 2];
  HEAP32[$3$s2 + 2] = HEAP32[_jsapi_init_callbacks + 8 >> 2];
  HEAP32[$3$s2 + 3] = HEAP32[_jsapi_init_callbacks + 12 >> 2];
  _enet_initialize_with_callbacks(66309, $callbacks);
  STACKTOP = __stackBase__;
  return;
}
function _jsapi_enet_host_create($host, $port, $maxpeers, $maxchannels, $bw_in, $bw_out) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var $address = __stackBase__;
  HEAP32[$address >> 2] = $host;
  HEAP16[$address + 4 >> 1] = $port & 65535;
  var $4 = _enet_host_create($address, $maxpeers, $maxchannels, $bw_in, $bw_out);
  STACKTOP = __stackBase__;
  return $4;
}
function _jsapi_enet_host_connect($host, $destinationHost, $port, $channelCount, $data) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var $address = __stackBase__;
  HEAP32[$address >> 2] = $destinationHost;
  HEAP16[$address + 4 >> 1] = $port & 65535;
  var $4 = _enet_host_connect($host, $address, $channelCount, $data);
  STACKTOP = __stackBase__;
  return $4;
}
function _jsapi_event_new() {
  return _malloc(20);
}
function _jsapi_event_free($event) {
  _free($event);
  return;
}
function _enet_malloc($size) {
  var $2 = FUNCTION_TABLE[HEAP32[_callbacks_0 >> 2]]($size);
  if (($2 | 0) != 0) {
    return $2;
  }
  FUNCTION_TABLE[HEAP32[_callbacks_2 >> 2]]();
  return $2;
}
function _enet_free($memory) {
  FUNCTION_TABLE[HEAP32[_callbacks_1 >> 2]]($memory);
  return;
}
function _enet_packet_filter($host) {
  do {
    if ((HEAP32[$host + 10360 >> 2] | 0) == 0) {
      var $_0 = 1;
    } else {
      var $5 = HEAP32[_callbacks_3 >> 2];
      if (($5 | 0) == 0) {
        var $_0 = 1;
        break;
      }
      var $_0 = FUNCTION_TABLE[$5]($host);
    }
  } while (0);
  var $_0;
  return $_0;
}
function _enet_range_coder_create() {
  return _enet_malloc(65536);
}
function _enet_range_coder_destroy($context) {
  if (($context | 0) == 0) {
    return;
  }
  _enet_free($context);
  return;
}
function _enet_range_coder_compress($context, $inBuffers, $inBufferCount, $inLimit, $outData, $outLimit) {
  var $286$s1;
  var $261$s1;
  var $231$s1;
  var $164$s1;
  var $132$s1;
  var $111$s1;
  var $86$s1;
  var $56$s1;
  var $41$s1;
  var $20$s1;
  var $18$s1;
  var $16$s1;
  var $13$s1;
  var $predicted$s1;
  var __stackBase__ = STACKTOP;
  STACKTOP += 4;
  var label;
  var $predicted = __stackBase__, $predicted$s1 = $predicted >> 1;
  var $1 = $outData + $outLimit | 0;
  HEAP16[$predicted$s1] = 0;
  if (($context | 0) == 0 | ($inBufferCount | 0) == 0 | ($inLimit | 0) == 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $7 = HEAP32[$inBuffers >> 2];
  var $10 = $7 + HEAP32[$inBuffers + 4 >> 2] | 0;
  var $11 = $inBuffers + 8 | 0;
  var $12 = $inBufferCount - 1 | 0;
  var $13 = $context, $13$s1 = $13 >> 1;
  var $14 = $context;
  var $16$s1 = ($context + 8 | 0) >> 1;
  var $18$s1 = ($context + 10 | 0) >> 1;
  var $20$s1 = ($context + 12 | 0) >> 1;
  for (var $$dest = $context, $$stop = $$dest + 16; $$dest < $$stop; $$dest++) {
    HEAP8[$$dest] = 0;
  }
  HEAP16[$18$s1] = 1;
  HEAP16[$20$s1] = 257;
  HEAP16[$16$s1] = 0;
  var $21 = $context;
  var $22 = $context;
  var $23 = $context;
  var $_01 = $11;
  var $_02 = $12;
  var $_04 = $outData;
  var $inData_0 = $7;
  var $inEnd_0 = $10;
  var $encodeLow_0 = 0;
  var $encodeRange_0 = -1;
  var $order_0 = 0;
  var $nextSymbol_0 = 1;
  L70 : while (1) {
    var $nextSymbol_0;
    var $order_0;
    var $encodeRange_0;
    var $encodeLow_0;
    var $inEnd_0;
    var $inData_0;
    var $_04;
    var $_02;
    var $_01;
    if ($inData_0 >>> 0 < $inEnd_0 >>> 0) {
      var $_1 = $_01;
      var $_13 = $_02;
      var $inData_1 = $inData_0;
      var $inEnd_1 = $inEnd_0;
    } else {
      if (($_02 | 0) == 0) {
        var $_8 = $_04;
        var $encodeLow_8 = $encodeLow_0;
        label = 130;
        break;
      }
      var $29 = HEAP32[$_01 >> 2];
      var $_1 = $_01 + 8 | 0;
      var $_13 = $_02 - 1 | 0;
      var $inData_1 = $29;
      var $inEnd_1 = $29 + HEAP32[$_01 + 4 >> 2] | 0;
    }
    var $inEnd_1;
    var $inData_1;
    var $_13;
    var $_1;
    var $36 = $inData_1 + 1 | 0;
    var $37 = HEAP8[$inData_1];
    var $_15 = $_04;
    var $parent_0 = $predicted;
    var $encodeLow_1 = $encodeLow_0;
    var $encodeRange_1 = $encodeRange_0;
    var $nextSymbol_1 = $nextSymbol_0;
    var $_pn_in_in = $predicted;
    while (1) {
      var $_pn_in_in;
      var $nextSymbol_1;
      var $encodeRange_1;
      var $encodeLow_1;
      var $parent_0;
      var $_15;
      var $_pn = HEAP16[$_pn_in_in >> 1] & 65535;
      var $subcontext_0 = ($_pn << 4) + $13 | 0;
      if (($subcontext_0 | 0) == ($14 | 0)) {
        label = 102;
        break;
      }
      var $41$s1 = (($_pn << 4) + $13 + 8 | 0) >> 1;
      var $42 = HEAP16[$41$s1];
      do {
        if ($42 << 16 >> 16 == 0) {
          var $46 = ($nextSymbol_1 << 4) + $13 | 0;
          HEAP8[$46 | 0] = $37;
          HEAP8[($nextSymbol_1 << 4) + $13 + 1 | 0] = 2;
          HEAP16[(($nextSymbol_1 << 4) + 2 >> 1) + $13$s1] = 2;
          var $56$s1 = (($nextSymbol_1 << 4) + $13 + 4 | 0) >> 1;
          HEAP16[$56$s1] = 0;
          HEAP16[$56$s1 + 1] = 0;
          HEAP16[$56$s1 + 2] = 0;
          HEAP16[$56$s1 + 3] = 0;
          HEAP16[$56$s1 + 4] = 0;
          HEAP16[$56$s1 + 5] = 0;
          HEAP16[$41$s1] = ($46 - $subcontext_0 | 0) >>> 4 & 65535;
          var $under_1 = 0;
          var $count_0 = 0;
          var $nextSymbol_2 = $nextSymbol_1 + 1 | 0;
          var $symbol_0 = $46;
        } else {
          var $node_0_ph = (($42 & 65535) + $_pn << 4) + $13 | 0;
          var $under_0_ph = 0;
          L82 : while (1) {
            var $under_0_ph;
            var $node_0_ph;
            var $node_0 = $node_0_ph;
            while (1) {
              var $node_0;
              var $62 = HEAP8[$node_0 | 0];
              if (($37 & 255) >= ($62 & 255)) {
                break;
              }
              var $65 = $node_0 + 2 | 0;
              HEAP16[$65 >> 1] = HEAP16[$65 >> 1] + 2 & 65535;
              var $68 = $node_0 + 4 | 0;
              var $69 = HEAP16[$68 >> 1];
              if ($69 << 16 >> 16 == 0) {
                label = 75;
                break L82;
              }
              var $node_0 = (($69 & 65535) << 4) + $node_0 | 0;
            }
            if (($37 & 255) <= ($62 & 255)) {
              label = 80;
              break;
            }
            var $92 = HEAP16[$node_0 + 2 >> 1] + $under_0_ph & 65535;
            var $93 = $node_0 + 6 | 0;
            var $94 = HEAP16[$93 >> 1];
            if ($94 << 16 >> 16 == 0) {
              label = 79;
              break;
            }
            var $node_0_ph = (($94 & 65535) << 4) + $node_0 | 0;
            var $under_0_ph = $92;
          }
          if (label == 75) {
            label = 0;
            var $76 = ($nextSymbol_1 << 4) + $13 | 0;
            HEAP8[$76 | 0] = $37;
            HEAP8[($nextSymbol_1 << 4) + $13 + 1 | 0] = 2;
            HEAP16[(($nextSymbol_1 << 4) + 2 >> 1) + $13$s1] = 2;
            var $86$s1 = (($nextSymbol_1 << 4) + $13 + 4 | 0) >> 1;
            HEAP16[$86$s1] = 0;
            HEAP16[$86$s1 + 1] = 0;
            HEAP16[$86$s1 + 2] = 0;
            HEAP16[$86$s1 + 3] = 0;
            HEAP16[$86$s1 + 4] = 0;
            HEAP16[$86$s1 + 5] = 0;
            HEAP16[$68 >> 1] = ($76 - $node_0 | 0) >>> 4 & 65535;
            var $under_1 = $under_0_ph;
            var $count_0 = 0;
            var $nextSymbol_2 = $nextSymbol_1 + 1 | 0;
            var $symbol_0 = $76;
            break;
          } else if (label == 79) {
            label = 0;
            var $101 = ($nextSymbol_1 << 4) + $13 | 0;
            HEAP8[$101 | 0] = $37;
            HEAP8[($nextSymbol_1 << 4) + $13 + 1 | 0] = 2;
            HEAP16[(($nextSymbol_1 << 4) + 2 >> 1) + $13$s1] = 2;
            var $111$s1 = (($nextSymbol_1 << 4) + $13 + 4 | 0) >> 1;
            HEAP16[$111$s1] = 0;
            HEAP16[$111$s1 + 1] = 0;
            HEAP16[$111$s1 + 2] = 0;
            HEAP16[$111$s1 + 3] = 0;
            HEAP16[$111$s1 + 4] = 0;
            HEAP16[$111$s1 + 5] = 0;
            HEAP16[$93 >> 1] = ($101 - $node_0 | 0) >>> 4 & 65535;
            var $under_1 = $92;
            var $count_0 = 0;
            var $nextSymbol_2 = $nextSymbol_1 + 1 | 0;
            var $symbol_0 = $101;
            break;
          } else if (label == 80) {
            label = 0;
            var $113 = $node_0 + 1 | 0;
            var $115 = HEAP8[$113] & 255;
            var $116 = $node_0 + 2 | 0;
            var $117 = HEAP16[$116 >> 1];
            HEAP16[$116 >> 1] = $117 + 2 & 65535;
            HEAP8[$113] = HEAP8[$113] + 2 & 255;
            var $under_1 = ($under_0_ph & 65535) - $115 + ($117 & 65535) & 65535;
            var $count_0 = $115;
            var $nextSymbol_2 = $nextSymbol_1;
            var $symbol_0 = $node_0;
            break;
          }
        }
      } while (0);
      var $symbol_0;
      var $nextSymbol_2;
      var $count_0;
      var $under_1;
      HEAP16[$parent_0 >> 1] = ($symbol_0 - $21 | 0) >>> 4 & 65535;
      var $131 = $symbol_0 + 14 | 0;
      var $132$s1 = (($_pn << 4) + $13 + 12 | 0) >> 1;
      var $133 = HEAP16[$132$s1];
      var $134 = ($count_0 | 0) != 0;
      L96 : do {
        if ($134) {
          var $137 = Math.floor(($encodeRange_1 >>> 0) / (($133 & 65535) >>> 0));
          var $_2 = $_15;
          var $encodeLow_2 = ((HEAP16[(($_pn << 4) + 10 >> 1) + $13$s1] & 65535) + ($under_1 & 65535)) * $137 + $encodeLow_1 | 0;
          var $encodeRange_2 = $137 * $count_0 | 0;
          while (1) {
            var $encodeRange_2;
            var $encodeLow_2;
            var $_2;
            if (($encodeLow_2 + $encodeRange_2 ^ $encodeLow_2) >>> 0 > 16777215) {
              if ($encodeRange_2 >>> 0 > 65535) {
                var $_5 = $_2;
                var $encodeLow_5 = $encodeLow_2;
                var $encodeRange_7 = $encodeRange_2;
                break L96;
              }
              var $encodeRange_3 = -$encodeLow_2 & 65535;
            } else {
              var $encodeRange_3 = $encodeRange_2;
            }
            var $encodeRange_3;
            if ($_2 >>> 0 >= $1 >>> 0) {
              var $_0 = 0;
              label = 136;
              break L70;
            }
            HEAP8[$_2] = $encodeLow_2 >>> 24 & 255;
            var $_2 = $_2 + 1 | 0;
            var $encodeLow_2 = $encodeLow_2 << 8;
            var $encodeRange_2 = $encodeRange_3 << 8;
          }
        } else {
          var $164$s1 = (($_pn << 4) + $13 + 10 | 0) >> 1;
          var $165 = HEAP16[$164$s1];
          var $or_cond11 = $165 << 16 >> 16 != 0 & ($165 & 65535) < ($133 & 65535);
          L106 : do {
            if ($or_cond11) {
              var $_3 = $_15;
              var $encodeLow_3 = $encodeLow_1;
              var $encodeRange_4 = Math.floor(($encodeRange_1 >>> 0) / (($133 & 65535) >>> 0)) * ($165 & 65535) | 0;
              while (1) {
                var $encodeRange_4;
                var $encodeLow_3;
                var $_3;
                if (($encodeLow_3 + $encodeRange_4 ^ $encodeLow_3) >>> 0 > 16777215) {
                  if ($encodeRange_4 >>> 0 > 65535) {
                    var $_4 = $_3;
                    var $encodeLow_4 = $encodeLow_3;
                    var $encodeRange_6 = $encodeRange_4;
                    break L106;
                  }
                  var $encodeRange_5 = -$encodeLow_3 & 65535;
                } else {
                  var $encodeRange_5 = $encodeRange_4;
                }
                var $encodeRange_5;
                if ($_3 >>> 0 >= $1 >>> 0) {
                  var $_0 = 0;
                  label = 137;
                  break L70;
                }
                HEAP8[$_3] = $encodeLow_3 >>> 24 & 255;
                var $_3 = $_3 + 1 | 0;
                var $encodeLow_3 = $encodeLow_3 << 8;
                var $encodeRange_4 = $encodeRange_5 << 8;
              }
            } else {
              var $_4 = $_15;
              var $encodeLow_4 = $encodeLow_1;
              var $encodeRange_6 = $encodeRange_1;
            }
          } while (0);
          var $encodeRange_6;
          var $encodeLow_4;
          var $_4;
          HEAP16[$164$s1] = HEAP16[$164$s1] + 5 & 65535;
          HEAP16[$132$s1] = HEAP16[$132$s1] + 5 & 65535;
          var $_5 = $_4;
          var $encodeLow_5 = $encodeLow_4;
          var $encodeRange_7 = $encodeRange_6;
        }
      } while (0);
      var $encodeRange_7;
      var $encodeLow_5;
      var $_5;
      var $195 = HEAP16[$132$s1] + 2 & 65535;
      HEAP16[$132$s1] = $195;
      if ($count_0 >>> 0 > 251 | ($195 & 65535) > 65280) {
        var $199 = HEAP16[$41$s1];
        if ($199 << 16 >> 16 == 0) {
          var $206 = 0;
        } else {
          var $206 = _enet_symbol_rescale((($199 & 65535) + $_pn << 4) + $13 | 0);
        }
        var $206;
        HEAP16[$132$s1] = $206;
        var $207 = ($_pn << 4) + $13 + 10 | 0;
        var $208 = HEAP16[$207 >> 1];
        var $210 = $208 - (($208 & 65535) >>> 1) & 65535;
        HEAP16[$207 >> 1] = $210;
        HEAP16[$132$s1] = $210 + HEAP16[$132$s1] & 65535;
      }
      if ($134) {
        var $_7 = $_5;
        var $encodeLow_7 = $encodeLow_5;
        var $encodeRange_10 = $encodeRange_7;
        var $nextSymbol_4 = $nextSymbol_2;
        break;
      }
      var $_15 = $_5;
      var $parent_0 = $131;
      var $encodeLow_1 = $encodeLow_5;
      var $encodeRange_1 = $encodeRange_7;
      var $nextSymbol_1 = $nextSymbol_2;
      var $_pn_in_in = ($_pn << 4) + $13 + 14 | 0;
    }
    do {
      if (label == 102) {
        label = 0;
        var $217 = $37 & 255;
        var $218 = HEAP16[$16$s1];
        do {
          if ($218 << 16 >> 16 == 0) {
            var $222 = ($nextSymbol_1 << 4) + $13 | 0;
            HEAP8[$222 | 0] = $37;
            HEAP8[($nextSymbol_1 << 4) + $13 + 1 | 0] = 3;
            HEAP16[(($nextSymbol_1 << 4) + 2 >> 1) + $13$s1] = 3;
            var $231$s1 = (($nextSymbol_1 << 4) + $13 + 4 | 0) >> 1;
            HEAP16[$231$s1] = 0;
            HEAP16[$231$s1 + 1] = 0;
            HEAP16[$231$s1 + 2] = 0;
            HEAP16[$231$s1 + 3] = 0;
            HEAP16[$231$s1 + 4] = 0;
            HEAP16[$231$s1 + 5] = 0;
            HEAP16[$16$s1] = ($222 - $22 | 0) >>> 4 & 65535;
            var $under_3 = $217;
            var $count_1 = 1;
            var $nextSymbol_3 = $nextSymbol_1 + 1 | 0;
            var $symbol_1 = $222;
          } else {
            var $node1_0_ph = (($218 & 65535) << 4) + $14 | 0;
            var $under_2_ph = $217;
            L129 : while (1) {
              var $under_2_ph;
              var $node1_0_ph;
              var $node1_0 = $node1_0_ph;
              while (1) {
                var $node1_0;
                var $237 = HEAP8[$node1_0 | 0];
                if (($37 & 255) >= ($237 & 255)) {
                  break;
                }
                var $240 = $node1_0 + 2 | 0;
                HEAP16[$240 >> 1] = HEAP16[$240 >> 1] + 3 & 65535;
                var $243 = $node1_0 + 4 | 0;
                var $244 = HEAP16[$243 >> 1];
                if ($244 << 16 >> 16 == 0) {
                  label = 109;
                  break L129;
                }
                var $node1_0 = (($244 & 65535) << 4) + $node1_0 | 0;
              }
              if (($37 & 255) <= ($237 & 255)) {
                label = 114;
                break;
              }
              var $267 = HEAP16[$node1_0 + 2 >> 1] + $under_2_ph & 65535;
              var $268 = $node1_0 + 6 | 0;
              var $269 = HEAP16[$268 >> 1];
              if ($269 << 16 >> 16 == 0) {
                label = 113;
                break;
              }
              var $node1_0_ph = (($269 & 65535) << 4) + $node1_0 | 0;
              var $under_2_ph = $267;
            }
            if (label == 109) {
              label = 0;
              var $251 = ($nextSymbol_1 << 4) + $13 | 0;
              HEAP8[$251 | 0] = $37;
              HEAP8[($nextSymbol_1 << 4) + $13 + 1 | 0] = 3;
              HEAP16[(($nextSymbol_1 << 4) + 2 >> 1) + $13$s1] = 3;
              var $261$s1 = (($nextSymbol_1 << 4) + $13 + 4 | 0) >> 1;
              HEAP16[$261$s1] = 0;
              HEAP16[$261$s1 + 1] = 0;
              HEAP16[$261$s1 + 2] = 0;
              HEAP16[$261$s1 + 3] = 0;
              HEAP16[$261$s1 + 4] = 0;
              HEAP16[$261$s1 + 5] = 0;
              HEAP16[$243 >> 1] = ($251 - $node1_0 | 0) >>> 4 & 65535;
              var $under_3 = $under_2_ph;
              var $count_1 = 1;
              var $nextSymbol_3 = $nextSymbol_1 + 1 | 0;
              var $symbol_1 = $251;
              break;
            } else if (label == 113) {
              label = 0;
              var $276 = ($nextSymbol_1 << 4) + $13 | 0;
              HEAP8[$276 | 0] = $37;
              HEAP8[($nextSymbol_1 << 4) + $13 + 1 | 0] = 3;
              HEAP16[(($nextSymbol_1 << 4) + 2 >> 1) + $13$s1] = 3;
              var $286$s1 = (($nextSymbol_1 << 4) + $13 + 4 | 0) >> 1;
              HEAP16[$286$s1] = 0;
              HEAP16[$286$s1 + 1] = 0;
              HEAP16[$286$s1 + 2] = 0;
              HEAP16[$286$s1 + 3] = 0;
              HEAP16[$286$s1 + 4] = 0;
              HEAP16[$286$s1 + 5] = 0;
              HEAP16[$268 >> 1] = ($276 - $node1_0 | 0) >>> 4 & 65535;
              var $under_3 = $267;
              var $count_1 = 1;
              var $nextSymbol_3 = $nextSymbol_1 + 1 | 0;
              var $symbol_1 = $276;
              break;
            } else if (label == 114) {
              label = 0;
              var $288 = $node1_0 + 1 | 0;
              var $290 = HEAP8[$288] & 255;
              var $292 = $node1_0 + 2 | 0;
              var $293 = HEAP16[$292 >> 1];
              HEAP16[$292 >> 1] = $293 + 3 & 65535;
              HEAP8[$288] = HEAP8[$288] + 3 & 255;
              var $under_3 = ($under_2_ph & 65535) - $290 + ($293 & 65535) & 65535;
              var $count_1 = $290 + 1 | 0;
              var $nextSymbol_3 = $nextSymbol_1;
              var $symbol_1 = $node1_0;
              break;
            }
          }
        } while (0);
        var $symbol_1;
        var $nextSymbol_3;
        var $count_1;
        var $under_3;
        HEAP16[$parent_0 >> 1] = ($symbol_1 - $23 | 0) >>> 4 & 65535;
        var $309 = Math.floor(($encodeRange_1 >>> 0) / ((HEAP16[$20$s1] & 65535) >>> 0));
        var $_6 = $_15;
        var $encodeLow_6 = ((HEAP16[$18$s1] & 65535) + ($under_3 & 65535)) * $309 + $encodeLow_1 | 0;
        var $encodeRange_8 = $309 * $count_1 | 0;
        while (1) {
          var $encodeRange_8;
          var $encodeLow_6;
          var $_6;
          if (($encodeLow_6 + $encodeRange_8 ^ $encodeLow_6) >>> 0 > 16777215) {
            if ($encodeRange_8 >>> 0 > 65535) {
              break;
            }
            var $encodeRange_9 = -$encodeLow_6 & 65535;
          } else {
            var $encodeRange_9 = $encodeRange_8;
          }
          var $encodeRange_9;
          if ($_6 >>> 0 >= $1 >>> 0) {
            var $_0 = 0;
            label = 138;
            break L70;
          }
          HEAP8[$_6] = $encodeLow_6 >>> 24 & 255;
          var $_6 = $_6 + 1 | 0;
          var $encodeLow_6 = $encodeLow_6 << 8;
          var $encodeRange_8 = $encodeRange_9 << 8;
        }
        var $336 = HEAP16[$20$s1] + 3 & 65535;
        HEAP16[$20$s1] = $336;
        if (!($count_1 >>> 0 > 250 | ($336 & 65535) > 65280)) {
          var $_7 = $_6;
          var $encodeLow_7 = $encodeLow_6;
          var $encodeRange_10 = $encodeRange_8;
          var $nextSymbol_4 = $nextSymbol_3;
          break;
        }
        var $340 = HEAP16[$16$s1];
        if ($340 << 16 >> 16 == 0) {
          var $347 = 0;
        } else {
          var $347 = _enet_symbol_rescale((($340 & 65535) << 4) + $14 | 0);
        }
        var $347;
        HEAP16[$20$s1] = $347;
        var $348 = HEAP16[$18$s1];
        var $350 = $348 - (($348 & 65535) >>> 1) & 65535;
        HEAP16[$18$s1] = $350;
        HEAP16[$20$s1] = (HEAP16[$20$s1] + 256 & 65535) + $350 & 65535;
        var $_7 = $_6;
        var $encodeLow_7 = $encodeLow_6;
        var $encodeRange_10 = $encodeRange_8;
        var $nextSymbol_4 = $nextSymbol_3;
      }
    } while (0);
    var $nextSymbol_4;
    var $encodeRange_10;
    var $encodeLow_7;
    var $_7;
    if ($order_0 >>> 0 > 1) {
      HEAP16[$predicted$s1] = HEAP16[(((HEAP16[$predicted$s1] & 65535) << 4) + 14 >> 1) + $13$s1];
      var $order_1 = $order_0;
    } else {
      var $order_1 = $order_0 + 1 | 0;
    }
    var $order_1;
    if ($nextSymbol_4 >>> 0 <= 4093) {
      var $_01 = $_1;
      var $_02 = $_13;
      var $_04 = $_7;
      var $inData_0 = $36;
      var $inEnd_0 = $inEnd_1;
      var $encodeLow_0 = $encodeLow_7;
      var $encodeRange_0 = $encodeRange_10;
      var $order_0 = $order_1;
      var $nextSymbol_0 = $nextSymbol_4;
      continue;
    }
    for (var $$dest = $context, $$stop = $$dest + 16; $$dest < $$stop; $$dest++) {
      HEAP8[$$dest] = 0;
    }
    HEAP16[$18$s1] = 1;
    HEAP16[$20$s1] = 257;
    HEAP16[$16$s1] = 0;
    HEAP16[$predicted$s1] = 0;
    var $_01 = $_1;
    var $_02 = $_13;
    var $_04 = $_7;
    var $inData_0 = $36;
    var $inEnd_0 = $inEnd_1;
    var $encodeLow_0 = $encodeLow_7;
    var $encodeRange_0 = $encodeRange_10;
    var $order_0 = 0;
    var $nextSymbol_0 = 1;
  }
  if (label == 130) {
    while (1) {
      label = 0;
      var $encodeLow_8;
      var $_8;
      if (($encodeLow_8 | 0) == 0) {
        break;
      }
      if ($_8 >>> 0 >= $1 >>> 0) {
        var $_0 = 0;
        label = 139;
        break;
      }
      HEAP8[$_8] = $encodeLow_8 >>> 24 & 255;
      var $_8 = $_8 + 1 | 0;
      var $encodeLow_8 = $encodeLow_8 << 8;
    }
    if (label == 139) {
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    }
    var $_0 = $_8 - $outData | 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 136) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 137) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 138) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
}
_enet_range_coder_compress["X"] = 1;
function _enet_symbol_rescale($symbol) {
  var $7$s1;
  var $_0 = $symbol;
  var $total_0 = 0;
  while (1) {
    var $total_0;
    var $_0;
    var $2 = $_0 + 1 | 0;
    var $3 = HEAP8[$2];
    var $5 = $3 - (($3 & 255) >>> 1) & 255;
    HEAP8[$2] = $5;
    var $7$s1 = ($_0 + 2 | 0) >> 1;
    HEAP16[$7$s1] = $5 & 255;
    var $9 = HEAP16[$_0 + 4 >> 1];
    if ($9 << 16 >> 16 != 0) {
      HEAP16[$7$s1] = _enet_symbol_rescale((($9 & 65535) << 4) + $_0 | 0) + HEAP16[$7$s1] & 65535;
    }
    var $20 = (HEAP16[$7$s1] & 65535) + $total_0 | 0;
    var $22 = HEAP16[$_0 + 6 >> 1];
    if ($22 << 16 >> 16 == 0) {
      break;
    }
    var $_0 = (($22 & 65535) << 4) + $_0 | 0;
    var $total_0 = $20 & 65535;
  }
  return $20 & 65535;
}
function _enet_range_coder_decompress($context, $inData, $inLimit, $outData, $outLimit) {
  var $441$s1;
  var $416$s1;
  var $394$s1;
  var $365$s1;
  var $350$s1;
  var $292$s1;
  var $261$s1;
  var $221$s1;
  var $55$s1;
  var $50$s1;
  var $13$s1;
  var $11$s1;
  var $9$s1;
  var $6$s1;
  var $predicted$s1;
  var __stackBase__ = STACKTOP;
  STACKTOP += 4;
  var label;
  var $predicted = __stackBase__, $predicted$s1 = $predicted >> 1;
  var $1 = $outData + $outLimit | 0;
  var $2 = $inData + $inLimit | 0;
  HEAP16[$predicted$s1] = 0;
  if (($context | 0) == 0 | ($inLimit | 0) == 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $6 = $context, $6$s1 = $6 >> 1;
  var $7 = $context;
  var $9$s1 = ($context + 8 | 0) >> 1;
  var $11$s1 = ($context + 10 | 0) >> 1;
  var $13$s1 = ($context + 12 | 0) >> 1;
  for (var $$dest = $context, $$stop = $$dest + 16; $$dest < $$stop; $$dest++) {
    HEAP8[$$dest] = 0;
  }
  HEAP16[$11$s1] = 1;
  HEAP16[$13$s1] = 257;
  HEAP16[$9$s1] = 0;
  if (($inLimit | 0) > 0) {
    var $_01 = $inData + 1 | 0;
    var $decodeCode_0 = (HEAP8[$inData] & 255) << 24;
  } else {
    var $_01 = $inData;
    var $decodeCode_0 = 0;
  }
  var $decodeCode_0;
  var $_01;
  if ($_01 >>> 0 < $2 >>> 0) {
    var $_1 = $_01 + 1 | 0;
    var $decodeCode_1 = (HEAP8[$_01] & 255) << 16 | $decodeCode_0;
  } else {
    var $_1 = $_01;
    var $decodeCode_1 = $decodeCode_0;
  }
  var $decodeCode_1;
  var $_1;
  if ($_1 >>> 0 < $2 >>> 0) {
    var $_2 = $_1 + 1 | 0;
    var $decodeCode_2 = (HEAP8[$_1] & 255) << 8 | $decodeCode_1;
  } else {
    var $_2 = $_1;
    var $decodeCode_2 = $decodeCode_1;
  }
  var $decodeCode_2;
  var $_2;
  if ($_2 >>> 0 < $2 >>> 0) {
    var $_3_ph = $_2 + 1 | 0;
    var $decodeCode_3_ph = HEAP8[$_2] & 255 | $decodeCode_2;
  } else {
    var $_3_ph = $_2;
    var $decodeCode_3_ph = $decodeCode_2;
  }
  var $decodeCode_3_ph;
  var $_3_ph;
  var $43 = $context;
  var $44 = $context;
  var $45 = $context;
  var $46 = $context;
  var $_3 = $_3_ph;
  var $_02 = $outData;
  var $decodeLow_0 = 0;
  var $decodeCode_3 = $decodeCode_3_ph;
  var $decodeRange_0 = -1;
  var $order_0 = 0;
  var $nextSymbol_0 = 1;
  L197 : while (1) {
    var $nextSymbol_0;
    var $order_0;
    var $decodeRange_0;
    var $decodeCode_3;
    var $decodeLow_0;
    var $_02;
    var $_3;
    var $_4 = $_3;
    var $decodeLow_1 = $decodeLow_0;
    var $decodeCode_4 = $decodeCode_3;
    var $decodeRange_1 = $decodeRange_0;
    var $_pn_in_in = $predicted;
    L199 : while (1) {
      var $_pn_in_in;
      var $decodeRange_1;
      var $decodeCode_4;
      var $decodeLow_1;
      var $_4;
      var $_pn_in = HEAP16[$_pn_in_in >> 1];
      var $_pn = $_pn_in & 65535;
      if ((($_pn << 4) + $6 | 0) == ($7 | 0)) {
        label = 190;
        break;
      }
      var $50$s1 = (($_pn << 4) + $6 + 10 | 0) >> 1;
      var $51 = HEAP16[$50$s1];
      var $52 = $51 & 65535;
      var $53 = $51 << 16 >> 16 == 0;
      L202 : do {
        if ($53) {
          var $_9 = $_4;
          var $decodeLow_4 = $decodeLow_1;
          var $decodeCode_9 = $decodeCode_4;
          var $decodeRange_6 = $decodeRange_1;
        } else {
          var $55$s1 = (($_pn << 4) + $6 + 12 | 0) >> 1;
          var $56 = HEAP16[$55$s1];
          if (($51 & 65535) >= ($56 & 65535)) {
            var $_9 = $_4;
            var $decodeLow_4 = $decodeLow_1;
            var $decodeCode_9 = $decodeCode_4;
            var $decodeRange_6 = $decodeRange_1;
            break;
          }
          var $61 = Math.floor(($decodeRange_1 >>> 0) / (($56 & 65535) >>> 0));
          var $62 = Math.floor((($decodeCode_4 - $decodeLow_1 | 0) >>> 0) / ($61 >>> 0));
          if (($62 & 65535) >>> 0 >= $52 >>> 0) {
            label = 169;
            break L199;
          }
          var $_5 = $_4;
          var $decodeLow_2 = $decodeLow_1;
          var $decodeCode_5 = $decodeCode_4;
          var $decodeRange_2 = $61 * $52 | 0;
          while (1) {
            var $decodeRange_2;
            var $decodeCode_5;
            var $decodeLow_2;
            var $_5;
            if (($decodeLow_2 + $decodeRange_2 ^ $decodeLow_2) >>> 0 > 16777215) {
              if ($decodeRange_2 >>> 0 > 65535) {
                var $_9 = $_5;
                var $decodeLow_4 = $decodeLow_2;
                var $decodeCode_9 = $decodeCode_5;
                var $decodeRange_6 = $decodeRange_2;
                break L202;
              }
              var $decodeRange_3 = -$decodeLow_2 & 65535;
            } else {
              var $decodeRange_3 = $decodeRange_2;
            }
            var $decodeRange_3;
            var $77 = $decodeCode_5 << 8;
            if ($_5 >>> 0 < $2 >>> 0) {
              var $_6 = $_5 + 1 | 0;
              var $decodeCode_6 = HEAP8[$_5] & 255 | $77;
            } else {
              var $_6 = $_5;
              var $decodeCode_6 = $77;
            }
            var $decodeCode_6;
            var $_6;
            var $_5 = $_6;
            var $decodeLow_2 = $decodeLow_2 << 8;
            var $decodeCode_5 = $decodeCode_6;
            var $decodeRange_2 = $decodeRange_3 << 8;
          }
        }
      } while (0);
      var $decodeRange_6;
      var $decodeCode_9;
      var $decodeLow_4;
      var $_9;
      var $_4 = $_9;
      var $decodeLow_1 = $decodeLow_4;
      var $decodeCode_4 = $decodeCode_9;
      var $decodeRange_1 = $decodeRange_6;
      var $_pn_in_in = ($_pn << 4) + $6 + 14 | 0;
    }
    do {
      if (label == 190) {
        label = 0;
        var $183 = Math.floor(($decodeRange_1 >>> 0) / ((HEAP16[$13$s1] & 65535) >>> 0));
        var $184 = Math.floor((($decodeCode_4 - $decodeLow_1 | 0) >>> 0) / ($183 >>> 0));
        var $187 = HEAP16[$11$s1] & 65535;
        if (($184 & 65535) >>> 0 < $187 >>> 0) {
          label = 191;
          break L197;
        }
        var $206 = $184 - $187 | 0;
        var $207 = HEAP16[$9$s1];
        do {
          if ($207 << 16 >> 16 == 0) {
            var $210 = $206 & 255;
            var $212 = ($nextSymbol_0 << 4) + $6 | 0;
            HEAP8[$212 | 0] = $210;
            HEAP8[($nextSymbol_0 << 4) + $6 + 1 | 0] = 3;
            HEAP16[(($nextSymbol_0 << 4) + 2 >> 1) + $6$s1] = 3;
            var $221$s1 = (($nextSymbol_0 << 4) + $6 + 4 | 0) >> 1;
            HEAP16[$221$s1] = 0;
            HEAP16[$221$s1 + 1] = 0;
            HEAP16[$221$s1 + 2] = 0;
            HEAP16[$221$s1 + 3] = 0;
            HEAP16[$221$s1 + 4] = 0;
            HEAP16[$221$s1 + 5] = 0;
            HEAP16[$9$s1] = ($212 - $43 | 0) >>> 4 & 65535;
            var $count_0 = 1;
            var $nextSymbol_1 = $nextSymbol_0 + 1 | 0;
            var $symbol_0 = $212;
            var $value_0 = $210;
            var $under_2_in = $206;
          } else {
            var $225 = $206 & 65535;
            var $node1_0_ph = (($207 & 65535) << 4) + $7 | 0;
            var $under_1_ph = 0;
            L222 : while (1) {
              var $under_1_ph;
              var $node1_0_ph;
              var $node1_0 = $node1_0_ph;
              while (1) {
                var $node1_0;
                var $227 = $node1_0 + 2 | 0;
                var $228 = HEAP16[$227 >> 1];
                var $230 = ($228 & 65535) + $under_1_ph | 0;
                var $231 = $node1_0 | 0;
                var $232 = HEAP8[$231];
                var $234 = ($232 & 255) + 1 | 0;
                var $235 = $234 + $230 | 0;
                var $236 = $node1_0 + 1 | 0;
                var $237 = $235 & 65535;
                if ($225 >>> 0 >= $237 >>> 0) {
                  break;
                }
                var $265 = (HEAP8[$236] & 255) + 1 | 0;
                var $266 = $237 - $265 | 0;
                HEAP16[$227 >> 1] = $228 + 3 & 65535;
                if (($225 | 0) >= ($266 | 0)) {
                  label = 208;
                  break L222;
                }
                var $270 = $node1_0 + 4 | 0;
                var $271 = HEAP16[$270 >> 1];
                if ($271 << 16 >> 16 == 0) {
                  label = 207;
                  break L222;
                }
                var $node1_0 = (($271 & 65535) << 4) + $node1_0 | 0;
              }
              var $240 = $node1_0 + 6 | 0;
              var $241 = HEAP16[$240 >> 1];
              if ($241 << 16 >> 16 == 0) {
                label = 203;
                break;
              }
              var $node1_0_ph = (($241 & 65535) << 4) + $node1_0 | 0;
              var $under_1_ph = $230 & 65535;
            }
            if (label == 203) {
              label = 0;
              var $249 = $234 + $206 - $235 & 255;
              var $251 = ($nextSymbol_0 << 4) + $6 | 0;
              HEAP8[$251 | 0] = $249;
              HEAP8[($nextSymbol_0 << 4) + $6 + 1 | 0] = 3;
              HEAP16[(($nextSymbol_0 << 4) + 2 >> 1) + $6$s1] = 3;
              var $261$s1 = (($nextSymbol_0 << 4) + $6 + 4 | 0) >> 1;
              HEAP16[$261$s1] = 0;
              HEAP16[$261$s1 + 1] = 0;
              HEAP16[$261$s1 + 2] = 0;
              HEAP16[$261$s1 + 3] = 0;
              HEAP16[$261$s1 + 4] = 0;
              HEAP16[$261$s1 + 5] = 0;
              HEAP16[$240 >> 1] = ($251 - $node1_0 | 0) >>> 4 & 65535;
              var $count_0 = 1;
              var $nextSymbol_1 = $nextSymbol_0 + 1 | 0;
              var $symbol_0 = $251;
              var $value_0 = $249;
              var $under_2_in = $225;
              break;
            } else if (label == 207) {
              label = 0;
              var $280 = $206 - $266 + (HEAP8[$231] & 255) & 255;
              var $282 = ($nextSymbol_0 << 4) + $6 | 0;
              HEAP8[$282 | 0] = $280;
              HEAP8[($nextSymbol_0 << 4) + $6 + 1 | 0] = 3;
              HEAP16[(($nextSymbol_0 << 4) + 2 >> 1) + $6$s1] = 3;
              var $292$s1 = (($nextSymbol_0 << 4) + $6 + 4 | 0) >> 1;
              HEAP16[$292$s1] = 0;
              HEAP16[$292$s1 + 1] = 0;
              HEAP16[$292$s1 + 2] = 0;
              HEAP16[$292$s1 + 3] = 0;
              HEAP16[$292$s1 + 4] = 0;
              HEAP16[$292$s1 + 5] = 0;
              HEAP16[$270 >> 1] = ($282 - $node1_0 | 0) >>> 4 & 65535;
              var $count_0 = 1;
              var $nextSymbol_1 = $nextSymbol_0 + 1 | 0;
              var $symbol_0 = $282;
              var $value_0 = $280;
              var $under_2_in = $225;
              break;
            } else if (label == 208) {
              label = 0;
              HEAP8[$236] = HEAP8[$236] + 3 & 255;
              var $count_0 = $265;
              var $nextSymbol_1 = $nextSymbol_0;
              var $symbol_0 = $node1_0;
              var $value_0 = $232;
              var $under_2_in = $266;
              break;
            }
          }
        } while (0);
        var $under_2_in;
        var $value_0;
        var $symbol_0;
        var $nextSymbol_1;
        var $count_0;
        var $299 = ($symbol_0 - $44 | 0) >>> 4;
        var $_12 = $_4;
        var $decodeLow_6 = ((HEAP16[$11$s1] & 65535) + ($under_2_in & 65535)) * $183 + $decodeLow_1 | 0;
        var $decodeCode_12 = $decodeCode_4;
        var $decodeRange_9 = $count_0 * $183 | 0;
        while (1) {
          var $decodeRange_9;
          var $decodeCode_12;
          var $decodeLow_6;
          var $_12;
          if (($decodeLow_6 + $decodeRange_9 ^ $decodeLow_6) >>> 0 > 16777215) {
            if ($decodeRange_9 >>> 0 > 65535) {
              break;
            }
            var $decodeRange_10 = -$decodeLow_6 & 65535;
          } else {
            var $decodeRange_10 = $decodeRange_9;
          }
          var $decodeRange_10;
          var $317 = $decodeCode_12 << 8;
          if ($_12 >>> 0 < $2 >>> 0) {
            var $_13 = $_12 + 1 | 0;
            var $decodeCode_13 = HEAP8[$_12] & 255 | $317;
          } else {
            var $_13 = $_12;
            var $decodeCode_13 = $317;
          }
          var $decodeCode_13;
          var $_13;
          var $_12 = $_13;
          var $decodeLow_6 = $decodeLow_6 << 8;
          var $decodeCode_12 = $decodeCode_13;
          var $decodeRange_9 = $decodeRange_10 << 8;
        }
        var $328 = $299 & 65535;
        var $330 = HEAP16[$13$s1] + 3 & 65535;
        HEAP16[$13$s1] = $330;
        if (!($count_0 >>> 0 > 250 | ($330 & 65535) > 65280)) {
          var $_14 = $_12;
          var $bottom_0 = $328;
          var $decodeLow_7 = $decodeLow_6;
          var $decodeCode_14 = $decodeCode_12;
          var $decodeRange_11 = $decodeRange_9;
          var $nextSymbol_2 = $nextSymbol_1;
          var $value_1 = $value_0;
          break;
        }
        var $334 = HEAP16[$9$s1];
        if ($334 << 16 >> 16 == 0) {
          var $341 = 0;
        } else {
          var $341 = _enet_symbol_rescale((($334 & 65535) << 4) + $7 | 0);
        }
        var $341;
        HEAP16[$13$s1] = $341;
        var $342 = HEAP16[$11$s1];
        var $344 = $342 - (($342 & 65535) >>> 1) & 65535;
        HEAP16[$11$s1] = $344;
        HEAP16[$13$s1] = (HEAP16[$13$s1] + 256 & 65535) + $344 & 65535;
        var $_14 = $_12;
        var $bottom_0 = $328;
        var $decodeLow_7 = $decodeLow_6;
        var $decodeCode_14 = $decodeCode_12;
        var $decodeRange_11 = $decodeRange_9;
        var $nextSymbol_2 = $nextSymbol_1;
        var $value_1 = $value_0;
      } else if (label == 169) {
        label = 0;
        var $88 = ($_pn << 4) + $6 + 8 | 0;
        var $89 = HEAP16[$88 >> 1];
        if ($89 << 16 >> 16 == 0) {
          var $_0 = 0;
          label = 253;
          break L197;
        }
        var $95 = $62 - $52 & 65535;
        var $node_0_ph = (($89 & 65535) + $_pn << 4) + $6 | 0;
        var $under_0_ph = 0;
        L252 : while (1) {
          var $under_0_ph;
          var $node_0_ph;
          var $node_0 = $node_0_ph;
          while (1) {
            var $node_0;
            var $97 = $node_0 + 2 | 0;
            var $98 = HEAP16[$97 >> 1];
            var $99 = $98 + $under_0_ph & 65535;
            var $100 = $node_0 + 1 | 0;
            var $101 = $99 & 65535;
            if ($95 >>> 0 >= $101 >>> 0) {
              break;
            }
            var $112 = HEAP8[$node_0 | 0];
            var $113 = HEAP8[$100];
            var $114 = $113 & 255;
            var $115 = $101 - $114 | 0;
            HEAP16[$97 >> 1] = $98 + 2 & 65535;
            if (($95 | 0) >= ($115 | 0)) {
              break L252;
            }
            var $120 = HEAP16[$node_0 + 4 >> 1];
            if ($120 << 16 >> 16 == 0) {
              var $_0 = 0;
              label = 252;
              break L197;
            }
            var $node_0 = (($120 & 65535) << 4) + $node_0 | 0;
          }
          var $105 = HEAP16[$node_0 + 6 >> 1];
          if ($105 << 16 >> 16 == 0) {
            var $_0 = 0;
            label = 251;
            break L197;
          }
          var $node_0_ph = (($105 & 65535) << 4) + $node_0 | 0;
          var $under_0_ph = $99;
        }
        HEAP8[$100] = HEAP8[$100] + 2 & 255;
        var $130 = ($node_0 - $46 | 0) >>> 4;
        var $_7 = $_4;
        var $decodeLow_3 = ((HEAP16[$50$s1] & 65535) + ($115 & 65535)) * $61 + $decodeLow_1 | 0;
        var $decodeCode_7 = $decodeCode_4;
        var $decodeRange_4 = $114 * $61 | 0;
        while (1) {
          var $decodeRange_4;
          var $decodeCode_7;
          var $decodeLow_3;
          var $_7;
          if (($decodeLow_3 + $decodeRange_4 ^ $decodeLow_3) >>> 0 > 16777215) {
            if ($decodeRange_4 >>> 0 > 65535) {
              break;
            }
            var $decodeRange_5 = -$decodeLow_3 & 65535;
          } else {
            var $decodeRange_5 = $decodeRange_4;
          }
          var $decodeRange_5;
          var $148 = $decodeCode_7 << 8;
          if ($_7 >>> 0 < $2 >>> 0) {
            var $_8 = $_7 + 1 | 0;
            var $decodeCode_8 = HEAP8[$_7] & 255 | $148;
          } else {
            var $_8 = $_7;
            var $decodeCode_8 = $148;
          }
          var $decodeCode_8;
          var $_8;
          var $_7 = $_8;
          var $decodeLow_3 = $decodeLow_3 << 8;
          var $decodeCode_7 = $decodeCode_8;
          var $decodeRange_4 = $decodeRange_5 << 8;
        }
        var $159 = $130 & 65535;
        var $161 = HEAP16[$55$s1] + 2 & 65535;
        HEAP16[$55$s1] = $161;
        if (!(($113 & 255) > 251 | ($161 & 65535) > 65280)) {
          var $_14 = $_7;
          var $bottom_0 = $159;
          var $decodeLow_7 = $decodeLow_3;
          var $decodeCode_14 = $decodeCode_7;
          var $decodeRange_11 = $decodeRange_4;
          var $nextSymbol_2 = $nextSymbol_0;
          var $value_1 = $112;
          break;
        }
        var $165 = HEAP16[$88 >> 1];
        if ($165 << 16 >> 16 == 0) {
          var $172 = 0;
        } else {
          var $172 = _enet_symbol_rescale((($165 & 65535) + $_pn << 4) + $6 | 0);
        }
        var $172;
        HEAP16[$55$s1] = $172;
        var $173 = HEAP16[$50$s1];
        var $175 = $173 - (($173 & 65535) >>> 1) & 65535;
        HEAP16[$50$s1] = $175;
        HEAP16[$55$s1] = $175 + HEAP16[$55$s1] & 65535;
        var $_14 = $_7;
        var $bottom_0 = $159;
        var $decodeLow_7 = $decodeLow_3;
        var $decodeCode_14 = $decodeCode_7;
        var $decodeRange_11 = $decodeRange_4;
        var $nextSymbol_2 = $nextSymbol_0;
        var $value_1 = $112;
      }
    } while (0);
    var $value_1;
    var $nextSymbol_2;
    var $decodeRange_11;
    var $decodeCode_14;
    var $decodeLow_7;
    var $bottom_0;
    var $_14;
    var $_pn3_in82 = HEAP16[$predicted$s1];
    var $349 = $_pn3_in82 << 16 >> 16 == $_pn_in << 16 >> 16;
    L277 : do {
      if ($349) {
        var $nextSymbol_3_lcssa = $nextSymbol_2;
        var $parent_0_lcssa = $predicted;
      } else {
        var $nextSymbol_385 = $nextSymbol_2;
        var $parent_086 = $predicted;
        var $_pn383_pn_in = $_pn3_in82;
        while (1) {
          var $_pn383_pn_in;
          var $parent_086;
          var $nextSymbol_385;
          var $_pn383_pn = $_pn383_pn_in & 65535;
          var $350$s1 = (($_pn383_pn << 4) + $6 + 8 | 0) >> 1;
          var $351 = HEAP16[$350$s1];
          do {
            if ($351 << 16 >> 16 == 0) {
              var $355 = ($nextSymbol_385 << 4) + $6 | 0;
              HEAP8[$355 | 0] = $value_1;
              HEAP8[($nextSymbol_385 << 4) + $6 + 1 | 0] = 2;
              HEAP16[(($nextSymbol_385 << 4) + 2 >> 1) + $6$s1] = 2;
              var $365$s1 = (($nextSymbol_385 << 4) + $6 + 4 | 0) >> 1;
              HEAP16[$365$s1] = 0;
              HEAP16[$365$s1 + 1] = 0;
              HEAP16[$365$s1 + 2] = 0;
              HEAP16[$365$s1 + 3] = 0;
              HEAP16[$365$s1 + 4] = 0;
              HEAP16[$365$s1 + 5] = 0;
              HEAP16[$350$s1] = ($355 - (($_pn383_pn << 4) + $6) | 0) >>> 4 & 65535;
              var $count_1 = 0;
              var $nextSymbol_4 = $nextSymbol_385 + 1 | 0;
              var $symbol_1 = $355;
            } else {
              var $node4_0 = (($351 & 65535) + $_pn383_pn << 4) + $6 | 0;
              while (1) {
                var $node4_0;
                var $370 = HEAP8[$node4_0 | 0];
                if (($value_1 & 255) < ($370 & 255)) {
                  var $373 = $node4_0 + 2 | 0;
                  HEAP16[$373 >> 1] = HEAP16[$373 >> 1] + 2 & 65535;
                  var $376 = $node4_0 + 4 | 0;
                  var $377 = HEAP16[$376 >> 1];
                  if ($377 << 16 >> 16 == 0) {
                    label = 227;
                    break;
                  }
                  var $node4_0 = (($377 & 65535) << 4) + $node4_0 | 0;
                  continue;
                }
                if (($value_1 & 255) <= ($370 & 255)) {
                  label = 232;
                  break;
                }
                var $398 = $node4_0 + 6 | 0;
                var $399 = HEAP16[$398 >> 1];
                if ($399 << 16 >> 16 == 0) {
                  label = 231;
                  break;
                }
                var $node4_0 = (($399 & 65535) << 4) + $node4_0 | 0;
              }
              if (label == 227) {
                label = 0;
                var $384 = ($nextSymbol_385 << 4) + $6 | 0;
                HEAP8[$384 | 0] = $value_1;
                HEAP8[($nextSymbol_385 << 4) + $6 + 1 | 0] = 2;
                HEAP16[(($nextSymbol_385 << 4) + 2 >> 1) + $6$s1] = 2;
                var $394$s1 = (($nextSymbol_385 << 4) + $6 + 4 | 0) >> 1;
                HEAP16[$394$s1] = 0;
                HEAP16[$394$s1 + 1] = 0;
                HEAP16[$394$s1 + 2] = 0;
                HEAP16[$394$s1 + 3] = 0;
                HEAP16[$394$s1 + 4] = 0;
                HEAP16[$394$s1 + 5] = 0;
                HEAP16[$376 >> 1] = ($384 - $node4_0 | 0) >>> 4 & 65535;
                var $count_1 = 0;
                var $nextSymbol_4 = $nextSymbol_385 + 1 | 0;
                var $symbol_1 = $384;
                break;
              } else if (label == 231) {
                label = 0;
                var $406 = ($nextSymbol_385 << 4) + $6 | 0;
                HEAP8[$406 | 0] = $value_1;
                HEAP8[($nextSymbol_385 << 4) + $6 + 1 | 0] = 2;
                HEAP16[(($nextSymbol_385 << 4) + 2 >> 1) + $6$s1] = 2;
                var $416$s1 = (($nextSymbol_385 << 4) + $6 + 4 | 0) >> 1;
                HEAP16[$416$s1] = 0;
                HEAP16[$416$s1 + 1] = 0;
                HEAP16[$416$s1 + 2] = 0;
                HEAP16[$416$s1 + 3] = 0;
                HEAP16[$416$s1 + 4] = 0;
                HEAP16[$416$s1 + 5] = 0;
                HEAP16[$398 >> 1] = ($406 - $node4_0 | 0) >>> 4 & 65535;
                var $count_1 = 0;
                var $nextSymbol_4 = $nextSymbol_385 + 1 | 0;
                var $symbol_1 = $406;
                break;
              } else if (label == 232) {
                label = 0;
                var $418 = $node4_0 + 1 | 0;
                var $420 = HEAP8[$418] & 255;
                var $421 = $node4_0 + 2 | 0;
                HEAP16[$421 >> 1] = HEAP16[$421 >> 1] + 2 & 65535;
                HEAP8[$418] = HEAP8[$418] + 2 & 255;
                var $count_1 = $420;
                var $nextSymbol_4 = $nextSymbol_385;
                var $symbol_1 = $node4_0;
                break;
              }
            }
          } while (0);
          var $symbol_1;
          var $nextSymbol_4;
          var $count_1;
          HEAP16[$parent_086 >> 1] = ($symbol_1 - $45 | 0) >>> 4 & 65535;
          var $431 = $symbol_1 + 14 | 0;
          if (($count_1 | 0) == 0) {
            var $434 = ($_pn383_pn << 4) + $6 + 10 | 0;
            HEAP16[$434 >> 1] = HEAP16[$434 >> 1] + 5 & 65535;
            var $437 = ($_pn383_pn << 4) + $6 + 12 | 0;
            HEAP16[$437 >> 1] = HEAP16[$437 >> 1] + 5 & 65535;
          }
          var $441$s1 = (($_pn383_pn << 4) + $6 + 12 | 0) >> 1;
          var $443 = HEAP16[$441$s1] + 2 & 65535;
          HEAP16[$441$s1] = $443;
          if ($count_1 >>> 0 > 251 | ($443 & 65535) > 65280) {
            var $447 = HEAP16[$350$s1];
            if ($447 << 16 >> 16 == 0) {
              var $454 = 0;
            } else {
              var $454 = _enet_symbol_rescale((($447 & 65535) + $_pn383_pn << 4) + $6 | 0);
            }
            var $454;
            HEAP16[$441$s1] = $454;
            var $455 = ($_pn383_pn << 4) + $6 + 10 | 0;
            var $456 = HEAP16[$455 >> 1];
            var $458 = $456 - (($456 & 65535) >>> 1) & 65535;
            HEAP16[$455 >> 1] = $458;
            HEAP16[$441$s1] = $458 + HEAP16[$441$s1] & 65535;
          }
          var $_pn3_in = HEAP16[(($_pn383_pn << 4) + 14 >> 1) + $6$s1];
          if ($_pn3_in << 16 >> 16 == $_pn_in << 16 >> 16) {
            var $nextSymbol_3_lcssa = $nextSymbol_4;
            var $parent_0_lcssa = $431;
            break L277;
          } else {
            var $nextSymbol_385 = $nextSymbol_4;
            var $parent_086 = $431;
            var $_pn383_pn_in = $_pn3_in;
          }
        }
      }
    } while (0);
    var $parent_0_lcssa;
    var $nextSymbol_3_lcssa;
    HEAP16[$parent_0_lcssa >> 1] = $bottom_0;
    if ($_02 >>> 0 >= $1 >>> 0) {
      var $_0 = 0;
      label = 249;
      break;
    }
    var $466 = $_02 + 1 | 0;
    HEAP8[$_02] = $value_1;
    if ($order_0 >>> 0 > 1) {
      HEAP16[$predicted$s1] = HEAP16[(((HEAP16[$predicted$s1] & 65535) << 4) + 14 >> 1) + $6$s1];
      var $order_1 = $order_0;
    } else {
      var $order_1 = $order_0 + 1 | 0;
    }
    var $order_1;
    if ($nextSymbol_3_lcssa >>> 0 <= 4093) {
      var $_3 = $_14;
      var $_02 = $466;
      var $decodeLow_0 = $decodeLow_7;
      var $decodeCode_3 = $decodeCode_14;
      var $decodeRange_0 = $decodeRange_11;
      var $order_0 = $order_1;
      var $nextSymbol_0 = $nextSymbol_3_lcssa;
      continue;
    }
    for (var $$dest = $context, $$stop = $$dest + 16; $$dest < $$stop; $$dest++) {
      HEAP8[$$dest] = 0;
    }
    HEAP16[$11$s1] = 1;
    HEAP16[$13$s1] = 257;
    HEAP16[$9$s1] = 0;
    HEAP16[$predicted$s1] = 0;
    var $_3 = $_14;
    var $_02 = $466;
    var $decodeLow_0 = $decodeLow_7;
    var $decodeCode_3 = $decodeCode_14;
    var $decodeRange_0 = $decodeRange_11;
    var $order_0 = 0;
    var $nextSymbol_0 = 1;
  }
  if (label == 191) {
    var $_10 = $_4;
    var $decodeLow_5 = $decodeLow_1;
    var $decodeRange_7 = $187 * $183 | 0;
    while (1) {
      var $decodeRange_7;
      var $decodeLow_5;
      var $_10;
      if (($decodeLow_5 + $decodeRange_7 ^ $decodeLow_5) >>> 0 > 16777215) {
        if ($decodeRange_7 >>> 0 > 65535) {
          break;
        }
        var $decodeRange_8 = -$decodeLow_5 & 65535;
      } else {
        var $decodeRange_8 = $decodeRange_7;
      }
      var $decodeRange_8;
      var $_10 = $_10 >>> 0 < $2 >>> 0 ? $_10 + 1 | 0 : $_10;
      var $decodeLow_5 = $decodeLow_5 << 8;
      var $decodeRange_7 = $decodeRange_8 << 8;
    }
    var $_0 = $_02 - $outData | 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 249) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 251) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 252) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 253) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
}
_enet_range_coder_decompress["X"] = 1;
function _enet_host_compress_with_range_coder($host) {
  var $1$s2;
  var $compressor$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 16;
  var $compressor = __stackBase__, $compressor$s2 = $compressor >> 2;
  var $1$s2 = $compressor >> 2;
  HEAP32[$1$s2] = 0;
  HEAP32[$1$s2 + 1] = 0;
  HEAP32[$1$s2 + 2] = 0;
  HEAP32[$1$s2 + 3] = 0;
  var $2 = _enet_range_coder_create();
  HEAP32[$compressor$s2] = $2;
  if (($2 | 0) == 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  HEAP32[$compressor$s2 + 1] = 10;
  HEAP32[$compressor$s2 + 2] = 4;
  HEAP32[$compressor$s2 + 3] = 28;
  _enet_host_compress($host, $compressor);
  var $_0 = 0;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
function _enet_host_channel_limit($host, $channelLimit) {
  var $1 = ($channelLimit | 0) == 0;
  if ($1 | $channelLimit >>> 0 > 255) {
    var $_0 = 255;
  } else {
    var $_0 = $1 ? 1 : $channelLimit;
  }
  var $_0;
  HEAP32[$host + 44 >> 2] = $_0;
  return;
}
function _enet_host_bandwidth_limit($host, $incomingBandwidth, $outgoingBandwidth) {
  HEAP32[$host + 12 >> 2] = $incomingBandwidth;
  HEAP32[$host + 16 >> 2] = $outgoingBandwidth;
  HEAP32[$host + 32 >> 2] = 1;
  return;
}
function _enet_list_clear($list) {
  var $1 = $list | 0;
  HEAP32[$list >> 2] = $1;
  HEAP32[$list + 4 >> 2] = $1;
  return;
}
function _enet_list_insert($position, $data) {
  var $1 = $data;
  var $2 = $position + 4 | 0;
  var $5 = $data + 4 | 0;
  HEAP32[$5 >> 2] = HEAP32[$2 >> 2];
  HEAP32[$data >> 2] = $position;
  HEAP32[HEAP32[$5 >> 2] >> 2] = $1;
  HEAP32[$2 >> 2] = $1;
  return $1;
}
function _enet_list_remove($position) {
  var $1 = $position | 0;
  var $3 = $position + 4 | 0;
  HEAP32[HEAP32[$3 >> 2] >> 2] = HEAP32[$1 >> 2];
  HEAP32[HEAP32[$1 >> 2] + 4 >> 2] = HEAP32[$3 >> 2];
  return $position;
}
function _enet_list_move($position, $dataFirst, $dataLast) {
  var $6$s2;
  var $3$s2;
  var $1 = $dataFirst;
  var $3$s2 = $dataLast >> 2;
  var $6$s2 = ($dataFirst + 4 | 0) >> 2;
  HEAP32[HEAP32[$6$s2] >> 2] = HEAP32[$3$s2];
  HEAP32[HEAP32[$3$s2] + 4 >> 2] = HEAP32[$6$s2];
  var $12 = $position + 4 | 0;
  HEAP32[$6$s2] = HEAP32[$12 >> 2];
  HEAP32[$3$s2] = $position;
  HEAP32[HEAP32[$6$s2] >> 2] = $1;
  HEAP32[$12 >> 2] = $dataLast;
  return $1;
}
function _enet_list_size($list) {
  var $1 = $list | 0;
  var $position_01 = HEAP32[$list >> 2];
  if (($position_01 | 0) == ($1 | 0)) {
    var $size_0_lcssa = 0;
    var $size_0_lcssa;
    return $size_0_lcssa;
  } else {
    var $size_02 = 0;
    var $position_03 = $position_01;
  }
  while (1) {
    var $position_03;
    var $size_02;
    var $4 = $size_02 + 1 | 0;
    var $position_0 = HEAP32[$position_03 >> 2];
    if (($position_0 | 0) == ($1 | 0)) {
      var $size_0_lcssa = $4;
      break;
    } else {
      var $size_02 = $4;
      var $position_03 = $position_0;
    }
  }
  var $size_0_lcssa;
  return $size_0_lcssa;
}
function _enet_host_create($address, $peerCount, $channelLimit, $incomingBandwidth, $outgoingBandwidth) {
  var $81$s2;
  var $76$s2;
  var $73$s2;
  var $16$s2;
  var $11$s2;
  if ($peerCount >>> 0 > 4095) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $3 = _enet_malloc(10380);
  var $4 = $3;
  if (($3 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  for (var $$dest = $3 >> 2, $$stop = $$dest + 2595; $$dest < $$stop; $$dest++) {
    HEAP32[$$dest] = 0;
  }
  var $7 = $peerCount * 380 | 0;
  var $8 = _enet_malloc($7);
  var $11$s2 = ($3 + 36 | 0) >> 2;
  HEAP32[$11$s2] = $8;
  if (($8 | 0) == 0) {
    _enet_free($3);
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  _memset($8, 0, $7, 4);
  var $15 = _enet_socket_create(2);
  var $16$s2 = $3 >> 2;
  HEAP32[$16$s2] = $15;
  var $17 = ($15 | 0) == -1;
  L357 : do {
    if (!$17) {
      do {
        if (($address | 0) == 0) {
          _enet_socket_set_option($15, 1, 1);
          _enet_socket_set_option(HEAP32[$16$s2], 2, 1);
          _enet_socket_set_option(HEAP32[$16$s2], 3, 262144);
          _enet_socket_set_option(HEAP32[$16$s2], 4, 262144);
        } else {
          var $22 = (_enet_socket_bind($15, $address) | 0) < 0;
          var $_pr = HEAP32[$16$s2];
          if (!$22) {
            _enet_socket_set_option($_pr, 1, 1);
            _enet_socket_set_option(HEAP32[$16$s2], 2, 1);
            _enet_socket_set_option(HEAP32[$16$s2], 3, 262144);
            _enet_socket_set_option(HEAP32[$16$s2], 4, 262144);
            var $37 = $address;
            var $38 = $3 + 4 | 0;
            var $39$1 = HEAP32[$37 + 4 >> 2];
            HEAP32[$38 >> 2] = HEAP32[$37 >> 2];
            HEAP32[$38 + 4 >> 2] = $39$1;
            break;
          }
          if (($_pr | 0) == -1) {
            break L357;
          }
          _enet_socket_destroy($_pr);
          break L357;
        }
      } while (0);
      var $48 = ($channelLimit | 0) == 0;
      if ($48 | $channelLimit >>> 0 > 255) {
        var $_02 = 255;
      } else {
        var $_02 = $48 ? 1 : $channelLimit;
      }
      var $_02;
      var $54 = _time(0) + $3 | 0;
      HEAP32[$3 + 28 >> 2] = $54 << 16 | $54 >>> 16;
      HEAP32[$3 + 44 >> 2] = $_02;
      HEAP32[$3 + 12 >> 2] = $incomingBandwidth;
      HEAP32[$3 + 16 >> 2] = $outgoingBandwidth;
      HEAP32[$3 + 20 >> 2] = 0;
      HEAP32[$3 + 32 >> 2] = 0;
      HEAP32[$3 + 24 >> 2] = 1400;
      var $73$s2 = ($3 + 40 | 0) >> 2;
      HEAP32[$73$s2] = $peerCount;
      HEAP32[$3 + 1608 >> 2] = 0;
      var $76$s2 = ($3 + 2132 | 0) >> 2;
      HEAP32[$3 + 10348 >> 2] = 0;
      HEAP16[$3 + 10352 >> 1] = 0;
      var $81$s2 = ($3 + 10356 | 0) >> 2;
      HEAP32[$76$s2] = 0;
      HEAP32[$76$s2 + 1] = 0;
      HEAP32[$76$s2 + 2] = 0;
      HEAP32[$76$s2 + 3] = 0;
      HEAP32[$76$s2 + 4] = 0;
      HEAP32[$76$s2 + 5] = 0;
      HEAP32[$81$s2] = 0;
      HEAP32[$81$s2 + 1] = 0;
      HEAP32[$81$s2 + 2] = 0;
      HEAP32[$81$s2 + 3] = 0;
      HEAP32[$81$s2 + 4] = 0;
      HEAP32[$81$s2 + 5] = 0;
      _enet_list_clear($3 + 52 | 0);
      if ((HEAP32[$73$s2] | 0) <= 0) {
        var $_0 = $4;
        var $_0;
        return $_0;
      }
      var $currentPeer_03 = HEAP32[$11$s2];
      while (1) {
        var $currentPeer_03;
        HEAP32[$currentPeer_03 + 8 >> 2] = $4;
        HEAP16[$currentPeer_03 + 14 >> 1] = ($currentPeer_03 - HEAP32[$11$s2] | 0) / 380 & -1 & 65535;
        HEAP8[$currentPeer_03 + 21 | 0] = -1;
        HEAP8[$currentPeer_03 + 20 | 0] = -1;
        HEAP32[$currentPeer_03 + 32 >> 2] = 0;
        _enet_list_clear($currentPeer_03 + 192 | 0);
        _enet_list_clear($currentPeer_03 + 200 | 0);
        _enet_list_clear($currentPeer_03 + 208 | 0);
        _enet_list_clear($currentPeer_03 + 216 | 0);
        _enet_list_clear($currentPeer_03 + 224 | 0);
        _enet_list_clear($currentPeer_03 + 232 | 0);
        _enet_peer_reset($currentPeer_03);
        var $105 = $currentPeer_03 + 380 | 0;
        if ($105 >>> 0 < (HEAP32[$11$s2] + HEAP32[$73$s2] * 380 | 0) >>> 0) {
          var $currentPeer_03 = $105;
        } else {
          var $_0 = $4;
          break;
        }
      }
      var $_0;
      return $_0;
    }
  } while (0);
  _enet_free(HEAP32[$11$s2]);
  _enet_free($3);
  var $_0 = 0;
  var $_0;
  return $_0;
}
_enet_host_create["X"] = 1;
function _enet_host_destroy($host) {
  var $3$s2;
  _enet_socket_destroy(HEAP32[$host >> 2]);
  var $3$s2 = ($host + 36 | 0) >> 2;
  var $4 = $host + 40 | 0;
  var $6 = (HEAP32[$4 >> 2] | 0) > 0;
  L379 : do {
    if ($6) {
      var $currentPeer_01 = HEAP32[$3$s2];
      while (1) {
        var $currentPeer_01;
        _enet_peer_reset($currentPeer_01);
        var $9 = $currentPeer_01 + 380 | 0;
        if ($9 >>> 0 < (HEAP32[$3$s2] + HEAP32[$4 >> 2] * 380 | 0) >>> 0) {
          var $currentPeer_01 = $9;
        } else {
          break L379;
        }
      }
    }
  } while (0);
  var $15 = HEAP32[$host + 2140 >> 2];
  do {
    if (($15 | 0) != 0) {
      var $19 = HEAP32[$host + 2152 >> 2];
      if (($19 | 0) == 0) {
        break;
      }
      FUNCTION_TABLE[$19]($15);
    }
  } while (0);
  _enet_free(HEAP32[$3$s2]);
  _enet_free($host);
  return;
}
function _enet_host_connect($host, $address, $channelCount, $data) {
  var $channel_02$s1;
  var $49$s2;
  var $26$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var $command = __stackBase__;
  if (($channelCount | 0) == 0) {
    var $_01 = 1;
  } else {
    var $_01 = $channelCount >>> 0 > 255 ? 255 : $channelCount;
  }
  var $_01;
  var $5 = $host + 36 | 0;
  var $6 = HEAP32[$5 >> 2];
  var $7 = $host + 40 | 0;
  var $9 = $6 + HEAP32[$7 >> 2] * 380 | 0;
  var $currentPeer_0 = $6;
  while (1) {
    var $currentPeer_0;
    if ($currentPeer_0 >>> 0 >= $9 >>> 0) {
      break;
    }
    if ((HEAP32[$currentPeer_0 + 36 >> 2] | 0) == 0) {
      break;
    } else {
      var $currentPeer_0 = $currentPeer_0 + 380 | 0;
    }
  }
  if ($currentPeer_0 >>> 0 >= (HEAP32[$5 >> 2] + HEAP32[$7 >> 2] * 380 | 0) >>> 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $24 = _enet_malloc($_01 * 60 | 0);
  var $26$s2 = ($currentPeer_0 + 40 | 0) >> 2;
  HEAP32[$26$s2] = $24;
  if (($24 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  HEAP32[$currentPeer_0 + 44 >> 2] = $_01;
  HEAP32[$currentPeer_0 + 36 >> 2] = 1;
  var $32 = $address;
  var $33 = $currentPeer_0 + 24 | 0;
  var $34$1 = HEAP32[$32 + 4 >> 2];
  HEAP32[$33 >> 2] = HEAP32[$32 >> 2];
  HEAP32[$33 + 4 >> 2] = $34$1;
  var $35 = $host + 28 | 0;
  var $37 = HEAP32[$35 >> 2] + 1 | 0;
  HEAP32[$35 >> 2] = $37;
  var $38 = $currentPeer_0 + 16 | 0;
  HEAP32[$38 >> 2] = $37;
  var $39 = $host + 16 | 0;
  var $40 = HEAP32[$39 >> 2];
  if (($40 | 0) == 0) {
    HEAP32[$currentPeer_0 + 180 >> 2] = 32768;
  } else {
    HEAP32[$currentPeer_0 + 180 >> 2] = $40 >>> 4 & 268431360;
  }
  var $49$s2 = ($currentPeer_0 + 180 | 0) >> 2;
  var $50 = HEAP32[$49$s2];
  do {
    if ($50 >>> 0 < 4096) {
      HEAP32[$49$s2] = 4096;
    } else {
      if ($50 >>> 0 <= 32768) {
        break;
      }
      HEAP32[$49$s2] = 32768;
    }
  } while (0);
  var $57 = ($_01 | 0) > 0;
  L411 : do {
    if ($57) {
      var $channel_02 = HEAP32[$26$s2], $channel_02$s1 = $channel_02 >> 1;
      while (1) {
        var $channel_02;
        HEAP16[$channel_02$s1] = 0;
        HEAP16[$channel_02$s1 + 1] = 0;
        HEAP16[$channel_02$s1 + 19] = 0;
        HEAP16[$channel_02$s1 + 20] = 0;
        _enet_list_clear($channel_02 + 44 | 0);
        _enet_list_clear($channel_02 + 52 | 0);
        var $67 = $channel_02 + 60 | 0;
        _memset($channel_02 + 4 | 0, 0, 34, 2);
        if ($67 >>> 0 < (HEAP32[$26$s2] + $_01 * 60 | 0) >>> 0) {
          var $channel_02 = $67, $channel_02$s1 = $channel_02 >> 1;
        } else {
          break L411;
        }
      }
    }
  } while (0);
  HEAP8[$command | 0] = -126;
  HEAP8[$command + 1 | 0] = -1;
  var $77 = $command + 4 | 0;
  tempBigInt = _htons(HEAP16[$currentPeer_0 + 14 >> 1]);
  HEAP8[$77] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$77 + 1] = tempBigInt & 255;
  HEAP8[$command + 6 | 0] = HEAP8[$currentPeer_0 + 21 | 0];
  HEAP8[$command + 7 | 0] = HEAP8[$currentPeer_0 + 20 | 0];
  var $87 = $command + 8 | 0;
  tempBigInt = _htonl(HEAP32[$currentPeer_0 + 176 >> 2]);
  HEAP8[$87] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$87 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$87 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$87 + 3] = tempBigInt & 255;
  var $90 = $command + 12 | 0;
  tempBigInt = _htonl(HEAP32[$49$s2]);
  HEAP8[$90] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$90 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$90 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$90 + 3] = tempBigInt & 255;
  var $92 = $command + 16 | 0;
  tempBigInt = _htonl($_01);
  HEAP8[$92] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$92 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$92 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$92 + 3] = tempBigInt & 255;
  var $96 = $command + 20 | 0;
  tempBigInt = _htonl(HEAP32[$host + 12 >> 2]);
  HEAP8[$96] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$96 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$96 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$96 + 3] = tempBigInt & 255;
  var $99 = $command + 24 | 0;
  tempBigInt = _htonl(HEAP32[$39 >> 2]);
  HEAP8[$99] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$99 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$99 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$99 + 3] = tempBigInt & 255;
  var $103 = $command + 28 | 0;
  tempBigInt = _htonl(HEAP32[$currentPeer_0 + 132 >> 2]);
  HEAP8[$103] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$103 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$103 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$103 + 3] = tempBigInt & 255;
  var $107 = $command + 32 | 0;
  tempBigInt = _htonl(HEAP32[$currentPeer_0 + 124 >> 2]);
  HEAP8[$107] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$107 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$107 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$107 + 3] = tempBigInt & 255;
  var $111 = $command + 36 | 0;
  tempBigInt = _htonl(HEAP32[$currentPeer_0 + 128 >> 2]);
  HEAP8[$111] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$111 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$111 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$111 + 3] = tempBigInt & 255;
  var $113 = $command + 40 | 0;
  tempBigInt = HEAP32[$38 >> 2];
  HEAP8[$113] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$113 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$113 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$113 + 3] = tempBigInt & 255;
  var $115 = $command + 44 | 0;
  tempBigInt = _htonl($data);
  HEAP8[$115] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$115 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$115 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$115 + 3] = tempBigInt & 255;
  _enet_peer_queue_outgoing_command($currentPeer_0, $command, 0, 0, 0);
  var $_0 = $currentPeer_0;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
_enet_host_connect["X"] = 1;
function _enet_host_broadcast($host, $channelID, $packet) {
  var $1 = $host + 36 | 0;
  var $2 = $host + 40 | 0;
  var $4 = (HEAP32[$2 >> 2] | 0) > 0;
  L418 : do {
    if ($4) {
      var $currentPeer_01 = HEAP32[$1 >> 2];
      while (1) {
        var $currentPeer_01;
        if ((HEAP32[$currentPeer_01 + 36 >> 2] | 0) == 5) {
          _enet_peer_send($currentPeer_01, $channelID, $packet);
        }
        var $13 = $currentPeer_01 + 380 | 0;
        if ($13 >>> 0 < (HEAP32[$1 >> 2] + HEAP32[$2 >> 2] * 380 | 0) >>> 0) {
          var $currentPeer_01 = $13;
        } else {
          break L418;
        }
      }
    }
  } while (0);
  if ((HEAP32[$packet >> 2] | 0) != 0) {
    return;
  }
  _enet_packet_destroy($packet);
  return;
}
function _enet_host_compress($host, $compressor) {
  var $14$s2;
  var $13$s2;
  var $1 = $host + 2140 | 0;
  var $2 = $1 | 0;
  var $3 = HEAP32[$2 >> 2];
  do {
    if (($3 | 0) != 0) {
      var $7 = HEAP32[$host + 2152 >> 2];
      if (($7 | 0) == 0) {
        break;
      }
      FUNCTION_TABLE[$7]($3);
    }
  } while (0);
  if (($compressor | 0) == 0) {
    HEAP32[$2 >> 2] = 0;
    return;
  } else {
    var $13$s2 = $1 >> 2;
    var $14$s2 = $compressor >> 2;
    HEAP32[$13$s2] = HEAP32[$14$s2];
    HEAP32[$13$s2 + 1] = HEAP32[$14$s2 + 1];
    HEAP32[$13$s2 + 2] = HEAP32[$14$s2 + 2];
    HEAP32[$13$s2 + 3] = HEAP32[$14$s2 + 3];
    return;
  }
}
function _enet_host_bandwidth_throttle($host) {
  var $peer_423$s2;
  var $peer_230$s2;
  var $peer_137$s2;
  var $8$s2;
  var $7$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var label;
  var $command = __stackBase__;
  var $1 = _enet_time_get();
  var $2 = $host + 20 | 0;
  var $4 = $1 - HEAP32[$2 >> 2] | 0;
  if ($4 >>> 0 < 1e3) {
    STACKTOP = __stackBase__;
    return;
  }
  var $7$s2 = ($host + 36 | 0) >> 2;
  var $8$s2 = ($host + 40 | 0) >> 2;
  if ((HEAP32[$8$s2] | 0) <= 0) {
    STACKTOP = __stackBase__;
    return;
  }
  var $11 = HEAP32[$7$s2];
  var $13 = $11 + HEAP32[$8$s2] * 380 | 0;
  var $dataTotal_052 = 0;
  var $peersTotal_053 = 0;
  var $peer_054 = $11;
  while (1) {
    var $peer_054;
    var $peersTotal_053;
    var $dataTotal_052;
    if ((HEAP32[$peer_054 + 36 >> 2] - 5 | 0) >>> 0 < 2) {
      var $peersTotal_1 = $peersTotal_053 + 1 | 0;
      var $dataTotal_1 = HEAP32[$peer_054 + 68 >> 2] + $dataTotal_052 | 0;
    } else {
      var $peersTotal_1 = $peersTotal_053;
      var $dataTotal_1 = $dataTotal_052;
    }
    var $dataTotal_1;
    var $peersTotal_1;
    var $23 = $peer_054 + 380 | 0;
    if ($23 >>> 0 < $13 >>> 0) {
      var $dataTotal_052 = $dataTotal_1;
      var $peersTotal_053 = $peersTotal_1;
      var $peer_054 = $23;
    } else {
      break;
    }
  }
  if (($peersTotal_1 | 0) == 0) {
    STACKTOP = __stackBase__;
    return;
  }
  var $27 = $host + 16 | 0;
  var $28 = HEAP32[$27 >> 2];
  do {
    if (($28 | 0) == 0) {
      var $bandwidth_045 = -1;
      var $peersRemaining_046 = $peersTotal_1;
      var $dataTotal_247 = $dataTotal_1;
    } else {
      var $bandwidth_045 = Math.floor((($28 * $4 | 0) >>> 0) / 1e3);
      var $peersRemaining_046 = $peersTotal_1;
      var $dataTotal_247 = $dataTotal_1;
      break;
    }
  } while (0);
  while (1) {
    var $dataTotal_247;
    var $peersRemaining_046;
    var $bandwidth_045;
    if ($dataTotal_247 >>> 0 < $bandwidth_045 >>> 0) {
      var $throttle_1 = 32;
    } else {
      var $throttle_1 = Math.floor(($bandwidth_045 << 5 >>> 0) / ($dataTotal_247 >>> 0));
    }
    var $throttle_1;
    if ((HEAP32[$8$s2] | 0) <= 0) {
      label = 357;
      break;
    }
    var $bandwidth_133 = $bandwidth_045;
    var $peersRemaining_134 = $peersRemaining_046;
    var $dataTotal_335 = $dataTotal_247;
    var $needsAdjustment_136 = 0;
    var $peer_137 = HEAP32[$7$s2], $peer_137$s2 = $peer_137 >> 2;
    while (1) {
      var $peer_137;
      var $needsAdjustment_136;
      var $dataTotal_335;
      var $peersRemaining_134;
      var $bandwidth_133;
      do {
        if ((HEAP32[$peer_137$s2 + 9] - 5 | 0) >>> 0 < 2) {
          var $48 = HEAP32[$peer_137$s2 + 12];
          if (($48 | 0) == 0) {
            var $needsAdjustment_2 = $needsAdjustment_136;
            var $dataTotal_4 = $dataTotal_335;
            var $peersRemaining_2 = $peersRemaining_134;
            var $bandwidth_2 = $bandwidth_133;
            break;
          }
          var $51 = $peer_137 + 60 | 0;
          if ((HEAP32[$51 >> 2] | 0) == ($1 | 0)) {
            var $needsAdjustment_2 = $needsAdjustment_136;
            var $dataTotal_4 = $dataTotal_335;
            var $peersRemaining_2 = $peersRemaining_134;
            var $bandwidth_2 = $bandwidth_133;
            break;
          }
          var $56 = Math.floor((($48 * $4 | 0) >>> 0) / 1e3);
          var $58 = HEAP32[$peer_137$s2 + 17];
          if (($58 * $throttle_1 | 0) >>> 5 >>> 0 <= $56 >>> 0) {
            var $needsAdjustment_2 = $needsAdjustment_136;
            var $dataTotal_4 = $dataTotal_335;
            var $peersRemaining_2 = $peersRemaining_134;
            var $bandwidth_2 = $bandwidth_133;
            break;
          }
          var $64 = Math.floor(($56 << 5 >>> 0) / ($58 >>> 0));
          var $_ = ($64 | 0) == 0 ? 1 : $64;
          HEAP32[$peer_137$s2 + 28] = $_;
          var $67 = $peer_137 + 108 | 0;
          if (HEAP32[$67 >> 2] >>> 0 > $_ >>> 0) {
            HEAP32[$67 >> 2] = $_;
          }
          HEAP32[$51 >> 2] = $1;
          var $needsAdjustment_2 = 1;
          var $dataTotal_4 = $dataTotal_335 - $56 | 0;
          var $peersRemaining_2 = $peersRemaining_134 - 1 | 0;
          var $bandwidth_2 = $bandwidth_133 - $56 | 0;
        } else {
          var $needsAdjustment_2 = $needsAdjustment_136;
          var $dataTotal_4 = $dataTotal_335;
          var $peersRemaining_2 = $peersRemaining_134;
          var $bandwidth_2 = $bandwidth_133;
        }
      } while (0);
      var $bandwidth_2;
      var $peersRemaining_2;
      var $dataTotal_4;
      var $needsAdjustment_2;
      var $76 = $peer_137 + 380 | 0;
      if ($76 >>> 0 < (HEAP32[$7$s2] + HEAP32[$8$s2] * 380 | 0) >>> 0) {
        var $bandwidth_133 = $bandwidth_2;
        var $peersRemaining_134 = $peersRemaining_2;
        var $dataTotal_335 = $dataTotal_4;
        var $needsAdjustment_136 = $needsAdjustment_2;
        var $peer_137 = $76, $peer_137$s2 = $peer_137 >> 2;
      } else {
        break;
      }
    }
    var $32 = ($peersRemaining_2 | 0) != 0;
    if (($needsAdjustment_2 | 0) == 0 | $32 ^ 1) {
      label = 367;
      break;
    } else {
      var $bandwidth_045 = $bandwidth_2;
      var $peersRemaining_046 = $peersRemaining_2;
      var $dataTotal_247 = $dataTotal_4;
    }
  }
  do {
    if (label == 357) {
      if (($peersRemaining_046 | 0) == 0) {
        break;
      } else {
        label = 368;
        break;
      }
    } else if (label == 367) {
      if ($32) {
        label = 368;
        break;
      } else {
        break;
      }
    }
  } while (0);
  L479 : do {
    if (label == 368) {
      if ((HEAP32[$8$s2] | 0) <= 0) {
        break;
      }
      var $peer_230 = HEAP32[$7$s2], $peer_230$s2 = $peer_230 >> 2;
      while (1) {
        var $peer_230;
        do {
          if ((HEAP32[$peer_230$s2 + 9] - 5 | 0) >>> 0 < 2) {
            if ((HEAP32[$peer_230$s2 + 15] | 0) == ($1 | 0)) {
              break;
            }
            HEAP32[$peer_230$s2 + 28] = $throttle_1;
            var $94 = $peer_230 + 108 | 0;
            if (HEAP32[$94 >> 2] >>> 0 <= $throttle_1 >>> 0) {
              break;
            }
            HEAP32[$94 >> 2] = $throttle_1;
          }
        } while (0);
        var $99 = $peer_230 + 380 | 0;
        if ($99 >>> 0 < (HEAP32[$7$s2] + HEAP32[$8$s2] * 380 | 0) >>> 0) {
          var $peer_230 = $99, $peer_230$s2 = $peer_230 >> 2;
        } else {
          break L479;
        }
      }
    }
  } while (0);
  var $104 = $host + 32 | 0;
  var $106 = (HEAP32[$104 >> 2] | 0) == 0;
  L490 : do {
    if (!$106) {
      HEAP32[$104 >> 2] = 0;
      var $109 = HEAP32[$host + 12 >> 2];
      var $or_cond66 = ($109 | 0) == 0 | ($peersTotal_1 | 0) == 0;
      L492 : do {
        if ($or_cond66) {
          var $bandwidthLimit_1_ph = 0;
        } else {
          var $bandwidth_318 = $109;
          var $peersRemaining_319 = $peersTotal_1;
          while (1) {
            var $peersRemaining_319;
            var $bandwidth_318;
            var $114 = Math.floor(($bandwidth_318 >>> 0) / ($peersRemaining_319 >>> 0));
            if ((HEAP32[$8$s2] | 0) <= 0) {
              break L490;
            }
            var $bandwidth_412 = $bandwidth_318;
            var $peersRemaining_413 = $peersRemaining_319;
            var $needsAdjustment_414 = 0;
            var $peer_315 = HEAP32[$7$s2];
            while (1) {
              var $peer_315;
              var $needsAdjustment_414;
              var $peersRemaining_413;
              var $bandwidth_412;
              do {
                if ((HEAP32[$peer_315 + 36 >> 2] - 5 | 0) >>> 0 < 2) {
                  var $122 = $peer_315 + 56 | 0;
                  if ((HEAP32[$122 >> 2] | 0) == ($1 | 0)) {
                    var $needsAdjustment_5 = $needsAdjustment_414;
                    var $peersRemaining_5 = $peersRemaining_413;
                    var $bandwidth_5 = $bandwidth_412;
                    break;
                  }
                  var $126 = $peer_315 + 52 | 0;
                  var $127 = HEAP32[$126 >> 2];
                  if (!(($127 | 0) == 0 | $127 >>> 0 < $114 >>> 0)) {
                    var $needsAdjustment_5 = $needsAdjustment_414;
                    var $peersRemaining_5 = $peersRemaining_413;
                    var $bandwidth_5 = $bandwidth_412;
                    break;
                  }
                  HEAP32[$122 >> 2] = $1;
                  var $needsAdjustment_5 = 1;
                  var $peersRemaining_5 = $peersRemaining_413 - 1 | 0;
                  var $bandwidth_5 = $bandwidth_412 - HEAP32[$126 >> 2] | 0;
                } else {
                  var $needsAdjustment_5 = $needsAdjustment_414;
                  var $peersRemaining_5 = $peersRemaining_413;
                  var $bandwidth_5 = $bandwidth_412;
                }
              } while (0);
              var $bandwidth_5;
              var $peersRemaining_5;
              var $needsAdjustment_5;
              var $135 = $peer_315 + 380 | 0;
              if ($135 >>> 0 < (HEAP32[$7$s2] + HEAP32[$8$s2] * 380 | 0) >>> 0) {
                var $bandwidth_412 = $bandwidth_5;
                var $peersRemaining_413 = $peersRemaining_5;
                var $needsAdjustment_414 = $needsAdjustment_5;
                var $peer_315 = $135;
              } else {
                break;
              }
            }
            if (($peersRemaining_5 | 0) == 0 | ($needsAdjustment_5 | 0) == 0) {
              var $bandwidthLimit_1_ph = $114;
              break L492;
            } else {
              var $bandwidth_318 = $bandwidth_5;
              var $peersRemaining_319 = $peersRemaining_5;
            }
          }
        }
      } while (0);
      var $bandwidthLimit_1_ph;
      if ((HEAP32[$8$s2] | 0) <= 0) {
        break;
      }
      var $142 = $command | 0;
      var $143 = $command + 1 | 0;
      var $144 = $command + 8 | 0;
      var $146 = $command + 4 | 0;
      var $148 = $command + 4 | 0;
      var $peer_423 = HEAP32[$7$s2], $peer_423$s2 = $peer_423 >> 2;
      while (1) {
        var $peer_423;
        if ((HEAP32[$peer_423$s2 + 9] - 5 | 0) >>> 0 < 2) {
          HEAP8[$142] = -118;
          HEAP8[$143] = -1;
          tempBigInt = _htonl(HEAP32[$27 >> 2]);
          HEAP8[$144] = tempBigInt & 255;
          tempBigInt >>= 8;
          HEAP8[$144 + 1] = tempBigInt & 255;
          tempBigInt >>= 8;
          HEAP8[$144 + 2] = tempBigInt & 255;
          tempBigInt >>= 8;
          HEAP8[$144 + 3] = tempBigInt & 255;
          if ((HEAP32[$peer_423$s2 + 14] | 0) == ($1 | 0)) {
            tempBigInt = _htonl(HEAP32[$peer_423$s2 + 13]);
            HEAP8[$146] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$146 + 1] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$146 + 2] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$146 + 3] = tempBigInt & 255;
          } else {
            tempBigInt = _htonl($bandwidthLimit_1_ph);
            HEAP8[$148] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$148 + 1] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$148 + 2] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$148 + 3] = tempBigInt & 255;
          }
          _enet_peer_queue_outgoing_command($peer_423, $command, 0, 0, 0);
        }
        var $167 = $peer_423 + 380 | 0;
        if ($167 >>> 0 < (HEAP32[$7$s2] + HEAP32[$8$s2] * 380 | 0) >>> 0) {
          var $peer_423 = $167, $peer_423$s2 = $peer_423 >> 2;
        } else {
          break L490;
        }
      }
    }
  } while (0);
  HEAP32[$2 >> 2] = $1;
  if ((HEAP32[$8$s2] | 0) <= 0) {
    STACKTOP = __stackBase__;
    return;
  }
  var $peer_527 = HEAP32[$7$s2];
  while (1) {
    var $peer_527;
    HEAP32[$peer_527 + 64 >> 2] = 0;
    HEAP32[$peer_527 + 68 >> 2] = 0;
    var $178 = $peer_527 + 380 | 0;
    if ($178 >>> 0 < (HEAP32[$7$s2] + HEAP32[$8$s2] * 380 | 0) >>> 0) {
      var $peer_527 = $178;
    } else {
      break;
    }
  }
  STACKTOP = __stackBase__;
  return;
}
_enet_host_bandwidth_throttle["X"] = 1;
function _reflect_crc($val, $bits) {
  if (($bits | 0) <= 0) {
    var $result_0_lcssa = 0;
    var $result_0_lcssa;
    return $result_0_lcssa;
  }
  var $2 = $bits - 1 | 0;
  var $result_01 = 0;
  var $bit_02 = 0;
  var $_03 = $val;
  while (1) {
    var $_03;
    var $bit_02;
    var $result_01;
    if (($_03 & 1 | 0) == 0) {
      var $result_1 = $result_01;
    } else {
      var $result_1 = 1 << $2 - $bit_02 | $result_01;
    }
    var $result_1;
    var $12 = $bit_02 + 1 | 0;
    if (($12 | 0) == ($bits | 0)) {
      var $result_0_lcssa = $result_1;
      break;
    } else {
      var $result_01 = $result_1;
      var $bit_02 = $12;
      var $_03 = $_03 >> 1;
    }
  }
  var $result_0_lcssa;
  return $result_0_lcssa;
}
function _enet_peer_throttle($peer, $rtt) {
  var $15$s2;
  var $peer$s2 = $peer >> 2;
  var $2 = HEAP32[$peer$s2 + 38];
  var $4 = HEAP32[$peer$s2 + 40];
  if ($2 >>> 0 <= $4 >>> 0) {
    HEAP32[$peer$s2 + 27] = HEAP32[$peer$s2 + 28];
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  if ($2 >>> 0 > $rtt >>> 0) {
    var $15$s2 = ($peer + 108 | 0) >> 2;
    var $17 = HEAP32[$15$s2] + HEAP32[$peer$s2 + 31] | 0;
    HEAP32[$15$s2] = $17;
    var $19 = HEAP32[$peer$s2 + 28];
    if ($17 >>> 0 <= $19 >>> 0) {
      var $_0 = 1;
      var $_0;
      return $_0;
    }
    HEAP32[$15$s2] = $19;
    var $_0 = 1;
    var $_0;
    return $_0;
  } else {
    if ((($4 << 1) + $2 | 0) >>> 0 >= $rtt >>> 0) {
      var $_0 = 0;
      var $_0;
      return $_0;
    }
    var $27 = $peer + 108 | 0;
    var $28 = HEAP32[$27 >> 2];
    var $30 = HEAP32[$peer$s2 + 32];
    HEAP32[$27 >> 2] = $28 >>> 0 > $30 >>> 0 ? $28 - $30 | 0 : 0;
    var $_0 = -1;
    var $_0;
    return $_0;
  }
}
function _enet_packet_create($data, $dataLength, $flags) {
  var $1$s2;
  var $1 = _enet_malloc(20), $1$s2 = $1 >> 2;
  var $2 = $1;
  if (($1 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  do {
    if (($flags & 4 | 0) == 0) {
      if (($dataLength | 0) == 0) {
        HEAP32[$1$s2 + 2] = 0;
        break;
      }
      var $16 = _enet_malloc($dataLength);
      HEAP32[$1$s2 + 2] = $16;
      if (($16 | 0) == 0) {
        _enet_free($1);
        var $_0 = 0;
        var $_0;
        return $_0;
      } else {
        if (($data | 0) == 0) {
          break;
        }
        _memcpy($16, $data, $dataLength, 1);
        break;
      }
    } else {
      HEAP32[$1$s2 + 2] = $data;
    }
  } while (0);
  HEAP32[$1$s2] = 0;
  HEAP32[$1$s2 + 1] = $flags;
  HEAP32[$1$s2 + 3] = $dataLength;
  HEAP32[$1$s2 + 4] = 0;
  var $_0 = $2;
  var $_0;
  return $_0;
}
function _enet_packet_destroy($packet) {
  var $2 = HEAP32[$packet + 16 >> 2];
  if (($2 | 0) != 0) {
    FUNCTION_TABLE[$2]($packet);
  }
  do {
    if ((HEAP32[$packet + 4 >> 2] & 4 | 0) == 0) {
      var $12 = HEAP32[$packet + 8 >> 2];
      if (($12 | 0) == 0) {
        break;
      }
      _enet_free($12);
    }
  } while (0);
  _enet_free($packet);
  return;
}
function _enet_packet_resize($packet, $dataLength) {
  var $14$s2;
  var $1$s2;
  var $1$s2 = ($packet + 12 | 0) >> 2;
  do {
    if (HEAP32[$1$s2] >>> 0 < $dataLength >>> 0) {
      if ((HEAP32[$packet + 4 >> 2] & 4 | 0) != 0) {
        break;
      }
      var $11 = _enet_malloc($dataLength);
      if (($11 | 0) == 0) {
        var $_0 = -1;
        var $_0;
        return $_0;
      }
      var $14$s2 = ($packet + 8 | 0) >> 2;
      _memcpy($11, HEAP32[$14$s2], HEAP32[$1$s2], 1);
      _enet_free(HEAP32[$14$s2]);
      HEAP32[$14$s2] = $11;
      HEAP32[$1$s2] = $dataLength;
      var $_0 = 0;
      var $_0;
      return $_0;
    }
  } while (0);
  HEAP32[$1$s2] = $dataLength;
  var $_0 = 0;
  var $_0;
  return $_0;
}
function _enet_crc32($buffers, $bufferCount) {
  if (!HEAP8[_initializedCRC32_b]) {
    _initialize_crc32();
  }
  if (($bufferCount | 0) == 0) {
    var $crc_0_lcssa = -1;
    var $crc_0_lcssa;
    var $22 = $crc_0_lcssa ^ -1;
    var $23 = _htonl($22);
    return $23;
  } else {
    var $crc_04 = -1;
    var $_05 = $buffers;
    var $_in = $bufferCount;
  }
  while (1) {
    var $_in;
    var $_05;
    var $crc_04;
    var $3 = $_in - 1 | 0;
    var $5 = HEAP32[$_05 >> 2];
    var $7 = HEAP32[$_05 + 4 >> 2];
    var $8 = $5 + $7 | 0;
    var $9 = ($7 | 0) > 0;
    L591 : do {
      if ($9) {
        var $data_02 = $5;
        var $crc_13 = $crc_04;
        while (1) {
          var $crc_13;
          var $data_02;
          var $12 = $data_02 + 1 | 0;
          var $18 = HEAP32[_crcTable + ((HEAP8[$data_02] & 255 ^ $crc_13 & 255) << 2) >> 2] ^ $crc_13 >>> 8;
          if ($12 >>> 0 < $8 >>> 0) {
            var $data_02 = $12;
            var $crc_13 = $18;
          } else {
            var $crc_1_lcssa = $18;
            break L591;
          }
        }
      } else {
        var $crc_1_lcssa = $crc_04;
      }
    } while (0);
    var $crc_1_lcssa;
    if (($3 | 0) == 0) {
      var $crc_0_lcssa = $crc_1_lcssa;
      break;
    } else {
      var $crc_04 = $crc_1_lcssa;
      var $_05 = $_05 + 8 | 0;
      var $_in = $3;
    }
  }
  var $crc_0_lcssa;
  var $22 = $crc_0_lcssa ^ -1;
  var $23 = _htonl($22);
  return $23;
}
function _initialize_crc32() {
  var $byte_03 = 0;
  while (1) {
    var $byte_03;
    var $2 = _reflect_crc($byte_03, 8);
    var $4 = $2 << 25;
    var $crc_1 = ($2 & 128 | 0) != 0 ? $4 ^ 79764919 : $4;
    var $7 = $crc_1 << 1;
    var $crc_1_1 = ($crc_1 | 0) < 0 ? $7 ^ 79764919 : $7;
    var $10 = $crc_1_1 << 1;
    var $crc_1_2 = ($crc_1_1 | 0) < 0 ? $10 ^ 79764919 : $10;
    var $13 = $crc_1_2 << 1;
    var $crc_1_3 = ($crc_1_2 | 0) < 0 ? $13 ^ 79764919 : $13;
    var $16 = $crc_1_3 << 1;
    var $crc_1_4 = ($crc_1_3 | 0) < 0 ? $16 ^ 79764919 : $16;
    var $19 = $crc_1_4 << 1;
    var $crc_1_5 = ($crc_1_4 | 0) < 0 ? $19 ^ 79764919 : $19;
    var $22 = $crc_1_5 << 1;
    var $crc_1_6 = ($crc_1_5 | 0) < 0 ? $22 ^ 79764919 : $22;
    var $25 = $crc_1_6 << 1;
    var $27 = _reflect_crc(($crc_1_6 | 0) < 0 ? $25 ^ 79764919 : $25, 32);
    HEAP32[_crcTable + ($byte_03 << 2) >> 2] = $27;
    var $29 = $byte_03 + 1 | 0;
    if (($29 | 0) == 256) {
      break;
    } else {
      var $byte_03 = $29;
    }
  }
  HEAP8[_initializedCRC32_b] = 1;
  return;
}
function _enet_peer_throttle_configure($peer, $interval, $acceleration, $deceleration) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var $command = __stackBase__;
  HEAP32[$peer + 132 >> 2] = $interval;
  HEAP32[$peer + 124 >> 2] = $acceleration;
  HEAP32[$peer + 128 >> 2] = $deceleration;
  HEAP8[$command | 0] = -117;
  HEAP8[$command + 1 | 0] = -1;
  var $8 = $command + 4 | 0;
  tempBigInt = _htonl($interval);
  HEAP8[$8] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$8 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$8 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$8 + 3] = tempBigInt & 255;
  var $10 = $command + 8 | 0;
  tempBigInt = _htonl($acceleration);
  HEAP8[$10] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$10 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$10 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$10 + 3] = tempBigInt & 255;
  var $12 = $command + 12 | 0;
  tempBigInt = _htonl($deceleration);
  HEAP8[$12] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$12 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$12 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$12 + 3] = tempBigInt & 255;
  _enet_peer_queue_outgoing_command($peer, $command, 0, 0, 0);
  STACKTOP = __stackBase__;
  return;
}
function _enet_peer_queue_outgoing_command($peer, $command, $packet, $offset, $length) {
  var $1 = _enet_malloc(84);
  var $2 = $1;
  if (($1 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  _memcpy($1 + 32 | 0, $command | 0, 48, 1);
  HEAP32[$1 + 24 >> 2] = $offset;
  HEAP16[$1 + 28 >> 1] = $length;
  HEAP32[$1 + 80 >> 2] = $packet;
  if (($packet | 0) != 0) {
    var $15 = $packet | 0;
    HEAP32[$15 >> 2] = HEAP32[$15 >> 2] + 1 | 0;
  }
  _enet_peer_setup_outgoing_command($peer, $2);
  var $_0 = $2;
  var $_0;
  return $_0;
}
function _enet_peer_send($peer, $channelID, $packet) {
  var $12$s2;
  var $3$s1;
  var $peer$s2 = $peer >> 2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 56;
  var label;
  var $command = __stackBase__;
  var $fragments = __stackBase__ + 48;
  var $1 = $channelID & 255;
  var $3$s1 = HEAP32[$peer$s2 + 10] >> 1;
  if ((HEAP32[$peer$s2 + 9] | 0) != 5) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  if ($1 >>> 0 >= HEAP32[$peer$s2 + 11] >>> 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $12$s2 = ($packet + 12 | 0) >> 2;
  var $13 = HEAP32[$12$s2];
  if ($13 >>> 0 > 1073741824) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $_ = ((HEAP32[HEAP32[$peer$s2 + 2] + 2136 >> 2] | 0) == 0 ? -28 : -32) + HEAP32[$peer$s2 + 44] | 0;
  if ($13 >>> 0 <= $_ >>> 0) {
    HEAP8[$command + 1 | 0] = $channelID;
    var $111 = HEAP32[$packet + 4 >> 2];
    var $113 = ($111 & 3 | 0) == 2;
    L621 : do {
      if ($113) {
        HEAP8[$command | 0] = 73;
        var $120 = $command + 6 | 0;
        tempBigInt = _htons(HEAP32[$12$s2] & 65535);
        HEAP8[$120] = tempBigInt & 255;
        tempBigInt >>= 8;
        HEAP8[$120 + 1] = tempBigInt & 255;
      } else {
        do {
          if (($111 & 1 | 0) == 0) {
            if (HEAP16[$3$s1 + ($1 * 30 | 0) + 1] << 16 >> 16 == -1) {
              break;
            }
            HEAP8[$command | 0] = 7;
            var $140 = $command + 6 | 0;
            tempBigInt = _htons(HEAP32[$12$s2] & 65535);
            HEAP8[$140] = tempBigInt & 255;
            tempBigInt >>= 8;
            HEAP8[$140 + 1] = tempBigInt & 255;
            break L621;
          }
        } while (0);
        HEAP8[$command | 0] = -122;
        var $133 = $command + 4 | 0;
        tempBigInt = _htons(HEAP32[$12$s2] & 65535);
        HEAP8[$133] = tempBigInt & 255;
        tempBigInt >>= 8;
        HEAP8[$133 + 1] = tempBigInt & 255;
      }
    } while (0);
    var $_0 = ((_enet_peer_queue_outgoing_command($peer, $command, $packet, 0, HEAP32[$12$s2] & 65535) | 0) == 0) << 31 >> 31;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $27 = Math.floor((($13 - 1 + $_ | 0) >>> 0) / ($_ >>> 0));
  if ($27 >>> 0 > 1048576) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  do {
    if ((HEAP32[$packet + 4 >> 2] & 9 | 0) == 8) {
      var $36 = HEAP16[$3$s1 + ($1 * 30 | 0) + 1];
      if ($36 << 16 >> 16 == -1) {
        label = 480;
        break;
      }
      var $startSequenceNumber_0 = _htons($36 + 1 & 65535);
      var $commandNumber_0 = 12;
      break;
    } else {
      label = 480;
    }
  } while (0);
  if (label == 480) {
    var $startSequenceNumber_0 = _htons(HEAP16[$3$s1 + ($1 * 30 | 0)] + 1 & 65535);
    var $commandNumber_0 = -120;
  }
  var $commandNumber_0;
  var $startSequenceNumber_0;
  _enet_list_clear($fragments);
  var $47 = $fragments | 0;
  var $fragmentOffset_0 = 0;
  var $fragmentLength_1 = $_;
  var $fragmentNumber_0 = 0;
  while (1) {
    var $fragmentNumber_0;
    var $fragmentLength_1;
    var $fragmentOffset_0;
    var $49 = HEAP32[$12$s2];
    if ($fragmentOffset_0 >>> 0 >= $49 >>> 0) {
      label = 487;
      break;
    }
    var $52 = $49 - $fragmentOffset_0 | 0;
    var $_fragmentLength_1 = $52 >>> 0 < $fragmentLength_1 >>> 0 ? $52 : $fragmentLength_1;
    var $54 = _enet_malloc(84);
    if (($54 | 0) == 0) {
      label = 484;
      break;
    }
    HEAP32[$54 + 24 >> 2] = $fragmentOffset_0;
    var $67 = $_fragmentLength_1 & 65535;
    HEAP16[$54 + 28 >> 1] = $67;
    HEAP32[$54 + 80 >> 2] = $packet;
    HEAP8[$54 + 32 | 0] = $commandNumber_0;
    HEAP8[$54 + 33 | 0] = $channelID;
    var $75 = $54 + 36 | 0;
    tempBigInt = $startSequenceNumber_0;
    HEAP8[$75] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$75 + 1] = tempBigInt & 255;
    var $78 = $54 + 38 | 0;
    tempBigInt = _htons($67);
    HEAP8[$78] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$78 + 1] = tempBigInt & 255;
    var $81 = $54 + 40 | 0;
    tempBigInt = _htonl($27);
    HEAP8[$81] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$81 + 1] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$81 + 2] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$81 + 3] = tempBigInt & 255;
    var $84 = $54 + 44 | 0;
    tempBigInt = _htonl($fragmentNumber_0);
    HEAP8[$84] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$84 + 1] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$84 + 2] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$84 + 3] = tempBigInt & 255;
    var $88 = $54 + 48 | 0;
    tempBigInt = _htonl(HEAP32[$12$s2]);
    HEAP8[$88] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$88 + 1] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$88 + 2] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$88 + 3] = tempBigInt & 255;
    var $91 = $54 + 52 | 0;
    tempBigInt = _ntohl($fragmentOffset_0);
    HEAP8[$91] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$91 + 1] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$91 + 2] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$91 + 3] = tempBigInt & 255;
    _enet_list_insert($47, $54);
    var $fragmentOffset_0 = $_fragmentLength_1 + $fragmentOffset_0 | 0;
    var $fragmentLength_1 = $_fragmentLength_1;
    var $fragmentNumber_0 = $fragmentNumber_0 + 1 | 0;
  }
  if (label == 487) {
    var $96 = $packet | 0;
    HEAP32[$96 >> 2] = HEAP32[$96 >> 2] + $fragmentNumber_0 | 0;
    var $99 = $fragments | 0;
    var $100 = $fragments | 0;
    var $101 = HEAP32[$100 >> 2];
    if (($101 | 0) == ($99 | 0)) {
      var $_0 = 0;
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    } else {
      var $103 = $101;
    }
    while (1) {
      var $103;
      _enet_peer_setup_outgoing_command($peer, _enet_list_remove($103));
      var $106 = HEAP32[$100 >> 2];
      if (($106 | 0) == ($99 | 0)) {
        var $_0 = 0;
        break;
      } else {
        var $103 = $106;
      }
    }
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 484) {
    var $56 = $fragments | 0;
    var $57 = $fragments | 0;
    var $58 = HEAP32[$57 >> 2];
    if (($58 | 0) == ($56 | 0)) {
      var $_0 = -1;
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    } else {
      var $60 = $58;
    }
    while (1) {
      var $60;
      _enet_free(_enet_list_remove($60));
      var $62 = HEAP32[$57 >> 2];
      if (($62 | 0) == ($56 | 0)) {
        var $_0 = -1;
        break;
      } else {
        var $60 = $62;
      }
    }
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
}
_enet_peer_send["X"] = 1;
function _enet_peer_setup_outgoing_command($peer, $outgoingCommand) {
  var $31$s1;
  var label;
  var $1 = $outgoingCommand + 33 | 0;
  var $3 = HEAP8[$1] & 255;
  var $5 = HEAP32[$peer + 40 >> 2];
  var $6 = $5 + $3 * 60 | 0;
  var $7 = $outgoingCommand + 32 | 0;
  var $13 = $peer + 68 | 0;
  HEAP32[$13 >> 2] = _enet_protocol_command_size(HEAP8[$7]) + HEAP32[$13 >> 2] + (HEAP16[$outgoingCommand + 28 >> 1] & 65535) | 0;
  do {
    if (HEAP8[$1] << 24 >> 24 == -1) {
      var $20 = $peer + 188 | 0;
      var $22 = HEAP16[$20 >> 1] + 1 & 65535;
      HEAP16[$20 >> 1] = $22;
      HEAP16[$outgoingCommand + 8 >> 1] = $22;
      HEAP16[$outgoingCommand + 10 >> 1] = 0;
    } else {
      var $27 = HEAP8[$7] & 255;
      if (($27 & 128 | 0) != 0) {
        var $31$s1 = ($6 | 0) >> 1;
        HEAP16[$31$s1] = HEAP16[$31$s1] + 1 & 65535;
        HEAP16[($5 + 2 >> 1) + ($3 * 30 | 0)] = 0;
        HEAP16[$outgoingCommand + 8 >> 1] = HEAP16[$31$s1];
        HEAP16[$outgoingCommand + 10 >> 1] = 0;
        break;
      }
      if (($27 & 64 | 0) != 0) {
        var $42 = $peer + 246 | 0;
        HEAP16[$42 >> 1] = HEAP16[$42 >> 1] + 1 & 65535;
        HEAP16[$outgoingCommand + 8 >> 1] = 0;
        HEAP16[$outgoingCommand + 10 >> 1] = 0;
        break;
      }
      if ((HEAP32[$outgoingCommand + 24 >> 2] | 0) == 0) {
        var $52 = $5 + $3 * 60 + 2 | 0;
        HEAP16[$52 >> 1] = HEAP16[$52 >> 1] + 1 & 65535;
      }
      HEAP16[$outgoingCommand + 8 >> 1] = HEAP16[$6 >> 1];
      HEAP16[$outgoingCommand + 10 >> 1] = HEAP16[($5 + 2 >> 1) + ($3 * 30 | 0)];
    }
  } while (0);
  HEAP16[$outgoingCommand + 30 >> 1] = 0;
  HEAP32[$outgoingCommand + 12 >> 2] = 0;
  HEAP32[$outgoingCommand + 16 >> 2] = 0;
  HEAP32[$outgoingCommand + 20 >> 2] = 0;
  var $70 = $outgoingCommand + 34 | 0;
  tempBigInt = _htons(HEAP16[$outgoingCommand + 8 >> 1]);
  HEAP8[$70] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$70 + 1] = tempBigInt & 255;
  var $71 = HEAP8[$7];
  var $73 = $71 & 255 & 15;
  do {
    if (($73 | 0) == 7) {
      var $78 = $outgoingCommand + 36 | 0;
      tempBigInt = _htons(HEAP16[$outgoingCommand + 10 >> 1]);
      HEAP8[$78] = tempBigInt & 255;
      tempBigInt >>= 8;
      HEAP8[$78 + 1] = tempBigInt & 255;
      label = 518;
      break;
    } else if (($73 | 0) == 9) {
      var $83 = $outgoingCommand + 36 | 0;
      tempBigInt = _htons(HEAP16[$peer + 246 >> 1]);
      HEAP8[$83] = tempBigInt & 255;
      tempBigInt >>= 8;
      HEAP8[$83 + 1] = tempBigInt & 255;
      label = 518;
      break;
    } else {
      var $85 = $71;
    }
  } while (0);
  if (label == 518) {
    var $85 = HEAP8[$7];
  }
  var $85;
  if ($85 << 24 >> 24 < 0) {
    _enet_list_insert($peer + 216 | 0, $outgoingCommand);
    return;
  } else {
    _enet_list_insert($peer + 224 | 0, $outgoingCommand);
    return;
  }
}
_enet_peer_setup_outgoing_command["X"] = 1;
function _enet_peer_receive($peer, $channelID) {
  var $1 = $peer + 232 | 0;
  var $3 = HEAP32[$1 >> 2];
  if (($3 | 0) == ($1 | 0)) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $6 = _enet_list_remove($3);
  if (($channelID | 0) != 0) {
    HEAP8[$channelID] = HEAP8[$6 + 13 | 0];
  }
  var $14 = HEAP32[$6 + 72 >> 2];
  var $15 = $14 | 0;
  HEAP32[$15 >> 2] = HEAP32[$15 >> 2] - 1 | 0;
  var $20 = HEAP32[$6 + 68 >> 2];
  if (($20 | 0) != 0) {
    _enet_free($20);
  }
  _enet_free($6);
  var $_0 = $14;
  var $_0;
  return $_0;
}
function _enet_peer_reset_queues($peer) {
  var $24$s2;
  var $40$s2;
  var $20$s2;
  var $1 = $peer + 240 | 0;
  if ((HEAP32[$1 >> 2] | 0) != 0) {
    _enet_list_remove($peer | 0);
    HEAP32[$1 >> 2] = 0;
  }
  var $7 = $peer + 192 | 0;
  var $8 = $7 | 0;
  var $9 = HEAP32[$8 >> 2];
  var $10 = ($9 | 0) == ($7 | 0);
  L697 : do {
    if (!$10) {
      var $11 = $9;
      while (1) {
        var $11;
        _enet_free(_enet_list_remove($11));
        var $13 = HEAP32[$8 >> 2];
        if (($13 | 0) == ($7 | 0)) {
          break L697;
        } else {
          var $11 = $13;
        }
      }
    }
  } while (0);
  _enet_peer_reset_outgoing_commands($peer + 200 | 0);
  _enet_peer_reset_outgoing_commands($peer + 208 | 0);
  _enet_peer_reset_outgoing_commands($peer + 216 | 0);
  _enet_peer_reset_outgoing_commands($peer + 224 | 0);
  _enet_peer_reset_incoming_commands($peer + 232 | 0);
  var $20$s2 = ($peer + 40 | 0) >> 2;
  var $21 = HEAP32[$20$s2];
  if (($21 | 0) == 0) {
    HEAP32[$20$s2] = 0;
    var $40 = $peer + 44 | 0, $40$s2 = $40 >> 2;
    HEAP32[$40$s2] = 0;
    return;
  }
  var $24$s2 = ($peer + 44 | 0) >> 2;
  if ((HEAP32[$24$s2] | 0) == 0) {
    HEAP32[$20$s2] = 0;
    var $40 = $peer + 44 | 0, $40$s2 = $40 >> 2;
    HEAP32[$40$s2] = 0;
    return;
  }
  var $28 = HEAP32[$20$s2];
  var $30 = $21 >>> 0 < ($28 + HEAP32[$24$s2] * 60 | 0) >>> 0;
  L707 : do {
    if ($30) {
      var $channel_01 = $21;
      while (1) {
        var $channel_01;
        _enet_peer_reset_incoming_commands($channel_01 + 44 | 0);
        _enet_peer_reset_incoming_commands($channel_01 + 52 | 0);
        var $33 = $channel_01 + 60 | 0;
        var $35 = HEAP32[$20$s2];
        if ($33 >>> 0 < ($35 + HEAP32[$24$s2] * 60 | 0) >>> 0) {
          var $channel_01 = $33;
        } else {
          var $_lcssa = $35;
          break L707;
        }
      }
    } else {
      var $_lcssa = $28;
    }
  } while (0);
  var $_lcssa;
  _enet_free($_lcssa);
  HEAP32[$20$s2] = 0;
  var $40 = $peer + 44 | 0, $40$s2 = $40 >> 2;
  HEAP32[$40$s2] = 0;
  return;
}
_enet_peer_reset_queues["X"] = 1;
function _enet_peer_reset_outgoing_commands($queue) {
  var $1 = $queue | 0;
  var $2 = $queue | 0;
  var $3 = HEAP32[$2 >> 2];
  if (($3 | 0) == ($1 | 0)) {
    return;
  } else {
    var $5 = $3;
  }
  while (1) {
    var $5;
    var $6 = _enet_list_remove($5);
    var $8 = $6 + 80 | 0;
    var $9 = HEAP32[$8 >> 2];
    do {
      if (($9 | 0) != 0) {
        var $12 = $9 | 0;
        HEAP32[$12 >> 2] = HEAP32[$12 >> 2] - 1 | 0;
        var $15 = HEAP32[$8 >> 2];
        if ((HEAP32[$15 >> 2] | 0) != 0) {
          break;
        }
        _enet_packet_destroy($15);
      }
    } while (0);
    _enet_free($6);
    var $21 = HEAP32[$2 >> 2];
    if (($21 | 0) == ($1 | 0)) {
      break;
    } else {
      var $5 = $21;
    }
  }
  return;
}
function _enet_peer_reset_incoming_commands($queue) {
  _enet_peer_remove_incoming_commands(HEAP32[$queue >> 2], $queue | 0);
  return;
}
function _enet_peer_ping_interval($peer, $pingInterval) {
  HEAP32[$peer + 136 >> 2] = ($pingInterval | 0) != 0 ? $pingInterval : 500;
  return;
}
function _enet_peer_timeout($peer, $timeoutLimit, $timeoutMinimum, $timeoutMaximum) {
  HEAP32[$peer + 140 >> 2] = ($timeoutLimit | 0) != 0 ? $timeoutLimit : 32;
  HEAP32[$peer + 144 >> 2] = ($timeoutMinimum | 0) != 0 ? $timeoutMinimum : 5e3;
  HEAP32[$peer + 148 >> 2] = ($timeoutMaximum | 0) != 0 ? $timeoutMaximum : 3e4;
  return;
}
function _enet_protocol_command_size($commandNumber) {
  return HEAP32[_commandSizes + (($commandNumber & 255 & 15) << 2) >> 2];
}
function _enet_peer_reset($peer) {
  HEAP16[$peer + 12 >> 1] = 4095;
  HEAP32[$peer + 16 >> 2] = 0;
  HEAP32[$peer + 36 >> 2] = 0;
  var $5 = $peer + 108 | 0;
  var $6 = $peer + 48 | 0;
  for (var $$dest = $6 >> 2, $$stop = $$dest + 15; $$dest < $$stop; $$dest++) {
    HEAP32[$$dest] = 0;
  }
  HEAP32[$5 >> 2] = 32;
  HEAP32[$peer + 112 >> 2] = 32;
  HEAP32[$peer + 116 >> 2] = 0;
  HEAP32[$peer + 120 >> 2] = 0;
  HEAP32[$peer + 124 >> 2] = 2;
  HEAP32[$peer + 128 >> 2] = 2;
  HEAP32[$peer + 132 >> 2] = 5e3;
  HEAP32[$peer + 136 >> 2] = 500;
  HEAP32[$peer + 140 >> 2] = 32;
  HEAP32[$peer + 144 >> 2] = 5e3;
  HEAP32[$peer + 148 >> 2] = 3e4;
  HEAP32[$peer + 152 >> 2] = 500;
  HEAP32[$peer + 156 >> 2] = 500;
  HEAP32[$peer + 160 >> 2] = 0;
  HEAP32[$peer + 164 >> 2] = 0;
  HEAP32[$peer + 168 >> 2] = 500;
  HEAP32[$peer + 172 >> 2] = 0;
  HEAP32[$peer + 176 >> 2] = HEAP32[HEAP32[$peer + 8 >> 2] + 24 >> 2];
  HEAP32[$peer + 184 >> 2] = 0;
  HEAP16[$peer + 188 >> 1] = 0;
  HEAP32[$peer + 180 >> 2] = 32768;
  _memset($peer + 244 | 0, 0, 136, 2);
  _enet_peer_reset_queues($peer);
  return;
}
_enet_peer_reset["X"] = 1;
function _enet_peer_ping($peer) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var $command = __stackBase__;
  if ((HEAP32[$peer + 36 >> 2] | 0) != 5) {
    STACKTOP = __stackBase__;
    return;
  }
  HEAP8[$command | 0] = -123;
  HEAP8[$command + 1 | 0] = -1;
  _enet_peer_queue_outgoing_command($peer, $command, 0, 0, 0);
  STACKTOP = __stackBase__;
  return;
}
function _enet_peer_disconnect_now($peer, $data) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var $command = __stackBase__;
  var $2 = HEAP32[$peer + 36 >> 2];
  if (($2 | 0) == 0) {
    STACKTOP = __stackBase__;
    return;
  } else if (!(($2 | 0) == 9 || ($2 | 0) == 7)) {
    _enet_peer_reset_queues($peer);
    HEAP8[$command | 0] = 68;
    HEAP8[$command + 1 | 0] = -1;
    var $8 = $command + 4 | 0;
    tempBigInt = _htonl($data);
    HEAP8[$8] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$8 + 1] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$8 + 2] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$8 + 3] = tempBigInt & 255;
    _enet_peer_queue_outgoing_command($peer, $command, 0, 0, 0);
    _enet_host_flush(HEAP32[$peer + 8 >> 2]);
  }
  _enet_peer_reset($peer);
  STACKTOP = __stackBase__;
  return;
}
function _enet_peer_disconnect($peer, $data) {
  var $1$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var $command = __stackBase__;
  var $1$s2 = ($peer + 36 | 0) >> 2;
  var $2 = HEAP32[$1$s2];
  if (($2 | 0) == 7 || ($2 | 0) == 0 || ($2 | 0) == 8 || ($2 | 0) == 9) {
    STACKTOP = __stackBase__;
    return;
  }
  _enet_peer_reset_queues($peer);
  var $4 = $command | 0;
  HEAP8[$4] = 4;
  HEAP8[$command + 1 | 0] = -1;
  var $8 = $command + 4 | 0;
  tempBigInt = _htonl($data);
  HEAP8[$8] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$8 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$8 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$8 + 3] = tempBigInt & 255;
  HEAP8[$4] = ((HEAP32[$1$s2] - 5 | 0) >>> 0 < 2 ? -128 : 64) | HEAP8[$4];
  _enet_peer_queue_outgoing_command($peer, $command, 0, 0, 0);
  if ((HEAP32[$1$s2] - 5 | 0) >>> 0 < 2) {
    HEAP32[$1$s2] = 7;
    STACKTOP = __stackBase__;
    return;
  } else {
    _enet_host_flush(HEAP32[$peer + 8 >> 2]);
    _enet_peer_reset($peer);
    STACKTOP = __stackBase__;
    return;
  }
}
function _enet_peer_disconnect_later($peer, $data) {
  var $1 = $peer + 36 | 0;
  var $switch = (HEAP32[$1 >> 2] - 5 | 0) >>> 0 < 2;
  L748 : do {
    if ($switch) {
      var $4 = $peer + 216 | 0;
      do {
        if ((HEAP32[$4 >> 2] | 0) == ($4 | 0)) {
          var $9 = $peer + 224 | 0;
          if ((HEAP32[$9 >> 2] | 0) != ($9 | 0)) {
            break;
          }
          var $14 = $peer + 200 | 0;
          if ((HEAP32[$14 >> 2] | 0) == ($14 | 0)) {
            break L748;
          }
        }
      } while (0);
      HEAP32[$1 >> 2] = 6;
      HEAP32[$peer + 376 >> 2] = $data;
      return;
    }
  } while (0);
  _enet_peer_disconnect($peer, $data);
  return;
}
function _enet_peer_queue_acknowledgement($peer, $command, $sentTime) {
  var $3 = HEAP8[$command + 1 | 0] & 255;
  do {
    if ($3 >>> 0 < HEAP32[$peer + 44 >> 2] >>> 0) {
      var $10 = $command + 2 | 0;
      var $11 = (tempInt = HEAPU8[$10] | HEAPU8[$10 + 1] << 8, tempInt << 16 >> 16);
      var $12 = ($11 & 65535) >>> 12;
      var $14 = HEAP16[(HEAP32[$peer + 40 >> 2] + 38 >> 1) + ($3 * 30 | 0)];
      var $18 = (($11 & 65535) < ($14 & 65535) ? $12 | 16 : $12) & 65535;
      var $19 = ($14 & 65535) >>> 12 & 65535;
      if ($18 >>> 0 < ($19 + 7 | 0) >>> 0 | $18 >>> 0 > ($19 + 8 | 0) >>> 0) {
        break;
      } else {
        var $_0 = 0;
      }
      var $_0;
      return $_0;
    }
  } while (0);
  var $25 = _enet_malloc(60);
  if (($25 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $29 = $peer + 68 | 0;
  HEAP32[$29 >> 2] = HEAP32[$29 >> 2] + 8 | 0;
  HEAP32[$25 + 8 >> 2] = $sentTime & 65535;
  _memcpy($25 + 12 | 0, $command | 0, 48, 1);
  _enet_list_insert($peer + 192 | 0, $25);
  var $_0 = $25;
  var $_0;
  return $_0;
}
function _enet_peer_dispatch_incoming_unreliable_commands($peer, $channel) {
  var $2$s2;
  var $1 = $channel + 52 | 0;
  var $2$s2 = ($1 | 0) >> 2;
  var $3 = HEAP32[$2$s2];
  var $4 = $channel + 38 | 0;
  var $5 = $channel + 40 | 0;
  var $6 = $peer + 232 | 0;
  var $7 = $peer + 240 | 0;
  var $8 = $peer + 8 | 0;
  var $9 = $peer;
  var $currentCommand_0 = $3;
  var $startCommand_0 = $3;
  var $droppedCommand_0 = $3;
  L767 : while (1) {
    var $droppedCommand_0;
    var $startCommand_0;
    var $currentCommand_0;
    if (($currentCommand_0 | 0) == ($1 | 0)) {
      break;
    }
    var $13 = $currentCommand_0;
    do {
      if ((HEAP8[$currentCommand_0 + 12 | 0] & 15) << 24 >> 24 == 9) {
        var $startCommand_1 = $startCommand_0;
        var $droppedCommand_1 = $droppedCommand_0;
      } else {
        if (HEAP16[$currentCommand_0 + 8 >> 1] << 16 >> 16 != HEAP16[$4 >> 1] << 16 >> 16) {
          break L767;
        }
        if ((HEAP32[$currentCommand_0 + 64 >> 2] | 0) == 0) {
          HEAP16[$5 >> 1] = HEAP16[$13 + 10 >> 1];
          var $startCommand_1 = $startCommand_0;
          var $droppedCommand_1 = $droppedCommand_0;
          break;
        }
        if (($startCommand_0 | 0) == ($currentCommand_0 | 0)) {
          var $startCommand_1 = HEAP32[$currentCommand_0 >> 2];
          var $droppedCommand_1 = $droppedCommand_0;
          break;
        }
        _enet_list_move($6, $startCommand_0, HEAP32[$currentCommand_0 + 4 >> 2]);
        if ((HEAP32[$7 >> 2] | 0) == 0) {
          _enet_list_insert(HEAP32[$8 >> 2] + 52 | 0, $9);
          HEAP32[$7 >> 2] = 1;
        }
        var $52 = HEAP32[$currentCommand_0 >> 2];
        var $startCommand_1 = $52;
        var $droppedCommand_1 = $52;
      }
    } while (0);
    var $droppedCommand_1;
    var $startCommand_1;
    var $currentCommand_0 = HEAP32[$currentCommand_0 >> 2];
    var $startCommand_0 = $startCommand_1;
    var $droppedCommand_0 = $droppedCommand_1;
  }
  if (($startCommand_0 | 0) == ($currentCommand_0 | 0)) {
    var $droppedCommand_2 = $droppedCommand_0;
    var $droppedCommand_2;
    var $78 = HEAP32[$2$s2];
    _enet_peer_remove_incoming_commands($78, $droppedCommand_2);
    return;
  }
  _enet_list_move($peer + 232 | 0, $startCommand_0, HEAP32[$currentCommand_0 + 4 >> 2]);
  var $65 = $peer + 240 | 0;
  if ((HEAP32[$65 >> 2] | 0) == 0) {
    _enet_list_insert(HEAP32[$peer + 8 >> 2] + 52 | 0, $peer);
    HEAP32[$65 >> 2] = 1;
  }
  var $droppedCommand_2 = HEAP32[$currentCommand_0 >> 2];
  var $droppedCommand_2;
  var $78 = HEAP32[$2$s2];
  _enet_peer_remove_incoming_commands($78, $droppedCommand_2);
  return;
}
_enet_peer_dispatch_incoming_unreliable_commands["X"] = 1;
function _enet_peer_remove_incoming_commands($startCommand, $endCommand) {
  if (($startCommand | 0) == ($endCommand | 0)) {
    return;
  } else {
    var $currentCommand_01 = $startCommand;
  }
  while (1) {
    var $currentCommand_01;
    var $3 = HEAP32[$currentCommand_01 >> 2];
    _enet_list_remove($currentCommand_01);
    var $6 = $currentCommand_01 + 72 | 0;
    var $7 = HEAP32[$6 >> 2];
    do {
      if (($7 | 0) != 0) {
        var $10 = $7 | 0;
        HEAP32[$10 >> 2] = HEAP32[$10 >> 2] - 1 | 0;
        var $13 = HEAP32[$6 >> 2];
        if ((HEAP32[$13 >> 2] | 0) != 0) {
          break;
        }
        _enet_packet_destroy($13);
      }
    } while (0);
    var $20 = HEAP32[$currentCommand_01 + 68 >> 2];
    if (($20 | 0) != 0) {
      _enet_free($20);
    }
    _enet_free($currentCommand_01);
    if (($3 | 0) == ($endCommand | 0)) {
      break;
    } else {
      var $currentCommand_01 = $3;
    }
  }
  return;
}
function _enet_peer_dispatch_incoming_reliable_commands($peer, $channel) {
  var $3$s1;
  var $1 = $channel + 44 | 0;
  var $2 = $1 | 0;
  var $3$s1 = ($channel + 38 | 0) >> 1;
  var $currentCommand_0_in = $2;
  while (1) {
    var $currentCommand_0_in;
    var $currentCommand_0 = HEAP32[$currentCommand_0_in >> 2];
    if (($currentCommand_0 | 0) == ($1 | 0)) {
      break;
    }
    if ((HEAP32[$currentCommand_0 + 64 >> 2] | 0) != 0) {
      break;
    }
    var $14 = HEAP16[$currentCommand_0 + 8 >> 1];
    if ($14 << 16 >> 16 != (HEAP16[$3$s1] + 1 & 65535) << 16 >> 16) {
      break;
    }
    HEAP16[$3$s1] = $14;
    var $22 = HEAP32[$currentCommand_0 + 60 >> 2];
    if (($22 | 0) != 0) {
      HEAP16[$3$s1] = ($14 & 65535) + $22 + 65535 & 65535;
    }
    var $currentCommand_0_in = $currentCommand_0 | 0;
  }
  if (($currentCommand_0 | 0) == (HEAP32[$2 >> 2] | 0)) {
    return;
  }
  HEAP16[$channel + 40 >> 1] = 0;
  _enet_list_move($peer + 232 | 0, HEAP32[$2 >> 2], HEAP32[$currentCommand_0 + 4 >> 2]);
  var $42 = $peer + 240 | 0;
  if ((HEAP32[$42 >> 2] | 0) == 0) {
    _enet_list_insert(HEAP32[$peer + 8 >> 2] + 52 | 0, $peer);
    HEAP32[$42 >> 2] = 1;
  }
  _enet_peer_dispatch_incoming_unreliable_commands($peer, $channel);
  return;
}
_enet_peer_dispatch_incoming_reliable_commands["X"] = 1;
function _enet_peer_queue_incoming_command($peer, $command, $packet, $fragmentCount) {
  var $129$s2;
  var label;
  var $3 = HEAP8[$command + 1 | 0] & 255;
  var $5 = HEAP32[$peer + 40 >> 2];
  var $6 = $5 + $3 * 60 | 0;
  var $9 = (HEAP32[$peer + 36 >> 2] | 0) == 6;
  L822 : do {
    if ($9) {
      label = 680;
    } else {
      var $11 = $command | 0;
      if ((HEAP8[$11] & 15) << 24 >> 24 == 9) {
        var $reliableSequenceNumber_0 = 0;
      } else {
        var $16 = $command + 2 | 0;
        var $17 = (tempInt = HEAPU8[$16] | HEAPU8[$16 + 1] << 8, tempInt << 16 >> 16);
        var $18 = ($17 & 65535) >>> 12;
        var $20 = HEAP16[($5 + 38 >> 1) + ($3 * 30 | 0)];
        var $21 = ($20 & 65535) >>> 12;
        var $reliableWindow_0 = ($17 & 65535) < ($20 & 65535) ? $18 | 16 : $18;
        if (($reliableWindow_0 & 65535) < ($21 & 65535)) {
          label = 680;
          break;
        }
        if (($reliableWindow_0 & 65535) >>> 0 < (($21 & 65535) + 7 | 0) >>> 0) {
          var $reliableSequenceNumber_0 = $17 & 65535;
        } else {
          label = 680;
          break;
        }
      }
      var $reliableSequenceNumber_0;
      var $34 = HEAP8[$11] & 255 & 15;
      L828 : do {
        if (($34 | 0) == 8 || ($34 | 0) == 6) {
          var $36 = $5 + $3 * 60 + 38 | 0;
          if (($reliableSequenceNumber_0 | 0) == (HEAP16[$36 >> 1] & 65535 | 0)) {
            label = 680;
            break L822;
          }
          var $41 = $5 + $3 * 60 + 44 | 0;
          var $currentCommand_0_in = $5 + $3 * 60 + 48 | 0;
          while (1) {
            var $currentCommand_0_in;
            var $currentCommand_0 = HEAP32[$currentCommand_0_in >> 2];
            if (($currentCommand_0 | 0) == ($41 | 0)) {
              var $currentCommand_2 = $currentCommand_0;
              var $unreliableSequenceNumber_0 = 0;
              break L828;
            }
            var $46 = HEAP16[$36 >> 1];
            var $50 = $currentCommand_0 + 8 | 0;
            var $52 = (HEAP16[$50 >> 1] & 65535) < ($46 & 65535);
            do {
              if ($reliableSequenceNumber_0 >>> 0 < ($46 & 65535) >>> 0) {
                if ($52) {
                  label = 650;
                  break;
                } else {
                  var $currentCommand_2 = $currentCommand_0;
                  var $unreliableSequenceNumber_0 = 0;
                  break L828;
                }
              } else {
                if ($52) {
                  break;
                } else {
                  label = 650;
                  break;
                }
              }
            } while (0);
            if (label == 650) {
              label = 0;
              var $57 = HEAP16[$50 >> 1] & 65535;
              if ($57 >>> 0 <= $reliableSequenceNumber_0 >>> 0) {
                break;
              }
            }
            var $currentCommand_0_in = $currentCommand_0 + 4 | 0;
          }
          if ($57 >>> 0 < $reliableSequenceNumber_0 >>> 0) {
            var $currentCommand_2 = $currentCommand_0;
            var $unreliableSequenceNumber_0 = 0;
          } else {
            label = 680;
            break L822;
          }
        } else if (($34 | 0) == 7 || ($34 | 0) == 12) {
          var $64 = $command + 4 | 0;
          var $66 = _ntohs((tempInt = HEAPU8[$64] | HEAPU8[$64 + 1] << 8, tempInt << 16 >> 16));
          var $67 = $5 + $3 * 60 + 38 | 0;
          if (($reliableSequenceNumber_0 | 0) == (HEAP16[$67 >> 1] & 65535 | 0)) {
            if (($66 & 65535) <= (HEAP16[($5 + 40 >> 1) + ($3 * 30 | 0)] & 65535)) {
              label = 680;
              break L822;
            }
          }
          var $76 = $5 + $3 * 60 + 52 | 0;
          var $currentCommand_1_in = $5 + $3 * 60 + 56 | 0;
          L845 : while (1) {
            var $currentCommand_1_in;
            var $currentCommand_1 = HEAP32[$currentCommand_1_in >> 2];
            if (($currentCommand_1 | 0) == ($76 | 0)) {
              var $currentCommand_2 = $currentCommand_1;
              var $unreliableSequenceNumber_0 = $66;
              break L828;
            }
            var $81 = $currentCommand_1;
            do {
              if ((HEAP8[$11] & 15) << 24 >> 24 != 9) {
                var $86 = HEAP16[$67 >> 1];
                var $90 = $currentCommand_1 + 8 | 0;
                var $92 = (HEAP16[$90 >> 1] & 65535) < ($86 & 65535);
                if ($reliableSequenceNumber_0 >>> 0 < ($86 & 65535) >>> 0) {
                  if (!$92) {
                    var $currentCommand_2 = $currentCommand_1;
                    var $unreliableSequenceNumber_0 = $66;
                    break L828;
                  }
                } else {
                  if ($92) {
                    break;
                  }
                }
                var $97 = HEAP16[$90 >> 1] & 65535;
                if ($97 >>> 0 < $reliableSequenceNumber_0 >>> 0) {
                  var $currentCommand_2 = $currentCommand_1;
                  var $unreliableSequenceNumber_0 = $66;
                  break L828;
                }
                if ($97 >>> 0 > $reliableSequenceNumber_0 >>> 0) {
                  break;
                }
                var $103 = HEAP16[$81 + 10 >> 1];
                if (($103 & 65535) <= ($66 & 65535)) {
                  break L845;
                }
              }
            } while (0);
            var $currentCommand_1_in = $currentCommand_1 + 4 | 0;
          }
          if (($103 & 65535) < ($66 & 65535)) {
            var $currentCommand_2 = $currentCommand_1;
            var $unreliableSequenceNumber_0 = $66;
          } else {
            label = 680;
            break L822;
          }
        } else if (($34 | 0) == 9) {
          var $currentCommand_2 = $5 + $3 * 60 + 52 | 0;
          var $unreliableSequenceNumber_0 = 0;
        } else {
          label = 680;
          break L822;
        }
      } while (0);
      var $unreliableSequenceNumber_0;
      var $currentCommand_2;
      var $111 = _enet_malloc(76);
      var $112 = $111;
      if (($111 | 0) == 0) {
        break;
      }
      var $115 = $command + 2 | 0;
      HEAP16[$111 + 8 >> 1] = (tempInt = HEAPU8[$115] | HEAPU8[$115 + 1] << 8, tempInt << 16 >> 16);
      HEAP16[$111 + 10 >> 1] = $unreliableSequenceNumber_0;
      _memcpy($111 + 12 | 0, $11, 48, 1);
      HEAP32[$111 + 60 >> 2] = $fragmentCount;
      HEAP32[$111 + 64 >> 2] = $fragmentCount;
      HEAP32[$111 + 72 >> 2] = $packet;
      var $129$s2 = ($111 + 68 | 0) >> 2;
      HEAP32[$129$s2] = 0;
      do {
        if (($fragmentCount | 0) != 0) {
          if ($fragmentCount >>> 0 < 1048577) {
            var $138 = _enet_malloc(($fragmentCount + 31 | 0) >>> 3 & 536870908);
            HEAP32[$129$s2] = $138;
            var $140 = $138;
          } else {
            var $140 = HEAP32[$129$s2];
          }
          var $140;
          if (($140 | 0) == 0) {
            _enet_free($111);
            break L822;
          } else {
            _memset($140, 0, ($fragmentCount + 31 | 0) >>> 3 & 536870908, 4);
            break;
          }
        }
      } while (0);
      if (($packet | 0) != 0) {
        var $151 = $packet | 0;
        HEAP32[$151 >> 2] = HEAP32[$151 >> 2] + 1 | 0;
      }
      _enet_list_insert(HEAP32[$currentCommand_2 >> 2], $111);
      var $160 = HEAP8[$11] & 255 & 15;
      if (($160 | 0) == 8 || ($160 | 0) == 6) {
        _enet_peer_dispatch_incoming_reliable_commands($peer, $6);
        var $_0 = $112;
        var $_0;
        return $_0;
      } else {
        _enet_peer_dispatch_incoming_unreliable_commands($peer, $6);
        var $_0 = $112;
        var $_0;
        return $_0;
      }
    }
  } while (0);
  do {
    if (label == 680) {
      if (($fragmentCount | 0) != 0) {
        break;
      }
      if (($packet | 0) == 0) {
        var $_0 = _enet_peer_queue_incoming_command_dummyCommand;
        var $_0;
        return $_0;
      }
      if ((HEAP32[$packet >> 2] | 0) != 0) {
        var $_0 = _enet_peer_queue_incoming_command_dummyCommand;
        var $_0;
        return $_0;
      }
      _enet_packet_destroy($packet);
      var $_0 = _enet_peer_queue_incoming_command_dummyCommand;
      var $_0;
      return $_0;
    }
  } while (0);
  if (($packet | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  if ((HEAP32[$packet >> 2] | 0) != 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  _enet_packet_destroy($packet);
  var $_0 = 0;
  var $_0;
  return $_0;
}
_enet_peer_queue_incoming_command["X"] = 1;
function _enet_host_flush($host) {
  HEAP32[$host + 48 >> 2] = _enet_time_get();
  _enet_protocol_send_outgoing_commands($host, 0, 0);
  return;
}
function _enet_protocol_send_outgoing_commands($host, $event, $checkForTimeouts) {
  var $180$s1;
  var $133$s2;
  var $129$s2;
  var $109$s2;
  var $currentPeer_0$s2;
  var $24$s2;
  var $10$s2;
  var $7$s2;
  var $6$s2;
  var $4$s1;
  var $1$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var label;
  var $headerData1 = __stackBase__;
  var $headerData1_sub = $headerData1 | 0;
  var $tmpcast = $headerData1;
  var $0 = $headerData1;
  var $1$s2 = ($host + 60 | 0) >> 2;
  HEAP32[$1$s2] = 1;
  var $2 = $host + 36 | 0;
  var $3 = $host + 40 | 0;
  var $4$s1 = ($host + 68 | 0) >> 1;
  var $5 = $host + 1608 | 0;
  var $6$s2 = ($host + 2132 | 0) >> 2;
  var $7$s2 = ($host + 64 | 0) >> 2;
  var $8 = ($checkForTimeouts | 0) == 0;
  var $9 = $host + 48 | 0;
  var $10$s2 = ($host + 48 | 0) >> 2;
  var $11 = $host + 1612 | 0;
  var $12 = $11 | 0;
  var $13 = $11 | 0;
  var $14 = $headerData1 + 2 | 0;
  var $15 = $host + 1616 | 0;
  var $16 = $host + 2140 | 0;
  var $17 = $host + 2136 | 0;
  var $18 = $host | 0;
  var $19 = $host + 10364 | 0;
  var $20 = $host + 10368 | 0;
  var $21 = $host + 6252 | 0;
  var $22 = $host + 1620 | 0;
  var $23 = $host + 1624 | 0;
  var $24$s2 = ($host + 1616 | 0) >> 2;
  var $25 = $host + 2144 | 0;
  var $26 = $host + 1620 | 0;
  var $27 = $host + 6252 | 0;
  var $28 = $host + 1616 | 0;
  var $29 = $host + 48 | 0;
  var $30 = ($event | 0) == 0;
  var $31 = $event | 0;
  L899 : while (1) {
    HEAP32[$1$s2] = 0;
    var $currentPeer_0 = HEAP32[$2 >> 2], $currentPeer_0$s2 = $currentPeer_0 >> 2;
    while (1) {
      var $currentPeer_0;
      if ($currentPeer_0 >>> 0 >= (HEAP32[$2 >> 2] + HEAP32[$3 >> 2] * 380 | 0) >>> 0) {
        break;
      }
      var $41 = HEAP32[$currentPeer_0$s2 + 9];
      L904 : do {
        if (!(($41 | 0) == 0 || ($41 | 0) == 9)) {
          HEAP16[$4$s1] = 0;
          HEAP32[$5 >> 2] = 0;
          HEAP32[$6$s2] = 1;
          HEAP32[$7$s2] = 4;
          var $43 = $currentPeer_0 + 192 | 0;
          if ((HEAP32[$43 >> 2] | 0) != ($43 | 0)) {
            _enet_protocol_send_acknowledgements($host, $currentPeer_0);
          }
          do {
            if (!$8) {
              var $50 = $currentPeer_0 + 200 | 0;
              if ((HEAP32[$50 >> 2] | 0) == ($50 | 0)) {
                break;
              }
              if ((HEAP32[$29 >> 2] - HEAP32[$currentPeer_0$s2 + 20] | 0) >>> 0 > 86399999) {
                break;
              }
              if ((_enet_protocol_check_timeouts($host, $currentPeer_0, $event) | 0) != 1) {
                break;
              }
              if ($30) {
                break L904;
              }
              if ((HEAP32[$31 >> 2] | 0) == 0) {
                break L904;
              } else {
                var $_0 = 1;
                label = 748;
                break L899;
              }
            }
          } while (0);
          var $68 = $currentPeer_0 + 216 | 0;
          do {
            if ((HEAP32[$68 >> 2] | 0) == ($68 | 0)) {
              label = 712;
            } else {
              if ((_enet_protocol_send_reliable_outgoing_commands($host, $currentPeer_0) | 0) == 0) {
                break;
              } else {
                label = 712;
                break;
              }
            }
          } while (0);
          do {
            if (label == 712) {
              label = 0;
              var $76 = $currentPeer_0 + 200 | 0;
              if ((HEAP32[$76 >> 2] | 0) != ($76 | 0)) {
                break;
              }
              var $81 = HEAP32[$9 >> 2];
              var $83 = HEAP32[$currentPeer_0$s2 + 19];
              var $84 = $81 - $83 | 0;
              if (($84 >>> 0 > 86399999 ? $83 - $81 | 0 : $84) >>> 0 < HEAP32[$currentPeer_0$s2 + 34] >>> 0) {
                break;
              }
              if ((HEAP32[$currentPeer_0$s2 + 44] - HEAP32[$7$s2] | 0) >>> 0 <= 3) {
                break;
              }
              _enet_peer_ping($currentPeer_0);
              _enet_protocol_send_reliable_outgoing_commands($host, $currentPeer_0);
            }
          } while (0);
          var $100 = $currentPeer_0 + 224 | 0;
          if ((HEAP32[$100 >> 2] | 0) != ($100 | 0)) {
            _enet_protocol_send_unreliable_outgoing_commands($host, $currentPeer_0);
          }
          if ((HEAP32[$5 >> 2] | 0) == 0) {
            break;
          }
          var $109$s2 = ($currentPeer_0 + 88 | 0) >> 2;
          var $110 = HEAP32[$109$s2];
          var $112 = HEAP32[$10$s2];
          do {
            if (($110 | 0) == 0) {
              HEAP32[$109$s2] = $112;
            } else {
              var $115 = $112 - $110 | 0;
              if (($115 >>> 0 > 86399999 ? $110 - $112 | 0 : $115) >>> 0 <= 9999) {
                break;
              }
              var $121 = $currentPeer_0 + 92 | 0;
              var $122 = HEAP32[$121 >> 2];
              if (($122 | 0) == 0) {
                break;
              }
              var $125 = $currentPeer_0 + 96 | 0;
              var $128 = Math.floor((HEAP32[$125 >> 2] << 16 >>> 0) / ($122 >>> 0));
              var $129$s2 = ($currentPeer_0 + 104 | 0) >> 2;
              var $130 = HEAP32[$129$s2];
              HEAP32[$129$s2] = $130 - ($130 >>> 2) | 0;
              var $133$s2 = ($currentPeer_0 + 100 | 0) >> 2;
              var $134 = HEAP32[$133$s2];
              if ($128 >>> 0 < $134 >>> 0) {
                var $147 = $134 - (($134 - $128 | 0) >>> 3) | 0;
                HEAP32[$133$s2] = $147;
                var $storemerge = HEAP32[$129$s2] + (($147 - $128 | 0) >>> 2) | 0;
              } else {
                var $139 = (($128 - $134 | 0) >>> 3) + $134 | 0;
                HEAP32[$133$s2] = $139;
                var $storemerge = HEAP32[$129$s2] + (($128 - $139 | 0) >>> 2) | 0;
              }
              var $storemerge;
              HEAP32[$129$s2] = $storemerge;
              HEAP32[$109$s2] = HEAP32[$10$s2];
              HEAP32[$121 >> 2] = 0;
              HEAP32[$125 >> 2] = 0;
            }
          } while (0);
          HEAP32[$13 >> 2] = $0;
          if (HEAP16[$4$s1] << 16 >> 16 < 0) {
            HEAP16[$14 >> 1] = _htons(HEAP32[$10$s2] & 65535);
            HEAP32[$15 >> 2] = 4;
          } else {
            HEAP32[$28 >> 2] = 2;
          }
          var $163 = HEAP32[$16 >> 2];
          do {
            if (($163 | 0) == 0) {
              var $shouldCompress_0 = 0;
            } else {
              var $166 = HEAP32[$25 >> 2];
              if (($166 | 0) == 0) {
                var $shouldCompress_0 = 0;
                break;
              }
              var $170 = HEAP32[$7$s2] - 4 | 0;
              var $173 = FUNCTION_TABLE[$166]($163, $26, HEAP32[$6$s2] - 1 | 0, $170, $27, $170);
              if (!(($173 | 0) != 0 & $173 >>> 0 < $170 >>> 0)) {
                var $shouldCompress_0 = 0;
                break;
              }
              HEAP16[$4$s1] = HEAP16[$4$s1] | 16384;
              var $shouldCompress_0 = $173;
            }
          } while (0);
          var $shouldCompress_0;
          var $180$s1 = ($currentPeer_0 + 12 | 0) >> 1;
          if ((HEAP16[$180$s1] & 65535) < 4095) {
            HEAP16[$4$s1] = (HEAP8[$currentPeer_0 + 20 | 0] & 255) << 12 | HEAP16[$4$s1];
          }
          HEAP16[$headerData1_sub >> 1] = _htons(HEAP16[$4$s1] | HEAP16[$180$s1]);
          if ((HEAP32[$17 >> 2] | 0) != 0) {
            var $200 = $tmpcast + HEAP32[$24$s2] | 0;
            if ((HEAP16[$180$s1] & 65535) < 4095) {
              var $207 = HEAP32[$currentPeer_0$s2 + 4];
            } else {
              var $207 = 0;
            }
            var $207;
            HEAP32[$200 >> 2] = $207;
            HEAP32[$24$s2] = HEAP32[$24$s2] + 4 | 0;
            HEAP32[$200 >> 2] = FUNCTION_TABLE[HEAP32[$17 >> 2]]($12, HEAP32[$6$s2]);
          }
          if (($shouldCompress_0 | 0) != 0) {
            HEAP32[$22 >> 2] = $21;
            HEAP32[$23 >> 2] = $shouldCompress_0;
            HEAP32[$6$s2] = 2;
          }
          HEAP32[$currentPeer_0$s2 + 18] = HEAP32[$10$s2];
          var $222 = _enet_socket_send(HEAP32[$18 >> 2], $currentPeer_0 + 24 | 0, $12, HEAP32[$6$s2]);
          _enet_protocol_remove_sent_unreliable_commands($currentPeer_0);
          if (($222 | 0) < 0) {
            var $_0 = -1;
            label = 747;
            break L899;
          }
          HEAP32[$19 >> 2] = HEAP32[$19 >> 2] + $222 | 0;
          HEAP32[$20 >> 2] = HEAP32[$20 >> 2] + 1 | 0;
        }
      } while (0);
      var $currentPeer_0 = $currentPeer_0 + 380 | 0, $currentPeer_0$s2 = $currentPeer_0 >> 2;
    }
    if ((HEAP32[$1$s2] | 0) == 0) {
      var $_0 = 0;
      label = 746;
      break;
    }
  }
  if (label == 746) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 747) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 748) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
}
_enet_protocol_send_outgoing_commands["X"] = 1;
function _enet_host_check_events($host, $event) {
  if (($event | 0) == 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  HEAP32[$event >> 2] = 0;
  HEAP32[$event + 4 >> 2] = 0;
  HEAP32[$event + 16 >> 2] = 0;
  var $_0 = _enet_protocol_dispatch_incoming_commands($host, $event);
  var $_0;
  return $_0;
}
function _enet_protocol_dispatch_incoming_commands($host, $event) {
  var $event$s2 = $event >> 2;
  var label;
  var $1 = $host + 52 | 0;
  var $2 = $1 | 0;
  var $3 = $event + 8 | 0;
  var $4 = $event + 16 | 0;
  while (1) {
    var $5 = HEAP32[$2 >> 2];
    if (($5 | 0) == ($1 | 0)) {
      var $_0 = 0;
      label = 764;
      break;
    }
    var $8 = _enet_list_remove($5);
    var $9 = $8;
    var $11 = $8 + 240 | 0;
    HEAP32[$11 >> 2] = 0;
    var $13 = $8 + 36 | 0;
    var $14 = HEAP32[$13 >> 2];
    if (($14 | 0) == 9) {
      label = 758;
      break;
    } else if (($14 | 0) == 3 || ($14 | 0) == 4) {
      label = 757;
      break;
    } else if (($14 | 0) != 5) {
      continue;
    }
    var $31 = $8 + 232 | 0;
    var $32 = $31;
    var $33 = $31;
    if ((HEAP32[$33 >> 2] | 0) == ($32 | 0)) {
      continue;
    }
    var $37 = _enet_peer_receive($9, $3);
    HEAP32[$4 >> 2] = $37;
    if (($37 | 0) != 0) {
      label = 761;
      break;
    }
  }
  if (label == 758) {
    HEAP32[$host + 32 >> 2] = 1;
    HEAP32[$event$s2] = 2;
    HEAP32[$event$s2 + 1] = $9;
    HEAP32[$event$s2 + 3] = HEAP32[$8 + 376 >> 2];
    _enet_peer_reset($9);
    var $_0 = 1;
    var $_0;
    return $_0;
  } else if (label == 764) {
    var $_0;
    return $_0;
  } else if (label == 757) {
    HEAP32[$13 >> 2] = 5;
    HEAP32[$event$s2] = 1;
    HEAP32[$event$s2 + 1] = $9;
    HEAP32[$event$s2 + 3] = HEAP32[$8 + 376 >> 2];
    var $_0 = 1;
    var $_0;
    return $_0;
  } else if (label == 761) {
    HEAP32[$event$s2] = 3;
    HEAP32[$event$s2 + 1] = $9;
    if ((HEAP32[$33 >> 2] | 0) == ($32 | 0)) {
      var $_0 = 1;
      var $_0;
      return $_0;
    }
    HEAP32[$11 >> 2] = 1;
    _enet_list_insert($1, $8);
    var $_0 = 1;
    var $_0;
    return $_0;
  }
}
_enet_protocol_dispatch_incoming_commands["X"] = 1;
function _enet_host_service($host, $event, $timeout) {
  var $10$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 4;
  var label;
  var $waitCondition = __stackBase__;
  var $1 = ($event | 0) != 0;
  do {
    if ($1) {
      HEAP32[$event >> 2] = 0;
      HEAP32[$event + 4 >> 2] = 0;
      HEAP32[$event + 16 >> 2] = 0;
      var $6 = _enet_protocol_dispatch_incoming_commands($host, $event);
      if (($6 | 0) == 1) {
        var $_0 = 1;
        break;
      } else if (($6 | 0) != -1) {
        label = 772;
        break;
      }
      _perror(__str | 0);
      var $_0 = -1;
      break;
    } else {
      label = 772;
    }
  } while (0);
  L992 : do {
    if (label == 772) {
      var $9 = _enet_time_get();
      var $10$s2 = ($host + 48 | 0) >> 2;
      HEAP32[$10$s2] = $9;
      var $11 = $9 + $timeout | 0;
      var $12 = $host + 20 | 0;
      var $13 = $host | 0;
      while (1) {
        var $15 = HEAP32[$10$s2];
        var $16 = HEAP32[$12 >> 2];
        var $17 = $15 - $16 | 0;
        if (($17 >>> 0 > 86399999 ? $16 - $15 | 0 : $17) >>> 0 > 999) {
          _enet_host_bandwidth_throttle($host);
        }
        var $24 = _enet_protocol_send_outgoing_commands($host, $event, 1);
        if (($24 | 0) == 1) {
          var $_0 = 1;
          break L992;
        } else if (($24 | 0) == -1) {
          label = 776;
          break;
        }
        var $27 = _enet_protocol_receive_incoming_commands($host, $event);
        if (($27 | 0) == 1) {
          var $_0 = 1;
          break L992;
        } else if (($27 | 0) == -1) {
          label = 778;
          break;
        }
        var $30 = _enet_protocol_send_outgoing_commands($host, $event, 1);
        if (($30 | 0) == 1) {
          var $_0 = 1;
          break L992;
        } else if (($30 | 0) == -1) {
          label = 780;
          break;
        }
        if ($1) {
          var $34 = _enet_protocol_dispatch_incoming_commands($host, $event);
          if (($34 | 0) == 1) {
            var $_0 = 1;
            break L992;
          } else if (($34 | 0) == -1) {
            label = 783;
            break;
          }
        }
        var $37 = _enet_time_get();
        HEAP32[$10$s2] = $37;
        if (($37 - $11 | 0) >>> 0 <= 86399999) {
          var $_0 = 0;
          break L992;
        }
        HEAP32[$waitCondition >> 2] = 2;
        var $42 = HEAP32[$10$s2];
        var $43 = $11 - $42 | 0;
        if ((_enet_socket_wait(HEAP32[$13 >> 2], $waitCondition, $43 >>> 0 > 86399999 ? $42 - $11 | 0 : $43) | 0) != 0) {
          var $_0 = -1;
          break L992;
        }
        HEAP32[$10$s2] = _enet_time_get();
        if ((HEAP32[$waitCondition >> 2] | 0) != 2) {
          var $_0 = 0;
          break L992;
        }
      }
      if (label == 783) {
        _perror(__str | 0);
        var $_0 = -1;
        break;
      } else if (label == 780) {
        _perror(__str1 | 0);
        var $_0 = -1;
        break;
      } else if (label == 778) {
        _perror(__str2 | 0);
        var $_0 = -1;
        break;
      } else if (label == 776) {
        _perror(__str1 | 0);
        var $_0 = -1;
        break;
      }
    }
  } while (0);
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
_enet_host_service["X"] = 1;
function _enet_protocol_receive_incoming_commands($host, $event) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var label;
  var $buffer = __stackBase__;
  var $1 = $host + 2156 | 0;
  var $2 = $buffer | 0;
  var $3 = $buffer + 4 | 0;
  var $4 = $host | 0;
  var $5 = $host + 10348 | 0;
  var $6 = $host + 10356 | 0;
  var $7 = $host + 10360 | 0;
  var $8 = $host + 10372 | 0;
  var $9 = $host + 10376 | 0;
  var $10 = ($event | 0) == 0;
  while (1) {
    HEAP32[$2 >> 2] = $1;
    HEAP32[$3 >> 2] = 4096;
    var $13 = _enet_socket_receive(HEAP32[$4 >> 2], $5, $buffer, 1);
    if (($13 | 0) < 0) {
      var $_0 = -1;
      label = 796;
      break;
    }
    if (($13 | 0) == 0) {
      var $_0 = 0;
      label = 798;
      break;
    }
    HEAP32[$6 >> 2] = $1;
    HEAP32[$7 >> 2] = $13;
    HEAP32[$8 >> 2] = HEAP32[$8 >> 2] + $13 | 0;
    HEAP32[$9 >> 2] = HEAP32[$9 >> 2] + 1 | 0;
    if ((_enet_packet_filter($host) | 0) == 0) {
      var $_0 = 0;
      label = 799;
      break;
    }
    var $25 = _enet_protocol_handle_incoming_commands($host, $event);
    if (($25 | 0) == 1 || ($25 | 0) == -1) {
      var $_0 = $25;
      label = 797;
      break;
    }
    if (!$10) {
      label = 794;
      break;
    }
  }
  if (label == 796) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 797) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 794) {
    HEAP32[$event >> 2] = 100;
    HEAP32[$event + 12 >> 2] = 0;
    HEAP32[$event + 16 >> 2] = _enet_packet_create(HEAP32[$6 >> 2], HEAP32[$7 >> 2], 4);
    var $_0 = 1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 799) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else if (label == 798) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
}
function _enet_protocol_handle_incoming_commands($host, $event) {
  var $18$s2;
  var $5$s2;
  var $1$s2;
  var $currentData$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 12;
  var label;
  var $currentData = __stackBase__, $currentData$s2 = $currentData >> 2;
  var $buffer = __stackBase__ + 4;
  var $1$s2 = ($host + 10360 | 0) >> 2;
  if (HEAP32[$1$s2] >>> 0 < 2) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $5$s2 = ($host + 10356 | 0) >> 2;
  var $6 = HEAP32[$5$s2];
  var $7 = $6;
  var $9 = _ntohs((tempInt = HEAPU8[$7] | HEAPU8[$7 + 1] << 8, tempInt << 16 >> 16));
  var $11 = ($9 & 65535) >>> 12 & 65535 & 3;
  var $13 = $9 & 4095;
  var $14 = $9 & -16384 & 65535;
  var $15 = $14 & 32768;
  var $16 = ($15 | 0) == 0;
  var $18$s2 = ($host + 2136 | 0) >> 2;
  var $headerSize_0 = ($15 >>> 14) + ((HEAP32[$18$s2] | 0) == 0 ? 2 : 6) | 0;
  var $21 = $13 & 65535;
  do {
    if ($13 << 16 >> 16 == 4095) {
      var $peer_0 = 0;
    } else {
      if ($21 >>> 0 >= HEAP32[$host + 40 >> 2] >>> 0) {
        var $_0 = 0;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      var $29 = HEAP32[$host + 36 >> 2];
      var $30 = $29 + $21 * 380 | 0;
      var $32 = HEAP32[($29 + 36 >> 2) + ($21 * 95 | 0)];
      if (($32 | 0) == 0 || ($32 | 0) == 9) {
        var $_0 = 0;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      var $36 = $29 + $21 * 380 + 24 | 0;
      var $37 = HEAP32[$36 >> 2];
      do {
        if ((HEAP32[$host + 10348 >> 2] | 0) == ($37 | 0)) {
          if (HEAP16[$host + 10352 >> 1] << 16 >> 16 == HEAP16[($29 + 28 >> 1) + ($21 * 190 | 0)] << 16 >> 16) {
            break;
          }
          var $46 = HEAP32[$36 >> 2];
          label = 808;
          break;
        } else {
          var $46 = $37;
          label = 808;
        }
      } while (0);
      do {
        if (label == 808) {
          var $46;
          if (($46 | 0) == -1) {
            break;
          } else {
            var $_0 = 0;
          }
          var $_0;
          STACKTOP = __stackBase__;
          return $_0;
        }
      } while (0);
      if ((HEAP16[($29 + 12 >> 1) + ($21 * 190 | 0)] & 65535) >= 4095) {
        var $peer_0 = $30;
        break;
      }
      if (($11 | 0) == (HEAP8[$29 + $21 * 380 + 21 | 0] & 255 | 0)) {
        var $peer_0 = $30;
        break;
      } else {
        var $_0 = 0;
      }
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    }
  } while (0);
  var $peer_0;
  do {
    if (($14 & 16384 | 0) != 0) {
      var $62 = HEAP32[$host + 2140 >> 2];
      if (($62 | 0) == 0) {
        var $_0 = 0;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      var $66 = HEAP32[$host + 2148 >> 2];
      if (($66 | 0) == 0) {
        var $_0 = 0;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      var $73 = $host + 6252 | 0;
      var $75 = 4096 - $headerSize_0 | 0;
      var $76 = FUNCTION_TABLE[$66]($62, HEAP32[$5$s2] + $headerSize_0 | 0, HEAP32[$1$s2] - $headerSize_0 | 0, $host + ($headerSize_0 + 6252) | 0, $75);
      if (($76 | 0) == 0 | $76 >>> 0 > $75 >>> 0) {
        var $_0 = 0;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      } else {
        _memcpy($73, $6, $headerSize_0, 1);
        HEAP32[$5$s2] = $73;
        HEAP32[$1$s2] = $76 + $headerSize_0 | 0;
        break;
      }
    }
  } while (0);
  do {
    if ((HEAP32[$18$s2] | 0) != 0) {
      var $88 = HEAP32[$5$s2] + ($headerSize_0 - 4) | 0;
      var $89 = HEAP32[$88 >> 2];
      if (($peer_0 | 0) == 0) {
        var $95 = 0;
      } else {
        var $95 = HEAP32[$peer_0 + 16 >> 2];
      }
      var $95;
      HEAP32[$88 >> 2] = $95;
      HEAP32[$buffer >> 2] = HEAP32[$5$s2];
      HEAP32[$buffer + 4 >> 2] = HEAP32[$1$s2];
      if ((FUNCTION_TABLE[HEAP32[$18$s2]]($buffer, 1) | 0) == ($89 | 0)) {
        break;
      } else {
        var $_0 = 0;
      }
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    }
  } while (0);
  if (($peer_0 | 0) != 0) {
    HEAP32[$peer_0 + 24 >> 2] = HEAP32[$host + 10348 >> 2];
    HEAP16[$peer_0 + 28 >> 1] = HEAP16[$host + 10352 >> 1];
    var $113 = $peer_0 + 64 | 0;
    HEAP32[$113 >> 2] = HEAP32[$113 >> 2] + HEAP32[$1$s2] | 0;
  }
  HEAP32[$currentData$s2] = HEAP32[$5$s2] + $headerSize_0 | 0;
  var $120 = $6 + 2 | 0;
  var $peer_1 = $peer_0;
  L1071 : while (1) {
    var $peer_1;
    var $121 = HEAP32[$currentData$s2];
    var $124 = HEAP32[$5$s2] + HEAP32[$1$s2] | 0;
    if ($121 >>> 0 >= $124 >>> 0) {
      break;
    }
    var $127 = $121;
    if (($121 + 4 | 0) >>> 0 > $124 >>> 0) {
      break;
    }
    var $132 = HEAP8[$121] & 15;
    if (($132 & 255) > 12 | $132 << 24 >> 24 == 0) {
      break;
    }
    var $139 = $121 + HEAP32[_commandSizes + (($132 & 255) << 2) >> 2] | 0;
    if ($139 >>> 0 > $124 >>> 0) {
      break;
    }
    HEAP32[$currentData$s2] = $139;
    if (!(($peer_1 | 0) != 0 | $132 << 24 >> 24 == 2)) {
      break;
    }
    var $146 = $121 + 2 | 0;
    tempBigInt = _ntohs((tempInt = HEAPU8[$146] | HEAPU8[$146 + 1] << 8, tempInt << 16 >> 16));
    HEAP8[$146] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$146 + 1] = tempBigInt & 255;
    var $151 = HEAP8[$121] & 255 & 15;
    do {
      if (($151 | 0) == 9) {
        if ((_enet_protocol_handle_send_unsequenced($host, $peer_1, $127, $currentData) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 7) {
        if ((_enet_protocol_handle_send_unreliable($host, $peer_1, $127, $currentData) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 1) {
        if ((_enet_protocol_handle_acknowledge($host, $event, $peer_1, $127) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 2) {
        var $156 = _enet_protocol_handle_connect($host, $127);
        if (($156 | 0) == 0) {
          break L1071;
        } else {
          var $peer_23 = $156;
          break;
        }
      } else if (($151 | 0) == 8) {
        if ((_enet_protocol_handle_send_fragment($host, $peer_1, $127, $currentData) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 4) {
        _enet_protocol_handle_disconnect($host, $peer_1, $127);
        label = 840;
        break;
      } else if (($151 | 0) == 6) {
        if ((_enet_protocol_handle_send_reliable($host, $peer_1, $127, $currentData) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 11) {
        _enet_protocol_handle_throttle_configure($peer_1, $127);
        label = 840;
        break;
      } else if (($151 | 0) == 12) {
        if ((_enet_protocol_handle_send_unreliable_fragment($host, $peer_1, $127, $currentData) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 5) {
        label = 840;
      } else if (($151 | 0) == 3) {
        if ((_enet_protocol_handle_verify_connect($host, $event, $peer_1, $127) | 0) == 0) {
          label = 840;
          break;
        } else {
          break L1071;
        }
      } else if (($151 | 0) == 10) {
        _enet_protocol_handle_bandwidth_limit($host, $peer_1, $127);
        label = 840;
        break;
      } else {
        break L1071;
      }
    } while (0);
    if (label == 840) {
      label = 0;
      if (($peer_1 | 0) == 0) {
        var $peer_1 = 0;
        continue;
      } else {
        var $peer_23 = $peer_1;
      }
    }
    var $peer_23;
    var $181 = HEAP8[$121];
    if ($181 << 24 >> 24 >= 0) {
      var $peer_1 = $peer_23;
      continue;
    }
    if ($16) {
      break;
    }
    var $186 = _ntohs((tempInt = HEAPU8[$120] | HEAPU8[$120 + 1] << 8, tempInt << 16 >> 16));
    var $188 = HEAP32[$peer_23 + 36 >> 2];
    if (($188 | 0) == 7 || ($188 | 0) == 2) {
      var $peer_1 = $peer_23;
      continue;
    } else if (($188 | 0) != 8) {
      _enet_peer_queue_acknowledgement($peer_23, $127, $186);
      var $peer_1 = $peer_23;
      continue;
    }
    if (($181 & 15) << 24 >> 24 != 4) {
      var $peer_1 = $peer_23;
      continue;
    }
    _enet_peer_queue_acknowledgement($peer_23, $127, $186);
    var $peer_1 = $peer_23;
  }
  do {
    if (($event | 0) != 0) {
      if ((HEAP32[$event >> 2] | 0) == 0) {
        break;
      } else {
        var $_0 = 1;
      }
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    }
  } while (0);
  var $_0 = 0;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
_enet_protocol_handle_incoming_commands["X"] = 1;
function _enet_protocol_handle_acknowledge($host, $event, $peer, $command) {
  var $56$s2;
  var $50$s2;
  var $29$s2;
  var $25$s2;
  var $6$s2;
  var $peer$s2 = $peer >> 2;
  var label;
  var $2 = $command + 6 | 0;
  var $5 = _ntohs((tempInt = HEAPU8[$2] | HEAPU8[$2 + 1] << 8, tempInt << 16 >> 16)) & 65535;
  var $6$s2 = ($host + 48 | 0) >> 2;
  var $7 = HEAP32[$6$s2];
  var $9 = $7 & -65536 | $5;
  var $receivedSentTime_0 = ($5 & 32768) >>> 0 > ($7 & 32768) >>> 0 ? $9 - 65536 | 0 : $9;
  if (($7 - $receivedSentTime_0 | 0) >>> 0 > 86399999) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  HEAP32[$peer$s2 + 19] = $7;
  HEAP32[$peer$s2 + 21] = 0;
  var $19 = HEAP32[$6$s2];
  var $20 = $19 - $receivedSentTime_0 | 0;
  var $23 = $20 >>> 0 > 86399999 ? $receivedSentTime_0 - $19 | 0 : $20;
  _enet_peer_throttle($peer, $23);
  var $25$s2 = ($peer + 172 | 0) >> 2;
  var $26 = HEAP32[$25$s2];
  HEAP32[$25$s2] = $26 - ($26 >>> 2) | 0;
  var $29$s2 = ($peer + 168 | 0) >> 2;
  var $30 = HEAP32[$29$s2];
  if ($23 >>> 0 < $30 >>> 0) {
    var $43 = $30 - (($30 - $23 | 0) >>> 3) | 0;
    HEAP32[$29$s2] = $43;
    var $storemerge = HEAP32[$25$s2] + (($43 - $23 | 0) >>> 2) | 0;
  } else {
    var $35 = (($23 - $30 | 0) >>> 3) + $30 | 0;
    HEAP32[$29$s2] = $35;
    var $storemerge = HEAP32[$25$s2] + (($23 - $35 | 0) >>> 2) | 0;
  }
  var $storemerge;
  HEAP32[$25$s2] = $storemerge;
  var $49 = HEAP32[$29$s2];
  var $50$s2 = ($peer + 156 | 0) >> 2;
  if ($49 >>> 0 < HEAP32[$50$s2] >>> 0) {
    HEAP32[$50$s2] = $49;
  }
  var $55 = HEAP32[$25$s2];
  var $56$s2 = ($peer + 164 | 0) >> 2;
  if ($55 >>> 0 > HEAP32[$56$s2] >>> 0) {
    HEAP32[$56$s2] = $55;
  }
  var $61 = $peer + 120 | 0;
  var $62 = HEAP32[$61 >> 2];
  do {
    if (($62 | 0) == 0) {
      label = 872;
    } else {
      var $65 = HEAP32[$6$s2];
      var $66 = $65 - $62 | 0;
      if (($66 >>> 0 > 86399999 ? $62 - $65 | 0 : $66) >>> 0 < HEAP32[$peer$s2 + 33] >>> 0) {
        break;
      } else {
        label = 872;
        break;
      }
    }
  } while (0);
  if (label == 872) {
    HEAP32[$peer$s2 + 38] = HEAP32[$50$s2];
    HEAP32[$peer$s2 + 40] = HEAP32[$56$s2];
    HEAP32[$50$s2] = HEAP32[$29$s2];
    HEAP32[$56$s2] = HEAP32[$25$s2];
    HEAP32[$61 >> 2] = HEAP32[$6$s2];
  }
  var $82 = $command + 4 | 0;
  var $87 = _enet_protocol_remove_sent_reliable_command($peer, _ntohs((tempInt = HEAPU8[$82] | HEAPU8[$82 + 1] << 8, tempInt << 16 >> 16)), HEAP8[$command + 1 | 0]);
  var $89 = HEAP32[$peer$s2 + 9];
  if (($89 | 0) == 7) {
    if (($87 | 0) != 4) {
      var $_0 = -1;
      var $_0;
      return $_0;
    }
    _enet_protocol_notify_disconnect($host, $peer, $event);
    var $_0 = 0;
    var $_0;
    return $_0;
  } else if (($89 | 0) == 6) {
    var $97 = $peer + 216 | 0;
    if ((HEAP32[$97 >> 2] | 0) != ($97 | 0)) {
      var $_0 = 0;
      var $_0;
      return $_0;
    }
    var $102 = $peer + 224 | 0;
    if ((HEAP32[$102 >> 2] | 0) != ($102 | 0)) {
      var $_0 = 0;
      var $_0;
      return $_0;
    }
    var $107 = $peer + 200 | 0;
    if ((HEAP32[$107 >> 2] | 0) != ($107 | 0)) {
      var $_0 = 0;
      var $_0;
      return $_0;
    }
    _enet_peer_disconnect($peer, HEAP32[$peer$s2 + 94]);
    var $_0 = 0;
    var $_0;
    return $_0;
  } else if (($89 | 0) == 2) {
    if (($87 | 0) != 3) {
      var $_0 = -1;
      var $_0;
      return $_0;
    }
    _enet_protocol_notify_connect($host, $peer, $event);
    var $_0 = 0;
    var $_0;
    return $_0;
  } else {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
}
_enet_protocol_handle_acknowledge["X"] = 1;
function _enet_protocol_handle_connect($host, $command) {
  var $182$s2;
  var $156$s2;
  var $channel_05$s1;
  var $80$s2;
  var $60$s2;
  var $9$s2;
  var $7$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var label;
  var $verifyCommand = __stackBase__;
  var $1 = $command + 16 | 0;
  var $3 = _ntohl(HEAPU8[$1] | HEAPU8[$1 + 1] << 8 | HEAPU8[$1 + 2] << 16 | HEAPU8[$1 + 3] << 24 | 0);
  if (($3 | 0) == 0 | $3 >>> 0 > 255) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $7$s2 = ($host + 36 | 0) >> 2;
  var $8 = HEAP32[$7$s2];
  var $9$s2 = ($host + 40 | 0) >> 2;
  var $11 = $8 + HEAP32[$9$s2] * 380 | 0;
  var $12 = $host + 10348 | 0;
  var $13 = $host + 10352 | 0;
  var $14 = $command + 40 | 0;
  var $currentPeer_0 = $8;
  L1151 : while (1) {
    var $currentPeer_0;
    if ($currentPeer_0 >>> 0 >= $11 >>> 0) {
      break;
    }
    do {
      if ((HEAP32[$currentPeer_0 + 36 >> 2] | 0) != 0) {
        if ((HEAP32[$currentPeer_0 + 24 >> 2] | 0) != (HEAP32[$12 >> 2] | 0)) {
          break;
        }
        if (HEAP16[$currentPeer_0 + 28 >> 1] << 16 >> 16 != HEAP16[$13 >> 1] << 16 >> 16) {
          break;
        }
        if ((HEAP32[$currentPeer_0 + 16 >> 2] | 0) == (HEAPU8[$14] | HEAPU8[$14 + 1] << 8 | HEAPU8[$14 + 2] << 16 | HEAPU8[$14 + 3] << 24 | 0)) {
          var $_0 = 0;
          label = 936;
          break L1151;
        }
      }
    } while (0);
    var $currentPeer_0 = $currentPeer_0 + 380 | 0;
  }
  if (label == 936) {
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $19 = HEAP32[$7$s2] + HEAP32[$9$s2] * 380 | 0;
  var $currentPeer_1 = $8;
  while (1) {
    var $currentPeer_1;
    if ($currentPeer_1 >>> 0 >= $19 >>> 0) {
      break;
    }
    if ((HEAP32[$currentPeer_1 + 36 >> 2] | 0) == 0) {
      break;
    } else {
      var $currentPeer_1 = $currentPeer_1 + 380 | 0;
    }
  }
  if ($currentPeer_1 >>> 0 >= (HEAP32[$7$s2] + HEAP32[$9$s2] * 380 | 0) >>> 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $55 = HEAP32[$host + 44 >> 2];
  var $_ = $3 >>> 0 > $55 >>> 0 ? $55 : $3;
  var $58 = _enet_malloc($_ * 60 | 0);
  var $60$s2 = ($currentPeer_1 + 40 | 0) >> 2;
  HEAP32[$60$s2] = $58;
  if (($58 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  HEAP32[$currentPeer_1 + 44 >> 2] = $_;
  HEAP32[$currentPeer_1 + 36 >> 2] = 2;
  var $65 = $command + 40 | 0;
  var $67 = $currentPeer_1 + 16 | 0;
  HEAP32[$67 >> 2] = HEAPU8[$65] | HEAPU8[$65 + 1] << 8 | HEAPU8[$65 + 2] << 16 | HEAPU8[$65 + 3] << 24 | 0;
  var $70 = $host + 10348 | 0;
  var $71 = $currentPeer_1 + 24 | 0;
  var $72$1 = HEAP32[$70 + 4 >> 2];
  HEAP32[$71 >> 2] = HEAP32[$70 >> 2];
  HEAP32[$71 + 4 >> 2] = $72$1;
  var $73 = $command + 4 | 0;
  HEAP16[$currentPeer_1 + 12 >> 1] = _ntohs((tempInt = HEAPU8[$73] | HEAPU8[$73 + 1] << 8, tempInt << 16 >> 16));
  var $77 = $command + 20 | 0;
  var $80$s2 = ($currentPeer_1 + 48 | 0) >> 2;
  HEAP32[$80$s2] = _ntohl(HEAPU8[$77] | HEAPU8[$77 + 1] << 8 | HEAPU8[$77 + 2] << 16 | HEAPU8[$77 + 3] << 24 | 0);
  var $81 = $command + 24 | 0;
  HEAP32[$currentPeer_1 + 52 >> 2] = _ntohl(HEAPU8[$81] | HEAPU8[$81 + 1] << 8 | HEAPU8[$81 + 2] << 16 | HEAPU8[$81 + 3] << 24 | 0);
  var $85 = $command + 28 | 0;
  var $88 = $currentPeer_1 + 132 | 0;
  HEAP32[$88 >> 2] = _ntohl(HEAPU8[$85] | HEAPU8[$85 + 1] << 8 | HEAPU8[$85 + 2] << 16 | HEAPU8[$85 + 3] << 24 | 0);
  var $89 = $command + 32 | 0;
  var $92 = $currentPeer_1 + 124 | 0;
  HEAP32[$92 >> 2] = _ntohl(HEAPU8[$89] | HEAPU8[$89 + 1] << 8 | HEAPU8[$89 + 2] << 16 | HEAPU8[$89 + 3] << 24 | 0);
  var $93 = $command + 36 | 0;
  var $96 = $currentPeer_1 + 128 | 0;
  HEAP32[$96 >> 2] = _ntohl(HEAPU8[$93] | HEAPU8[$93 + 1] << 8 | HEAPU8[$93 + 2] << 16 | HEAPU8[$93 + 3] << 24 | 0);
  var $97 = $command + 44 | 0;
  HEAP32[$currentPeer_1 + 376 >> 2] = _ntohl(HEAPU8[$97] | HEAPU8[$97 + 1] << 8 | HEAPU8[$97 + 2] << 16 | HEAPU8[$97 + 3] << 24 | 0);
  var $102 = HEAP8[$command + 6 | 0];
  if ($102 << 24 >> 24 == -1) {
    var $_in = HEAP8[$currentPeer_1 + 20 | 0];
  } else {
    var $_in = $102;
  }
  var $_in;
  var $109 = $_in + 1 & 255 & 3;
  var $110 = $currentPeer_1 + 20 | 0;
  if ($109 << 24 >> 24 == HEAP8[$110] << 24 >> 24) {
    var $incomingSessionID_0 = $_in + 2 & 255 & 3;
  } else {
    var $incomingSessionID_0 = $109;
  }
  var $incomingSessionID_0;
  HEAP8[$110] = $incomingSessionID_0;
  var $118 = HEAP8[$command + 7 | 0];
  if ($118 << 24 >> 24 == -1) {
    var $_in1 = HEAP8[$currentPeer_1 + 21 | 0];
  } else {
    var $_in1 = $118;
  }
  var $_in1;
  var $125 = $_in1 + 1 & 255 & 3;
  var $126 = $currentPeer_1 + 21 | 0;
  if ($125 << 24 >> 24 == HEAP8[$126] << 24 >> 24) {
    var $outgoingSessionID_0 = $_in1 + 2 & 255 & 3;
  } else {
    var $outgoingSessionID_0 = $125;
  }
  var $outgoingSessionID_0;
  HEAP8[$126] = $outgoingSessionID_0;
  var $133 = ($_ | 0) > 0;
  L1184 : do {
    if ($133) {
      var $channel_05 = HEAP32[$60$s2], $channel_05$s1 = $channel_05 >> 1;
      while (1) {
        var $channel_05;
        HEAP16[$channel_05$s1] = 0;
        HEAP16[$channel_05$s1 + 1] = 0;
        HEAP16[$channel_05$s1 + 19] = 0;
        HEAP16[$channel_05$s1 + 20] = 0;
        _enet_list_clear($channel_05 + 44 | 0);
        _enet_list_clear($channel_05 + 52 | 0);
        var $143 = $channel_05 + 60 | 0;
        _memset($channel_05 + 4 | 0, 0, 34, 2);
        if ($143 >>> 0 < (HEAP32[$60$s2] + $_ * 60 | 0) >>> 0) {
          var $channel_05 = $143, $channel_05$s1 = $channel_05 >> 1;
        } else {
          break L1184;
        }
      }
    }
  } while (0);
  var $148 = $command + 8 | 0;
  var $150 = _ntohl(HEAPU8[$148] | HEAPU8[$148 + 1] << 8 | HEAPU8[$148 + 2] << 16 | HEAPU8[$148 + 3] << 24 | 0);
  if ($150 >>> 0 < 576) {
    var $mtu_0 = 576;
  } else {
    var $mtu_0 = $150 >>> 0 > 4096 ? 4096 : $150;
  }
  var $mtu_0;
  var $155 = $currentPeer_1 + 176 | 0;
  HEAP32[$155 >> 2] = $mtu_0;
  var $156$s2 = ($host + 16 | 0) >> 2;
  var $157 = HEAP32[$156$s2];
  do {
    if (($157 | 0) == 0) {
      if ((HEAP32[$80$s2] | 0) == 0) {
        HEAP32[$currentPeer_1 + 180 >> 2] = 32768;
        break;
      } else {
        var $_pr = HEAP32[$156$s2];
        if (($_pr | 0) == 0) {
          label = 924;
          break;
        } else {
          var $166 = $_pr;
          label = 923;
          break;
        }
      }
    } else {
      var $166 = $157;
      label = 923;
    }
  } while (0);
  do {
    if (label == 923) {
      var $166;
      var $167 = HEAP32[$80$s2];
      if (($167 | 0) == 0) {
        label = 924;
        break;
      }
      HEAP32[$currentPeer_1 + 180 >> 2] = ($166 >>> 0 < $167 >>> 0 ? $166 : $167) >>> 4 & 268431360;
      break;
    }
  } while (0);
  if (label == 924) {
    var $170 = HEAP32[$156$s2];
    var $171 = HEAP32[$80$s2];
    HEAP32[$currentPeer_1 + 180 >> 2] = ($170 >>> 0 > $171 >>> 0 ? $170 : $171) >>> 4 & 268431360;
  }
  var $182$s2 = ($currentPeer_1 + 180 | 0) >> 2;
  var $183 = HEAP32[$182$s2];
  do {
    if ($183 >>> 0 < 4096) {
      HEAP32[$182$s2] = 4096;
    } else {
      if ($183 >>> 0 <= 32768) {
        break;
      }
      HEAP32[$182$s2] = 32768;
    }
  } while (0);
  var $190 = $host + 12 | 0;
  var $191 = HEAP32[$190 >> 2];
  if (($191 | 0) == 0) {
    var $windowSize_0 = 32768;
  } else {
    var $windowSize_0 = $191 >>> 4 & 268431360;
  }
  var $windowSize_0;
  var $197 = $command + 12 | 0;
  var $199 = _ntohl(HEAPU8[$197] | HEAPU8[$197 + 1] << 8 | HEAPU8[$197 + 2] << 16 | HEAPU8[$197 + 3] << 24 | 0);
  var $_windowSize_0 = $windowSize_0 >>> 0 > $199 >>> 0 ? $199 : $windowSize_0;
  if ($_windowSize_0 >>> 0 < 4096) {
    var $windowSize_2 = 4096;
  } else {
    var $windowSize_2 = $_windowSize_0 >>> 0 > 32768 ? 32768 : $_windowSize_0;
  }
  var $windowSize_2;
  HEAP8[$verifyCommand | 0] = -125;
  HEAP8[$verifyCommand + 1 | 0] = -1;
  var $210 = $verifyCommand + 4 | 0;
  tempBigInt = _htons(HEAP16[$currentPeer_1 + 14 >> 1]);
  HEAP8[$210] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$210 + 1] = tempBigInt & 255;
  HEAP8[$verifyCommand + 6 | 0] = $incomingSessionID_0;
  HEAP8[$verifyCommand + 7 | 0] = $outgoingSessionID_0;
  var $215 = $verifyCommand + 8 | 0;
  tempBigInt = _htonl(HEAP32[$155 >> 2]);
  HEAP8[$215] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$215 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$215 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$215 + 3] = tempBigInt & 255;
  var $217 = $verifyCommand + 12 | 0;
  tempBigInt = _htonl($windowSize_2);
  HEAP8[$217] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$217 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$217 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$217 + 3] = tempBigInt & 255;
  var $219 = $verifyCommand + 16 | 0;
  tempBigInt = _htonl($_);
  HEAP8[$219] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$219 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$219 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$219 + 3] = tempBigInt & 255;
  var $222 = $verifyCommand + 20 | 0;
  tempBigInt = _htonl(HEAP32[$190 >> 2]);
  HEAP8[$222] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$222 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$222 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$222 + 3] = tempBigInt & 255;
  var $225 = $verifyCommand + 24 | 0;
  tempBigInt = _htonl(HEAP32[$156$s2]);
  HEAP8[$225] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$225 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$225 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$225 + 3] = tempBigInt & 255;
  var $228 = $verifyCommand + 28 | 0;
  tempBigInt = _htonl(HEAP32[$88 >> 2]);
  HEAP8[$228] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$228 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$228 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$228 + 3] = tempBigInt & 255;
  var $231 = $verifyCommand + 32 | 0;
  tempBigInt = _htonl(HEAP32[$92 >> 2]);
  HEAP8[$231] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$231 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$231 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$231 + 3] = tempBigInt & 255;
  var $234 = $verifyCommand + 36 | 0;
  tempBigInt = _htonl(HEAP32[$96 >> 2]);
  HEAP8[$234] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$234 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$234 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$234 + 3] = tempBigInt & 255;
  var $236 = $verifyCommand + 40 | 0;
  tempBigInt = HEAP32[$67 >> 2];
  HEAP8[$236] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$236 + 1] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$236 + 2] = tempBigInt & 255;
  tempBigInt >>= 8;
  HEAP8[$236 + 3] = tempBigInt & 255;
  _enet_peer_queue_outgoing_command($currentPeer_1, $verifyCommand, 0, 0, 0);
  var $_0 = $currentPeer_1;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
_enet_protocol_handle_connect["X"] = 1;
function _enet_protocol_handle_ping() {
  return;
}
function _enet_protocol_handle_verify_connect($host, $event, $peer, $command) {
  if ((HEAP32[$peer + 36 >> 2] | 0) != 1) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $5 = $command + 16 | 0;
  var $7 = _ntohl(HEAPU8[$5] | HEAPU8[$5 + 1] << 8 | HEAPU8[$5 + 2] << 16 | HEAPU8[$5 + 3] << 24 | 0);
  do {
    if (!(($7 | 0) == 0 | $7 >>> 0 > 255)) {
      var $11 = $command + 28 | 0;
      if ((_ntohl(HEAPU8[$11] | HEAPU8[$11 + 1] << 8 | HEAPU8[$11 + 2] << 16 | HEAPU8[$11 + 3] << 24 | 0) | 0) != (HEAP32[$peer + 132 >> 2] | 0)) {
        break;
      }
      var $18 = $command + 32 | 0;
      if ((_ntohl(HEAPU8[$18] | HEAPU8[$18 + 1] << 8 | HEAPU8[$18 + 2] << 16 | HEAPU8[$18 + 3] << 24 | 0) | 0) != (HEAP32[$peer + 124 >> 2] | 0)) {
        break;
      }
      var $25 = $command + 36 | 0;
      if ((_ntohl(HEAPU8[$25] | HEAPU8[$25 + 1] << 8 | HEAPU8[$25 + 2] << 16 | HEAPU8[$25 + 3] << 24 | 0) | 0) != (HEAP32[$peer + 128 >> 2] | 0)) {
        break;
      }
      var $32 = $command + 40 | 0;
      if ((HEAPU8[$32] | HEAPU8[$32 + 1] << 8 | HEAPU8[$32 + 2] << 16 | HEAPU8[$32 + 3] << 24 | 0) != (HEAP32[$peer + 16 >> 2] | 0)) {
        break;
      }
      _enet_protocol_remove_sent_reliable_command($peer, 1, -1);
      var $41 = $peer + 44 | 0;
      if ($7 >>> 0 < HEAP32[$41 >> 2] >>> 0) {
        HEAP32[$41 >> 2] = $7;
      }
      var $46 = $command + 4 | 0;
      HEAP16[$peer + 12 >> 1] = _ntohs((tempInt = HEAPU8[$46] | HEAPU8[$46 + 1] << 8, tempInt << 16 >> 16));
      HEAP8[$peer + 21 | 0] = HEAP8[$command + 6 | 0];
      HEAP8[$peer + 20 | 0] = HEAP8[$command + 7 | 0];
      var $56 = $command + 8 | 0;
      var $58 = _ntohl(HEAPU8[$56] | HEAPU8[$56 + 1] << 8 | HEAPU8[$56 + 2] << 16 | HEAPU8[$56 + 3] << 24 | 0);
      if ($58 >>> 0 < 576) {
        var $mtu_0 = 576;
      } else {
        var $mtu_0 = $58 >>> 0 > 4096 ? 4096 : $58;
      }
      var $mtu_0;
      var $63 = $peer + 176 | 0;
      if ($mtu_0 >>> 0 < HEAP32[$63 >> 2] >>> 0) {
        HEAP32[$63 >> 2] = $mtu_0;
      }
      var $68 = $command + 12 | 0;
      var $70 = _ntohl(HEAPU8[$68] | HEAPU8[$68 + 1] << 8 | HEAPU8[$68 + 2] << 16 | HEAPU8[$68 + 3] << 24 | 0);
      var $_2 = $70 >>> 0 < 4096 ? 4096 : $70;
      var $windowSize_1 = $_2 >>> 0 > 32768 ? 32768 : $_2;
      var $73 = $peer + 180 | 0;
      if ($windowSize_1 >>> 0 < HEAP32[$73 >> 2] >>> 0) {
        HEAP32[$73 >> 2] = $windowSize_1;
      }
      var $78 = $command + 20 | 0;
      HEAP32[$peer + 48 >> 2] = _ntohl(HEAPU8[$78] | HEAPU8[$78 + 1] << 8 | HEAPU8[$78 + 2] << 16 | HEAPU8[$78 + 3] << 24 | 0);
      var $82 = $command + 24 | 0;
      HEAP32[$peer + 52 >> 2] = _ntohl(HEAPU8[$82] | HEAPU8[$82 + 1] << 8 | HEAPU8[$82 + 2] << 16 | HEAPU8[$82 + 3] << 24 | 0);
      _enet_protocol_notify_connect($host, $peer, $event);
      var $_0 = 0;
      var $_0;
      return $_0;
    }
  } while (0);
  HEAP32[$peer + 376 >> 2] = 0;
  _enet_protocol_dispatch_state($host, $peer, 9);
  var $_0 = -1;
  var $_0;
  return $_0;
}
_enet_protocol_handle_verify_connect["X"] = 1;
function _enet_protocol_handle_disconnect($host, $peer, $command) {
  var $1$s2;
  var label;
  var $1$s2 = ($peer + 36 | 0) >> 2;
  if ((HEAP32[$1$s2] - 8 | 0) >>> 0 < 2) {
    return;
  }
  _enet_peer_reset_queues($peer);
  var $4 = HEAP32[$1$s2];
  do {
    if (($4 | 0) == 5 || ($4 | 0) == 6) {
      if (HEAP8[$command | 0] << 24 >> 24 < 0) {
        HEAP32[$1$s2] = 8;
        break;
      } else {
        _enet_protocol_dispatch_state($host, $peer, 9);
        label = 970;
        break;
      }
    } else if (($4 | 0) == 4 || ($4 | 0) == 7) {
      _enet_protocol_dispatch_state($host, $peer, 9);
      label = 970;
      break;
    } else if (($4 | 0) == 3) {
      HEAP32[$host + 32 >> 2] = 1;
      label = 966;
      break;
    } else {
      label = 966;
    }
  } while (0);
  do {
    if (label == 966) {
      _enet_peer_reset($peer);
      label = 970;
      break;
    }
  } while (0);
  do {
    if (label == 970) {
      if ((HEAP32[$1$s2] | 0) != 0) {
        break;
      }
      return;
    }
  } while (0);
  var $18 = $command + 4 | 0;
  HEAP32[$peer + 376 >> 2] = _ntohl(HEAPU8[$18] | HEAPU8[$18 + 1] << 8 | HEAPU8[$18 + 2] << 16 | HEAPU8[$18 + 3] << 24 | 0);
  return;
}
function _enet_protocol_handle_send_reliable($host, $peer, $command, $currentData) {
  if ((HEAP8[$command + 1 | 0] & 255) >>> 0 >= HEAP32[$peer + 44 >> 2] >>> 0) {
    return -1;
  }
  if ((HEAP32[$peer + 36 >> 2] - 5 | 0) >>> 0 >= 2) {
    return -1;
  }
  var $11 = $command + 4 | 0;
  var $14 = _ntohs((tempInt = HEAPU8[$11] | HEAPU8[$11 + 1] << 8, tempInt << 16 >> 16)) & 65535;
  var $16 = HEAP32[$currentData >> 2] + $14 | 0;
  HEAP32[$currentData >> 2] = $16;
  var $18 = HEAP32[$host + 10356 >> 2];
  if ($16 >>> 0 < $18 >>> 0) {
    return -1;
  }
  if ($16 >>> 0 > ($18 + HEAP32[$host + 10360 >> 2] | 0) >>> 0) {
    return -1;
  }
  var $28 = _enet_packet_create($command + 6 | 0, $14, 1);
  if (($28 | 0) == 0) {
    return -1;
  } else {
    return ((_enet_peer_queue_incoming_command($peer, $command, $28, 0) | 0) == 0) << 31 >> 31;
  }
}
function _enet_protocol_handle_send_unreliable($host, $peer, $command, $currentData) {
  if ((HEAP8[$command + 1 | 0] & 255) >>> 0 >= HEAP32[$peer + 44 >> 2] >>> 0) {
    return -1;
  }
  if ((HEAP32[$peer + 36 >> 2] - 5 | 0) >>> 0 >= 2) {
    return -1;
  }
  var $12 = $command + 6 | 0;
  var $15 = _ntohs((tempInt = HEAPU8[$12] | HEAPU8[$12 + 1] << 8, tempInt << 16 >> 16)) & 65535;
  var $17 = HEAP32[$currentData >> 2] + $15 | 0;
  HEAP32[$currentData >> 2] = $17;
  var $19 = HEAP32[$host + 10356 >> 2];
  if ($17 >>> 0 < $19 >>> 0) {
    return -1;
  }
  if ($17 >>> 0 > ($19 + HEAP32[$host + 10360 >> 2] | 0) >>> 0) {
    return -1;
  }
  var $29 = _enet_packet_create($command + 8 | 0, $15, 0);
  if (($29 | 0) == 0) {
    return -1;
  } else {
    return ((_enet_peer_queue_incoming_command($peer, $command, $29, 0) | 0) == 0) << 31 >> 31;
  }
}
function _enet_protocol_handle_send_unsequenced($host, $peer, $command, $currentData) {
  if ((HEAP8[$command + 1 | 0] & 255) >>> 0 >= HEAP32[$peer + 44 >> 2] >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  if ((HEAP32[$peer + 36 >> 2] - 5 | 0) >>> 0 >= 2) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $12 = $command + 6 | 0;
  var $15 = _ntohs((tempInt = HEAPU8[$12] | HEAPU8[$12 + 1] << 8, tempInt << 16 >> 16)) & 65535;
  var $17 = HEAP32[$currentData >> 2] + $15 | 0;
  HEAP32[$currentData >> 2] = $17;
  var $19 = HEAP32[$host + 10356 >> 2];
  if ($17 >>> 0 < $19 >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  if ($17 >>> 0 > ($19 + HEAP32[$host + 10360 >> 2] | 0) >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $27 = $command + 4 | 0;
  var $29 = _ntohs((tempInt = HEAPU8[$27] | HEAPU8[$27 + 1] << 8, tempInt << 16 >> 16));
  var $30 = $29 & 65535;
  var $31 = $30 & 1023;
  var $32 = $peer + 244 | 0;
  var $33 = HEAP16[$32 >> 1];
  var $unsequencedGroup_0 = ($29 & 65535) < ($33 & 65535) ? $30 | 65536 : $30;
  var $36 = $33 & 65535;
  if ($unsequencedGroup_0 >>> 0 >= ($36 + 32768 | 0) >>> 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $41 = ($unsequencedGroup_0 & 65535) - $31 | 0;
  do {
    if (($41 | 0) == ($36 | 0)) {
      if ((HEAP32[$peer + ($31 >>> 5 << 2) + 248 >> 2] & 1 << ($30 & 31) | 0) == 0) {
        break;
      } else {
        var $_0 = 0;
      }
      var $_0;
      return $_0;
    } else {
      HEAP16[$32 >> 1] = $41 & 65535;
      var $46 = $peer + 248 | 0;
      for (var $$dest = $46 >> 2, $$stop = $$dest + 32; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0;
      }
    }
  } while (0);
  var $58 = _enet_packet_create($command + 8 | 0, $15, 2);
  if (($58 | 0) == 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  if ((_enet_peer_queue_incoming_command($peer, $command, $58, 0) | 0) == 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $67 = ($31 >>> 5 << 2) + $peer + 248 | 0;
  HEAP32[$67 >> 2] = HEAP32[$67 >> 2] | 1 << ($30 & 31);
  var $_0 = 0;
  var $_0;
  return $_0;
}
_enet_protocol_handle_send_unsequenced["X"] = 1;
function _enet_protocol_handle_send_fragment($host, $peer, $command, $currentData) {
  var $124$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 48;
  var label;
  var $hostCommand = __stackBase__;
  var $1 = $command + 1 | 0;
  if ((HEAP8[$1] & 255) >>> 0 >= HEAP32[$peer + 44 >> 2] >>> 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  if ((HEAP32[$peer + 36 >> 2] - 5 | 0) >>> 0 >= 2) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $12 = $command + 6 | 0;
  var $15 = _ntohs((tempInt = HEAPU8[$12] | HEAPU8[$12 + 1] << 8, tempInt << 16 >> 16)) & 65535;
  var $17 = HEAP32[$currentData >> 2] + $15 | 0;
  HEAP32[$currentData >> 2] = $17;
  var $19 = HEAP32[$host + 10356 >> 2];
  if ($17 >>> 0 < $19 >>> 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  if ($17 >>> 0 > ($19 + HEAP32[$host + 10360 >> 2] | 0) >>> 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $28 = HEAP8[$1] & 255;
  var $30 = HEAP32[$peer + 40 >> 2];
  var $31 = $30 + $28 * 60 | 0;
  var $32 = $command + 4 | 0;
  var $34 = _ntohs((tempInt = HEAPU8[$32] | HEAPU8[$32 + 1] << 8, tempInt << 16 >> 16));
  var $35 = ($34 & 65535) >>> 12;
  var $36 = $30 + $28 * 60 + 38 | 0;
  var $37 = HEAP16[$36 >> 1];
  var $38 = ($37 & 65535) >>> 12;
  var $startWindow_0 = ($34 & 65535) < ($37 & 65535) ? $35 | 16 : $35;
  if (($startWindow_0 & 65535) < ($38 & 65535)) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  if (($startWindow_0 & 65535) >>> 0 >= (($38 & 65535) + 7 | 0) >>> 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $48 = $command + 12 | 0;
  var $50 = _ntohl(HEAPU8[$48] | HEAPU8[$48 + 1] << 8 | HEAPU8[$48 + 2] << 16 | HEAPU8[$48 + 3] << 24 | 0);
  var $51 = $command + 8 | 0;
  var $53 = _ntohl(HEAPU8[$51] | HEAPU8[$51 + 1] << 8 | HEAPU8[$51 + 2] << 16 | HEAPU8[$51 + 3] << 24 | 0);
  var $54 = $command + 20 | 0;
  var $56 = _ntohl(HEAPU8[$54] | HEAPU8[$54 + 1] << 8 | HEAPU8[$54 + 2] << 16 | HEAPU8[$54 + 3] << 24 | 0);
  var $57 = $command + 16 | 0;
  var $59 = _ntohl(HEAPU8[$57] | HEAPU8[$57 + 1] << 8 | HEAPU8[$57 + 2] << 16 | HEAPU8[$57 + 3] << 24 | 0);
  if ($50 >>> 0 >= $53 >>> 0 | $53 >>> 0 > 1048576 | $59 >>> 0 > 1073741824 | $56 >>> 0 >= $59 >>> 0 | $15 >>> 0 > ($59 - $56 | 0) >>> 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $64 = $30 + $28 * 60 + 44 | 0;
  var $currentCommand_0_in = $30 + $28 * 60 + 48 | 0;
  L1341 : while (1) {
    var $currentCommand_0_in;
    var $currentCommand_0 = HEAP32[$currentCommand_0_in >> 2];
    if (($currentCommand_0 | 0) == ($64 | 0)) {
      label = 1040;
      break;
    }
    var $69 = $currentCommand_0;
    var $70 = HEAP16[$36 >> 1];
    var $73 = $currentCommand_0 + 8 | 0;
    var $75 = (HEAP16[$73 >> 1] & 65535) < ($70 & 65535);
    do {
      if (($34 & 65535) < ($70 & 65535)) {
        if ($75) {
          label = 1033;
          break;
        } else {
          label = 1040;
          break L1341;
        }
      } else {
        if ($75) {
          break;
        } else {
          label = 1033;
          break;
        }
      }
    } while (0);
    if (label == 1033) {
      label = 0;
      var $79 = HEAP16[$73 >> 1];
      if (($79 & 65535) <= ($34 & 65535)) {
        label = 1034;
        break;
      }
    }
    var $currentCommand_0_in = $currentCommand_0 + 4 | 0;
  }
  do {
    if (label == 1034) {
      if (($79 & 65535) < ($34 & 65535)) {
        label = 1040;
        break;
      }
      if ((HEAP8[$currentCommand_0 + 12 | 0] & 15) << 24 >> 24 != 8) {
        var $_0 = -1;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      if (($59 | 0) != (HEAP32[HEAP32[$currentCommand_0 + 72 >> 2] + 12 >> 2] | 0)) {
        var $_0 = -1;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      if (($53 | 0) == (HEAP32[$currentCommand_0 + 60 >> 2] | 0)) {
        if (($currentCommand_0 | 0) == 0) {
          label = 1040;
          break;
        } else {
          var $startCommand_1 = $69;
          break;
        }
      } else {
        var $_0 = -1;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
    }
  } while (0);
  do {
    if (label == 1040) {
      _memcpy($hostCommand | 0, $command | 0, 48, 1);
      var $107 = _enet_packet_create(0, $59, 1);
      if (($107 | 0) == 0) {
        var $_0 = -1;
        var $_0;
        STACKTOP = __stackBase__;
        return $_0;
      }
      var $110 = $hostCommand + 2 | 0;
      tempBigInt = $34;
      HEAP8[$110] = tempBigInt & 255;
      tempBigInt >>= 8;
      HEAP8[$110 + 1] = tempBigInt & 255;
      var $111 = _enet_peer_queue_incoming_command($peer, $hostCommand, $107, $53);
      if (($111 | 0) == 0) {
        var $_0 = -1;
      } else {
        var $startCommand_1 = $111;
        break;
      }
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    }
  } while (0);
  var $startCommand_1;
  var $114 = $50 >>> 5;
  var $115 = $startCommand_1 + 68 | 0;
  var $120 = 1 << ($50 & 31);
  if ((HEAP32[HEAP32[$115 >> 2] + ($114 << 2) >> 2] & $120 | 0) != 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $124$s2 = ($startCommand_1 + 64 | 0) >> 2;
  HEAP32[$124$s2] = HEAP32[$124$s2] - 1 | 0;
  var $128 = ($114 << 2) + HEAP32[$115 >> 2] | 0;
  HEAP32[$128 >> 2] = HEAP32[$128 >> 2] | $120;
  var $133 = HEAP32[$startCommand_1 + 72 >> 2];
  var $135 = HEAP32[$133 + 12 >> 2];
  _memcpy(HEAP32[$133 + 8 >> 2] + $56 | 0, $command + 24 | 0, ($56 + $15 | 0) >>> 0 > $135 >>> 0 ? $135 - $56 | 0 : $15, 1);
  if ((HEAP32[$124$s2] | 0) != 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  _enet_peer_dispatch_incoming_reliable_commands($peer, $31);
  var $_0 = 0;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
_enet_protocol_handle_send_fragment["X"] = 1;
function _enet_protocol_handle_bandwidth_limit($host, $peer, $command) {
  var $27$s2;
  var $5$s2;
  var label;
  var $2 = $command + 4 | 0;
  var $5$s2 = ($peer + 48 | 0) >> 2;
  HEAP32[$5$s2] = _ntohl(HEAPU8[$2] | HEAPU8[$2 + 1] << 8 | HEAPU8[$2 + 2] << 16 | HEAPU8[$2 + 3] << 24 | 0);
  var $6 = $command + 8 | 0;
  HEAP32[$peer + 52 >> 2] = _ntohl(HEAPU8[$6] | HEAPU8[$6 + 1] << 8 | HEAPU8[$6 + 2] << 16 | HEAPU8[$6 + 3] << 24 | 0);
  do {
    if ((HEAP32[$5$s2] | 0) == 0) {
      if ((HEAP32[$host + 16 >> 2] | 0) != 0) {
        label = 1064;
        break;
      }
      HEAP32[$peer + 180 >> 2] = 32768;
      break;
    } else {
      label = 1064;
    }
  } while (0);
  if (label == 1064) {
    var $19 = HEAP32[$5$s2];
    var $21 = HEAP32[$host + 16 >> 2];
    HEAP32[$peer + 180 >> 2] = ($19 >>> 0 < $21 >>> 0 ? $19 : $21) >>> 4 & 268431360;
  }
  var $27$s2 = ($peer + 180 | 0) >> 2;
  var $28 = HEAP32[$27$s2];
  if ($28 >>> 0 < 4096) {
    HEAP32[$27$s2] = 4096;
    return;
  }
  if ($28 >>> 0 <= 32768) {
    return;
  }
  HEAP32[$27$s2] = 32768;
  return;
}
function _enet_protocol_handle_throttle_configure($peer, $command) {
  var $2 = $command + 4 | 0;
  HEAP32[$peer + 132 >> 2] = _ntohl(HEAPU8[$2] | HEAPU8[$2 + 1] << 8 | HEAPU8[$2 + 2] << 16 | HEAPU8[$2 + 3] << 24 | 0);
  var $6 = $command + 8 | 0;
  HEAP32[$peer + 124 >> 2] = _ntohl(HEAPU8[$6] | HEAPU8[$6 + 1] << 8 | HEAPU8[$6 + 2] << 16 | HEAPU8[$6 + 3] << 24 | 0);
  var $10 = $command + 12 | 0;
  HEAP32[$peer + 128 >> 2] = _ntohl(HEAPU8[$10] | HEAPU8[$10 + 1] << 8 | HEAPU8[$10 + 2] << 16 | HEAPU8[$10 + 3] << 24 | 0);
  return;
}
function _enet_protocol_handle_send_unreliable_fragment($host, $peer, $command, $currentData) {
  var $135$s2;
  var label;
  var $1 = $command + 1 | 0;
  if ((HEAP8[$1] & 255) >>> 0 >= HEAP32[$peer + 44 >> 2] >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  if ((HEAP32[$peer + 36 >> 2] - 5 | 0) >>> 0 >= 2) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $12 = $command + 6 | 0;
  var $15 = _ntohs((tempInt = HEAPU8[$12] | HEAPU8[$12 + 1] << 8, tempInt << 16 >> 16)) & 65535;
  var $17 = HEAP32[$currentData >> 2] + $15 | 0;
  HEAP32[$currentData >> 2] = $17;
  var $19 = HEAP32[$host + 10356 >> 2];
  if ($17 >>> 0 < $19 >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  if ($17 >>> 0 > ($19 + HEAP32[$host + 10360 >> 2] | 0) >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $28 = HEAP8[$1] & 255;
  var $30 = HEAP32[$peer + 40 >> 2];
  var $31 = $30 + $28 * 60 | 0;
  var $32 = $command + 2 | 0;
  var $33 = (tempInt = HEAPU8[$32] | HEAPU8[$32 + 1] << 8, tempInt << 16 >> 16);
  var $34 = $command + 4 | 0;
  var $36 = _ntohs((tempInt = HEAPU8[$34] | HEAPU8[$34 + 1] << 8, tempInt << 16 >> 16));
  var $37 = ($33 & 65535) >>> 12;
  var $38 = $30 + $28 * 60 + 38 | 0;
  var $39 = HEAP16[$38 >> 1];
  var $40 = ($39 & 65535) >>> 12;
  var $reliableWindow_0 = ($33 & 65535) < ($39 & 65535) ? $37 | 16 : $37;
  if (($reliableWindow_0 & 65535) < ($40 & 65535)) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  if (($reliableWindow_0 & 65535) >>> 0 >= (($40 & 65535) + 7 | 0) >>> 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  do {
    if ($33 << 16 >> 16 == $39 << 16 >> 16) {
      if (($36 & 65535) > (HEAP16[($30 + 40 >> 1) + ($28 * 30 | 0)] & 65535)) {
        break;
      } else {
        var $_0 = 0;
      }
      var $_0;
      return $_0;
    }
  } while (0);
  var $56 = $command + 12 | 0;
  var $58 = _ntohl(HEAPU8[$56] | HEAPU8[$56 + 1] << 8 | HEAPU8[$56 + 2] << 16 | HEAPU8[$56 + 3] << 24 | 0);
  var $59 = $command + 8 | 0;
  var $61 = _ntohl(HEAPU8[$59] | HEAPU8[$59 + 1] << 8 | HEAPU8[$59 + 2] << 16 | HEAPU8[$59 + 3] << 24 | 0);
  var $62 = $command + 20 | 0;
  var $64 = _ntohl(HEAPU8[$62] | HEAPU8[$62 + 1] << 8 | HEAPU8[$62 + 2] << 16 | HEAPU8[$62 + 3] << 24 | 0);
  var $65 = $command + 16 | 0;
  var $67 = _ntohl(HEAPU8[$65] | HEAPU8[$65 + 1] << 8 | HEAPU8[$65 + 2] << 16 | HEAPU8[$65 + 3] << 24 | 0);
  if ($58 >>> 0 >= $61 >>> 0 | $61 >>> 0 > 1048576 | $67 >>> 0 > 1073741824 | $64 >>> 0 >= $67 >>> 0 | $15 >>> 0 > ($67 - $64 | 0) >>> 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  var $72 = $30 + $28 * 60 + 52 | 0;
  var $currentCommand_0_in = $30 + $28 * 60 + 56 | 0;
  L1418 : while (1) {
    var $currentCommand_0_in;
    var $currentCommand_0 = HEAP32[$currentCommand_0_in >> 2];
    if (($currentCommand_0 | 0) == ($72 | 0)) {
      label = 1097;
      break;
    }
    var $77 = $currentCommand_0;
    var $78 = HEAP16[$38 >> 1];
    var $81 = $currentCommand_0 + 8 | 0;
    var $83 = (HEAP16[$81 >> 1] & 65535) < ($78 & 65535);
    do {
      if (($33 & 65535) < ($78 & 65535)) {
        if ($83) {
          label = 1088;
          break;
        } else {
          label = 1097;
          break L1418;
        }
      } else {
        if ($83) {
          break;
        } else {
          label = 1088;
          break;
        }
      }
    } while (0);
    do {
      if (label == 1088) {
        label = 0;
        var $87 = HEAP16[$81 >> 1];
        if (($87 & 65535) < ($33 & 65535)) {
          label = 1097;
          break L1418;
        }
        if (($87 & 65535) > ($33 & 65535)) {
          break;
        }
        var $93 = HEAP16[$77 + 10 >> 1];
        if (($93 & 65535) <= ($36 & 65535)) {
          label = 1091;
          break L1418;
        }
      }
    } while (0);
    var $currentCommand_0_in = $currentCommand_0 + 4 | 0;
  }
  do {
    if (label == 1091) {
      if (($93 & 65535) < ($36 & 65535)) {
        label = 1097;
        break;
      }
      if ((HEAP8[$currentCommand_0 + 12 | 0] & 15) << 24 >> 24 != 12) {
        var $_0 = -1;
        var $_0;
        return $_0;
      }
      if (($67 | 0) != (HEAP32[HEAP32[$currentCommand_0 + 72 >> 2] + 12 >> 2] | 0)) {
        var $_0 = -1;
        var $_0;
        return $_0;
      }
      if (($61 | 0) == (HEAP32[$currentCommand_0 + 60 >> 2] | 0)) {
        if (($currentCommand_0 | 0) == 0) {
          label = 1097;
          break;
        } else {
          var $startCommand_1 = $77;
          break;
        }
      } else {
        var $_0 = -1;
        var $_0;
        return $_0;
      }
    }
  } while (0);
  do {
    if (label == 1097) {
      var $119 = _enet_packet_create(0, $67, 8);
      if (($119 | 0) == 0) {
        var $_0 = -1;
        var $_0;
        return $_0;
      }
      var $122 = _enet_peer_queue_incoming_command($peer, $command, $119, $61);
      if (($122 | 0) == 0) {
        var $_0 = -1;
      } else {
        var $startCommand_1 = $122;
        break;
      }
      var $_0;
      return $_0;
    }
  } while (0);
  var $startCommand_1;
  var $125 = $58 >>> 5;
  var $126 = $startCommand_1 + 68 | 0;
  var $131 = 1 << ($58 & 31);
  if ((HEAP32[HEAP32[$126 >> 2] + ($125 << 2) >> 2] & $131 | 0) != 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $135$s2 = ($startCommand_1 + 64 | 0) >> 2;
  HEAP32[$135$s2] = HEAP32[$135$s2] - 1 | 0;
  var $139 = ($125 << 2) + HEAP32[$126 >> 2] | 0;
  HEAP32[$139 >> 2] = HEAP32[$139 >> 2] | $131;
  var $144 = HEAP32[$startCommand_1 + 72 >> 2];
  var $146 = HEAP32[$144 + 12 >> 2];
  _memcpy(HEAP32[$144 + 8 >> 2] + $64 | 0, $command + 24 | 0, ($64 + $15 | 0) >>> 0 > $146 >>> 0 ? $146 - $64 | 0 : $15, 1);
  if ((HEAP32[$135$s2] | 0) != 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  _enet_peer_dispatch_incoming_unreliable_commands($peer, $31);
  var $_0 = 0;
  var $_0;
  return $_0;
}
_enet_protocol_handle_send_unreliable_fragment["X"] = 1;
function _enet_protocol_dispatch_state($host, $peer, $state) {
  HEAP32[$peer + 36 >> 2] = $state;
  var $2 = $peer + 240 | 0;
  if ((HEAP32[$2 >> 2] | 0) != 0) {
    return;
  }
  _enet_list_insert($host + 52 | 0, $peer);
  HEAP32[$2 >> 2] = 1;
  return;
}
function _enet_protocol_remove_sent_reliable_command($peer, $reliableSequenceNumber, $channelID) {
  var $72$s2;
  var label;
  var $1 = $peer + 200 | 0;
  var $2 = $1 | 0;
  var $currentCommand_0_in = $2;
  while (1) {
    var $currentCommand_0_in;
    var $currentCommand_0 = HEAP32[$currentCommand_0_in >> 2];
    var $4 = ($currentCommand_0 | 0) == ($1 | 0);
    if ($4) {
      label = 1130;
      break;
    }
    if (HEAP16[$currentCommand_0 + 8 >> 1] << 16 >> 16 == $reliableSequenceNumber << 16 >> 16) {
      if (HEAP8[$currentCommand_0 + 33 | 0] << 24 >> 24 == $channelID << 24 >> 24) {
        label = 1129;
        break;
      }
    }
    var $currentCommand_0_in = $currentCommand_0 | 0;
  }
  do {
    if (label == 1129) {
      if ($4) {
        label = 1130;
        break;
      } else {
        var $wasSent_0 = 1;
        var $outgoingCommand_4 = $currentCommand_0;
        break;
      }
    }
  } while (0);
  do {
    if (label == 1130) {
      var $20 = $peer + 216 | 0;
      var $_pn = $20;
      while (1) {
        var $_pn;
        var $currentCommand_1 = HEAP32[$_pn >> 2];
        var $21 = ($currentCommand_1 | 0) == ($20 | 0);
        if ($21) {
          var $_0 = 0;
          label = 1149;
          break;
        }
        var $23 = $currentCommand_1;
        if (HEAP16[$23 + 30 >> 1] << 16 >> 16 == 0) {
          var $_0 = 0;
          label = 1152;
          break;
        }
        if (HEAP16[$currentCommand_1 + 8 >> 1] << 16 >> 16 != $reliableSequenceNumber << 16 >> 16) {
          var $_pn = $currentCommand_1;
          continue;
        }
        if (HEAP8[$currentCommand_1 + 33 | 0] << 24 >> 24 == $channelID << 24 >> 24) {
          label = 1135;
          break;
        } else {
          var $_pn = $currentCommand_1;
        }
      }
      if (label == 1135) {
        if ($21) {
          var $_0 = 0;
        } else {
          var $wasSent_0 = 0;
          var $outgoingCommand_4 = $23;
          break;
        }
        var $_0;
        return $_0;
      } else if (label == 1149) {
        var $_0;
        return $_0;
      } else if (label == 1152) {
        var $_0;
        return $_0;
      }
    }
  } while (0);
  var $outgoingCommand_4;
  var $wasSent_0;
  if (($outgoingCommand_4 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $42 = $channelID & 255;
  do {
    if ($42 >>> 0 < HEAP32[$peer + 44 >> 2] >>> 0) {
      var $48 = HEAP32[$peer + 40 >> 2];
      var $50 = ($reliableSequenceNumber & 65535) >>> 12 & 65535;
      var $51 = ($50 << 1) + $48 + $42 * 60 + 6 | 0;
      var $52 = HEAP16[$51 >> 1];
      if ($52 << 16 >> 16 == 0) {
        break;
      }
      var $55 = $52 - 1 & 65535;
      HEAP16[$51 >> 1] = $55;
      if ($55 << 16 >> 16 != 0) {
        break;
      }
      var $60 = $48 + $42 * 60 + 4 | 0;
      HEAP16[$60 >> 1] = HEAP16[$60 >> 1] & 65535 & (1 << $50 ^ 65535) & 65535;
    }
  } while (0);
  var $69 = HEAP8[$outgoingCommand_4 + 32 | 0] & 255 & 15;
  _enet_list_remove($outgoingCommand_4 | 0);
  var $72$s2 = ($outgoingCommand_4 + 80 | 0) >> 2;
  do {
    if ((HEAP32[$72$s2] | 0) != 0) {
      if (($wasSent_0 | 0) != 0) {
        var $81 = $peer + 184 | 0;
        HEAP32[$81 >> 2] = HEAP32[$81 >> 2] - (HEAP16[$outgoingCommand_4 + 28 >> 1] & 65535) | 0;
      }
      var $86 = HEAP32[$72$s2] | 0;
      HEAP32[$86 >> 2] = HEAP32[$86 >> 2] - 1 | 0;
      var $89 = HEAP32[$72$s2];
      if ((HEAP32[$89 >> 2] | 0) != 0) {
        break;
      }
      _enet_packet_destroy($89);
    }
  } while (0);
  _enet_free($outgoingCommand_4);
  var $96 = HEAP32[$2 >> 2];
  if (($96 | 0) == ($1 | 0)) {
    var $_0 = $69;
    var $_0;
    return $_0;
  }
  HEAP32[$peer + 80 >> 2] = HEAP32[$96 + 16 >> 2] + HEAP32[$96 + 12 >> 2] | 0;
  var $_0 = $69;
  var $_0;
  return $_0;
}
_enet_protocol_remove_sent_reliable_command["X"] = 1;
function _enet_protocol_notify_connect($host, $peer, $event) {
  HEAP32[$host + 32 >> 2] = 1;
  var $3 = $peer + 36 | 0;
  if (($event | 0) == 0) {
    _enet_protocol_dispatch_state($host, $peer, (HEAP32[$3 >> 2] | 0) == 1 ? 4 : 3);
    return;
  } else {
    HEAP32[$3 >> 2] = 5;
    HEAP32[$event >> 2] = 1;
    HEAP32[$event + 4 >> 2] = $peer;
    HEAP32[$event + 12 >> 2] = HEAP32[$peer + 376 >> 2];
    return;
  }
}
function _enet_protocol_notify_disconnect($host, $peer, $event) {
  var $1 = $peer + 36 | 0;
  if (HEAP32[$1 >> 2] >>> 0 > 2) {
    HEAP32[$host + 32 >> 2] = 1;
  }
  var $7 = HEAP32[$1 >> 2];
  if (($7 | 0) != 1 & $7 >>> 0 < 4) {
    _enet_peer_reset($peer);
    return;
  }
  if (($event | 0) == 0) {
    HEAP32[$peer + 376 >> 2] = 0;
    _enet_protocol_dispatch_state($host, $peer, 9);
    return;
  } else {
    HEAP32[$event >> 2] = 2;
    HEAP32[$event + 4 >> 2] = $peer;
    HEAP32[$event + 12 >> 2] = 0;
    _enet_peer_reset($peer);
    return;
  }
}
function _enet_protocol_send_acknowledgements($host, $peer) {
  var $15$s2;
  var $5$s2;
  var $1$s2;
  var label;
  var $1$s2 = ($host + 1608 | 0) >> 2;
  var $3 = $host + 70 | 0;
  var $5$s2 = ($host + 2132 | 0) >> 2;
  var $7 = $host + 1612 | 0;
  var $9 = $peer + 192 | 0;
  var $12 = $host + 1606 | 0;
  var $13 = $host + 2132 | 0;
  var $14 = $peer + 176 | 0;
  var $15$s2 = ($host + 64 | 0) >> 2;
  var $currentAcknowledgement_0 = HEAP32[$9 >> 2];
  var $buffer_0 = (HEAP32[$5$s2] << 3) + $host + 1612 | 0;
  var $command_0 = $host + HEAP32[$1$s2] * 48 + 70 | 0;
  while (1) {
    var $command_0;
    var $buffer_0;
    var $currentAcknowledgement_0;
    if (($currentAcknowledgement_0 | 0) == ($9 | 0)) {
      label = 1181;
      break;
    }
    if (!($command_0 >>> 0 < $12 >>> 0 & $buffer_0 >>> 0 < $13 >>> 0)) {
      break;
    }
    if ((HEAP32[$14 >> 2] - HEAP32[$15$s2] | 0) >>> 0 < 8) {
      break;
    }
    var $30 = HEAP32[$currentAcknowledgement_0 >> 2];
    var $31 = $command_0 | 0;
    HEAP32[$buffer_0 >> 2] = $31;
    HEAP32[$buffer_0 + 4 >> 2] = 8;
    HEAP32[$15$s2] = HEAP32[$15$s2] + 8 | 0;
    HEAP8[$31] = 1;
    var $36 = $currentAcknowledgement_0 + 12 | 0;
    var $37 = $36;
    HEAP8[$command_0 + 1 | 0] = HEAP8[$37 + 1 | 0];
    var $41 = $37 + 2 | 0;
    var $44 = $command_0 + 4 | 0;
    tempBigInt = _htons((tempInt = HEAPU8[$41] | HEAPU8[$41 + 1] << 8, tempInt << 16 >> 16));
    HEAP8[$44] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$44 + 1] = tempBigInt & 255;
    var $51 = $command_0 + 6 | 0;
    tempBigInt = _htons(HEAP32[$currentAcknowledgement_0 + 8 >> 2] & 65535);
    HEAP8[$51] = tempBigInt & 255;
    tempBigInt >>= 8;
    HEAP8[$51 + 1] = tempBigInt & 255;
    if ((HEAP8[$36] & 15) << 24 >> 24 == 4) {
      _enet_protocol_dispatch_state($host, $peer, 9);
    }
    _enet_list_remove($currentAcknowledgement_0);
    _enet_free($currentAcknowledgement_0);
    var $currentAcknowledgement_0 = $30;
    var $buffer_0 = $buffer_0 + 8 | 0;
    var $command_0 = $command_0 + 48 | 0;
  }
  if (label == 1181) {
    var $62 = $command_0;
    var $63 = $3;
    var $64 = $62 - $63 | 0;
    var $65 = ($64 | 0) / 48 & -1;
    HEAP32[$1$s2] = $65;
    var $66 = $buffer_0;
    var $67 = $7;
    var $68 = $66 - $67 | 0;
    var $69 = $68 >> 3;
    HEAP32[$5$s2] = $69;
    return;
  }
  HEAP32[$host + 60 >> 2] = 1;
  var $62 = $command_0;
  var $63 = $3;
  var $64 = $62 - $63 | 0;
  var $65 = ($64 | 0) / 48 & -1;
  HEAP32[$1$s2] = $65;
  var $66 = $buffer_0;
  var $67 = $7;
  var $68 = $66 - $67 | 0;
  var $69 = $68 >> 3;
  HEAP32[$5$s2] = $69;
  return;
}
_enet_protocol_send_acknowledgements["X"] = 1;
function _enet_protocol_check_timeouts($host, $peer, $event) {
  var $26$s2;
  var $7$s2;
  var label;
  var $1 = $peer + 200 | 0;
  var $2 = $1 | 0;
  var $5 = HEAP32[$peer + 216 >> 2];
  var $6 = $host + 48 | 0;
  var $7$s2 = ($peer + 84 | 0) >> 2;
  var $8 = $peer + 96 | 0;
  var $9 = $peer + 80 | 0;
  var $10 = $peer + 184 | 0;
  var $11 = $peer + 148 | 0;
  var $12 = $peer + 144 | 0;
  var $currentCommand_0 = HEAP32[$2 >> 2];
  L1534 : while (1) {
    var $currentCommand_0;
    if (($currentCommand_0 | 0) == ($1 | 0)) {
      var $_0 = 0;
      label = 1200;
      break;
    }
    var $16 = HEAP32[$currentCommand_0 >> 2];
    var $17 = HEAP32[$6 >> 2];
    var $19 = $currentCommand_0 + 12 | 0;
    var $20 = HEAP32[$19 >> 2];
    var $21 = $17 - $20 | 0;
    var $25 = $currentCommand_0 + 16 | 0;
    var $26$s2 = $25 >> 2;
    if (($21 >>> 0 > 86399999 ? $20 - $17 | 0 : $21) >>> 0 < HEAP32[$26$s2] >>> 0) {
      var $currentCommand_0 = $16;
      continue;
    }
    var $30 = HEAP32[$7$s2];
    do {
      if (($30 | 0) == 0) {
        label = 1188;
      } else {
        if (($20 - $30 | 0) >>> 0 > 86399999) {
          label = 1188;
          break;
        }
        var $38 = HEAP32[$7$s2];
        break;
      }
    } while (0);
    if (label == 1188) {
      label = 0;
      var $36 = HEAP32[$19 >> 2];
      HEAP32[$7$s2] = $36;
      var $38 = $36;
    }
    var $38;
    do {
      if (($38 | 0) != 0) {
        var $41 = HEAP32[$6 >> 2];
        var $42 = $41 - $38 | 0;
        var $45 = $42 >>> 0 > 86399999 ? $38 - $41 | 0 : $42;
        if ($45 >>> 0 >= HEAP32[$11 >> 2] >>> 0) {
          break L1534;
        }
        if (HEAP32[$26$s2] >>> 0 < HEAP32[$currentCommand_0 + 20 >> 2] >>> 0) {
          break;
        }
        if ($45 >>> 0 >= HEAP32[$12 >> 2] >>> 0) {
          break L1534;
        }
      }
    } while (0);
    if ((HEAP32[$currentCommand_0 + 80 >> 2] | 0) != 0) {
      HEAP32[$10 >> 2] = HEAP32[$10 >> 2] - (HEAP16[$currentCommand_0 + 28 >> 1] & 65535) | 0;
    }
    HEAP32[$8 >> 2] = HEAP32[$8 >> 2] + 1 | 0;
    HEAP32[$25 >> 2] = HEAP32[$26$s2] << 1;
    _enet_list_insert($5, _enet_list_remove($currentCommand_0));
    var $78 = HEAP32[$2 >> 2];
    if (($16 | 0) != ($78 | 0) | ($78 | 0) == ($1 | 0)) {
      var $currentCommand_0 = $16;
      continue;
    }
    HEAP32[$9 >> 2] = HEAP32[$16 + 16 >> 2] + HEAP32[$16 + 12 >> 2] | 0;
    var $currentCommand_0 = $16;
  }
  if (label == 1200) {
    var $_0;
    return $_0;
  }
  _enet_protocol_notify_disconnect($host, $peer, $event);
  var $_0 = 1;
  var $_0;
  return $_0;
}
_enet_protocol_check_timeouts["X"] = 1;
function _enet_protocol_send_reliable_outgoing_commands($host, $peer) {
  var $208$s1;
  var $91$s2;
  var $buffer_0_ph_ph$s2;
  var $21$s2;
  var $5$s2;
  var $1$s2;
  var label;
  var $1$s2 = ($host + 1608 | 0) >> 2;
  var $3 = $host + 70 | 0;
  var $5$s2 = ($host + 2132 | 0) >> 2;
  var $7 = $host + 1612 | 0;
  var $9 = $peer + 216 | 0;
  var $12 = $peer + 44 | 0;
  var $13 = $peer + 40 | 0;
  var $14 = $peer + 108 | 0;
  var $15 = $peer + 180 | 0;
  var $16 = $peer + 184 | 0;
  var $17 = $peer + 176 | 0;
  var $18 = $host + 1606 | 0;
  var $19 = $host + 2132 | 0;
  var $20 = $peer + 176 | 0;
  var $21$s2 = ($host + 64 | 0) >> 2;
  var $22 = $peer + 168 | 0;
  var $23 = $peer + 172 | 0;
  var $24 = $peer + 140 | 0;
  var $25 = $peer + 200 | 0;
  var $26 = $25 | 0;
  var $27 = $host + 48 | 0;
  var $28 = $peer + 80 | 0;
  var $29 = $host + 48 | 0;
  var $30 = $host + 68 | 0;
  var $31 = $peer + 92 | 0;
  var $32 = $peer + 184 | 0;
  var $canPing_0_ph_ph = 1;
  var $windowWrap_0_ph_ph = 0;
  var $command_0_ph_ph = $host + HEAP32[$1$s2] * 48 + 70 | 0;
  var $buffer_0_ph_ph = (HEAP32[$5$s2] << 3) + $host + 1612 | 0, $buffer_0_ph_ph$s2 = $buffer_0_ph_ph >> 2;
  var $windowExceeded_0_ph_ph = 0;
  var $currentCommand_0_ph_ph = HEAP32[$9 >> 2];
  L1558 : while (1) {
    var $currentCommand_0_ph_ph;
    var $windowExceeded_0_ph_ph;
    var $buffer_0_ph_ph;
    var $command_0_ph_ph;
    var $windowWrap_0_ph_ph;
    var $canPing_0_ph_ph;
    var $windowWrap_0_ph = $windowWrap_0_ph_ph;
    var $windowExceeded_0_ph = $windowExceeded_0_ph_ph;
    var $currentCommand_0_ph = $currentCommand_0_ph_ph;
    while (1) {
      var $currentCommand_0_ph;
      var $windowExceeded_0_ph;
      var $windowWrap_0_ph;
      var $windowWrap_0 = $windowWrap_0_ph;
      var $currentCommand_0 = $currentCommand_0_ph;
      L1562 : while (1) {
        var $currentCommand_0;
        var $windowWrap_0;
        if (($currentCommand_0 | 0) == ($9 | 0)) {
          var $canPing_1 = $canPing_0_ph_ph;
          label = 1237;
          break L1558;
        }
        var $36 = $currentCommand_0;
        var $37 = $currentCommand_0 + 32 | 0;
        var $41 = HEAP8[$37 + 1 | 0] & 255;
        if ($41 >>> 0 >= HEAP32[$12 >> 2] >>> 0) {
          label = 1207;
          break;
        }
        var $49 = HEAP32[$13 >> 2];
        var $50 = $49 + $41 * 60 | 0;
        var $53 = HEAP16[$currentCommand_0 + 8 >> 1];
        var $54 = ($53 & 65535) >>> 12;
        var $55 = ($50 | 0) != 0;
        if (!$55) {
          var $windowWrap_2 = $windowWrap_0;
          var $89 = 0;
          var $88 = $54;
          var $87 = 0;
          break;
        }
        do {
          if (($windowWrap_0 | 0) == 0) {
            if (HEAP16[$36 + 30 >> 1] << 16 >> 16 != 0) {
              var $windowWrap_2 = 0;
              var $89 = $50;
              var $88 = $54;
              var $87 = $55;
              break L1562;
            }
            if (($53 & 4095) << 16 >> 16 == 0) {
              var $66 = $54 & 65535;
              if ((HEAP16[(((($66 | 16) - 1) % 16 << 1) + $49 + 6 >> 1) + ($41 * 30 | 0)] & 65535) > 4095) {
                var $windowWrap_14 = 1;
                break;
              }
              if ((HEAP16[($49 + 4 >> 1) + ($41 * 30 | 0)] & 65535 & (255 >>> ((4096 - $66 | 0) >>> 0) | 255 << $66) | 0) != 0) {
                var $windowWrap_14 = 1;
                break;
              }
            }
            if (($windowWrap_0 | 0) == 0) {
              var $windowWrap_2 = 0;
              var $89 = $50;
              var $88 = $54;
              var $87 = $55;
              break L1562;
            } else {
              var $windowWrap_14 = $windowWrap_0;
            }
          } else {
            var $windowWrap_14 = $windowWrap_0;
          }
        } while (0);
        var $windowWrap_14;
        var $windowWrap_0 = $windowWrap_14;
        var $currentCommand_0 = HEAP32[$currentCommand_0 >> 2];
      }
      if (label == 1207) {
        label = 0;
        var $windowWrap_2 = $windowWrap_0;
        var $89 = 0;
        var $88 = (HEAP16[$currentCommand_0 + 8 >> 1] & 65535) >>> 12;
        var $87 = 0;
      }
      var $87;
      var $88;
      var $89;
      var $windowWrap_2;
      var $91$s2 = ($currentCommand_0 + 80 | 0) >> 2;
      if ((HEAP32[$91$s2] | 0) == 0) {
        var $windowExceeded_2 = $windowExceeded_0_ph;
        break;
      }
      if (($windowExceeded_0_ph | 0) == 0) {
        var $100 = (HEAP32[$15 >> 2] * HEAP32[$14 >> 2] | 0) >>> 5;
        var $107 = HEAP32[$17 >> 2];
        var $_windowExceeded_0 = ((HEAP16[$currentCommand_0 + 28 >> 1] & 65535) + HEAP32[$16 >> 2] | 0) >>> 0 > ($100 >>> 0 > $107 >>> 0 ? $100 : $107) >>> 0 ? 1 : $windowExceeded_0_ph;
        if (($_windowExceeded_0 | 0) == 0) {
          var $windowExceeded_2 = 0;
          break;
        } else {
          var $windowExceeded_17 = $_windowExceeded_0;
        }
      } else {
        var $windowExceeded_17 = $windowExceeded_0_ph;
      }
      var $windowExceeded_17;
      var $windowWrap_0_ph = $windowWrap_2;
      var $windowExceeded_0_ph = $windowExceeded_17;
      var $currentCommand_0_ph = HEAP32[$currentCommand_0 >> 2];
    }
    var $windowExceeded_2;
    var $114 = $37;
    var $119 = HEAP32[_commandSizes + ((HEAP8[$114] & 255 & 15) << 2) >> 2];
    if ($command_0_ph_ph >>> 0 >= $18 >>> 0) {
      break;
    }
    var $122 = $buffer_0_ph_ph + 8 | 0;
    if ($122 >>> 0 >= $19 >>> 0) {
      break;
    }
    var $127 = HEAP32[$20 >> 2] - HEAP32[$21$s2] | 0;
    if ($127 >>> 0 < $119 >>> 0) {
      break;
    }
    if ((HEAP32[$91$s2] | 0) != 0) {
      if (($127 & 65535) >>> 0 < ((HEAP16[$currentCommand_0 + 28 >> 1] & 65535) + $119 & 65535) >>> 0) {
        break;
      }
    }
    var $145 = HEAP32[$currentCommand_0 >> 2];
    do {
      if ($87) {
        if (HEAP16[$36 + 30 >> 1] << 16 >> 16 != 0) {
          break;
        }
        var $151 = $88 & 65535;
        var $153 = $89 + 4 | 0;
        HEAP16[$153 >> 1] = (HEAP16[$153 >> 1] & 65535 | 1 << $151) & 65535;
        var $158 = ($151 << 1) + $89 + 6 | 0;
        HEAP16[$158 >> 1] = HEAP16[$158 >> 1] + 1 & 65535;
      }
    } while (0);
    var $162 = $36 + 30 | 0;
    HEAP16[$162 >> 1] = HEAP16[$162 >> 1] + 1 & 65535;
    var $165 = $currentCommand_0 + 16 | 0;
    var $166 = $165;
    if ((HEAP32[$166 >> 2] | 0) == 0) {
      var $173 = (HEAP32[$23 >> 2] << 2) + HEAP32[$22 >> 2] | 0;
      HEAP32[$165 >> 2] = $173;
      HEAP32[$currentCommand_0 + 20 >> 2] = $173 * HEAP32[$24 >> 2] | 0;
    }
    if ((HEAP32[$26 >> 2] | 0) == ($25 | 0)) {
      HEAP32[$28 >> 2] = HEAP32[$166 >> 2] + HEAP32[$27 >> 2] | 0;
    }
    _enet_list_insert($25, _enet_list_remove($currentCommand_0));
    HEAP32[$currentCommand_0 + 12 >> 2] = HEAP32[$29 >> 2];
    var $190 = $command_0_ph_ph | 0;
    HEAP32[$buffer_0_ph_ph$s2] = $190;
    HEAP32[$buffer_0_ph_ph$s2 + 1] = $119;
    HEAP32[$21$s2] = HEAP32[$21$s2] + $119 | 0;
    HEAP16[$30 >> 1] = HEAP16[$30 >> 1] | -32768;
    _memcpy($190, $114, 48, 1);
    var $197 = HEAP32[$91$s2];
    if (($197 | 0) == 0) {
      var $buffer_1 = $buffer_0_ph_ph;
    } else {
      HEAP32[$122 >> 2] = HEAP32[$197 + 8 >> 2] + HEAP32[$currentCommand_0 + 24 >> 2] | 0;
      var $208$s1 = ($currentCommand_0 + 28 | 0) >> 1;
      HEAP32[$buffer_0_ph_ph$s2 + 3] = HEAP16[$208$s1] & 65535;
      HEAP32[$21$s2] = HEAP32[$21$s2] + (HEAP16[$208$s1] & 65535) | 0;
      HEAP32[$32 >> 2] = HEAP32[$32 >> 2] + (HEAP16[$208$s1] & 65535) | 0;
      var $buffer_1 = $122;
    }
    var $buffer_1;
    HEAP32[$31 >> 2] = HEAP32[$31 >> 2] + 1 | 0;
    var $canPing_0_ph_ph = 0;
    var $windowWrap_0_ph_ph = $windowWrap_2;
    var $command_0_ph_ph = $command_0_ph_ph + 48 | 0;
    var $buffer_0_ph_ph = $buffer_1 + 8 | 0, $buffer_0_ph_ph$s2 = $buffer_0_ph_ph >> 2;
    var $windowExceeded_0_ph_ph = $windowExceeded_2;
    var $currentCommand_0_ph_ph = $145;
  }
  if (label == 1237) {
    var $canPing_1;
    var $225 = $command_0_ph_ph;
    var $226 = $3;
    var $227 = $225 - $226 | 0;
    var $228 = ($227 | 0) / 48 & -1;
    HEAP32[$1$s2] = $228;
    var $229 = $buffer_0_ph_ph;
    var $230 = $7;
    var $231 = $229 - $230 | 0;
    var $232 = $231 >> 3;
    HEAP32[$5$s2] = $232;
    return $canPing_1;
  }
  HEAP32[$host + 60 >> 2] = 1;
  var $canPing_1 = 0;
  var $canPing_1;
  var $225 = $command_0_ph_ph;
  var $226 = $3;
  var $227 = $225 - $226 | 0;
  var $228 = ($227 | 0) / 48 & -1;
  HEAP32[$1$s2] = $228;
  var $229 = $buffer_0_ph_ph;
  var $230 = $7;
  var $231 = $229 - $230 | 0;
  var $232 = $231 >> 3;
  HEAP32[$5$s2] = $232;
  return $canPing_1;
}
_enet_protocol_send_reliable_outgoing_commands["X"] = 1;
function _enet_initialize() {
  return 0;
}
function _enet_deinitialize() {
  return;
}
function _enet_protocol_send_unreliable_outgoing_commands($host, $peer) {
  var $37$s2;
  var $buffer_0_ph$s2;
  var $15$s2;
  var label;
  var $1 = $host + 1608 | 0;
  var $3 = $host + 70 | 0;
  var $5 = $host + 2132 | 0;
  var $7 = $host + 1612 | 0;
  var $9 = $peer + 224 | 0;
  var $10 = $9 | 0;
  var $12 = $host + 1606 | 0;
  var $13 = $host + 2132 | 0;
  var $14 = $peer + 176 | 0;
  var $15$s2 = ($host + 64 | 0) >> 2;
  var $16 = $peer + 116 | 0;
  var $17 = $peer + 108 | 0;
  var $18 = $peer + 208 | 0;
  var $currentCommand_0_ph = HEAP32[$10 >> 2];
  var $command_0_ph = $host + HEAP32[$1 >> 2] * 48 + 70 | 0;
  var $buffer_0_ph = (HEAP32[$5 >> 2] << 3) + $host + 1612 | 0, $buffer_0_ph$s2 = $buffer_0_ph >> 2;
  L1609 : while (1) {
    var $buffer_0_ph;
    var $command_0_ph;
    var $currentCommand_0_ph;
    var $19 = $buffer_0_ph + 8 | 0;
    var $currentCommand_0 = $currentCommand_0_ph;
    L1611 : while (1) {
      var $currentCommand_0;
      if (($currentCommand_0 | 0) == ($9 | 0)) {
        break L1609;
      }
      var $22 = $currentCommand_0;
      var $24 = $currentCommand_0 + 32 | 0;
      var $29 = HEAP32[_commandSizes + ((HEAP8[$24] & 255 & 15) << 2) >> 2];
      if ($command_0_ph >>> 0 >= $12 >>> 0 | $19 >>> 0 >= $13 >>> 0) {
        label = 1249;
        break L1609;
      }
      var $33 = HEAP32[$14 >> 2] - HEAP32[$15$s2] | 0;
      if ($33 >>> 0 < $29 >>> 0) {
        label = 1249;
        break L1609;
      }
      var $37$s2 = ($currentCommand_0 + 80 | 0) >> 2;
      if ((HEAP32[$37$s2] | 0) == 0) {
        label = 1247;
        break;
      }
      if ($33 >>> 0 < ((HEAP16[$currentCommand_0 + 28 >> 1] & 65535) + $29 | 0) >>> 0) {
        label = 1249;
        break L1609;
      }
      var $53 = HEAP32[$currentCommand_0 >> 2];
      if ((HEAP32[$37$s2] | 0) == 0) {
        var $101 = $53;
        break;
      }
      if ((HEAP32[$currentCommand_0 + 24 >> 2] | 0) != 0) {
        var $101 = $53;
        break;
      }
      var $63 = HEAP32[$16 >> 2] + 7 & 31;
      HEAP32[$16 >> 2] = $63;
      if ($63 >>> 0 <= HEAP32[$17 >> 2] >>> 0) {
        var $101 = $53;
        break;
      }
      var $69 = HEAP16[$currentCommand_0 + 8 >> 1];
      var $71 = HEAP16[$22 + 10 >> 1];
      var $currentCommand_1 = $53;
      var $outgoingCommand_0 = $22;
      while (1) {
        var $outgoingCommand_0;
        var $currentCommand_1;
        var $73 = $outgoingCommand_0 + 80 | 0;
        var $75 = HEAP32[$73 >> 2] | 0;
        HEAP32[$75 >> 2] = HEAP32[$75 >> 2] - 1 | 0;
        var $78 = HEAP32[$73 >> 2];
        if ((HEAP32[$78 >> 2] | 0) == 0) {
          _enet_packet_destroy($78);
        }
        _enet_list_remove($outgoingCommand_0 | 0);
        _enet_free($outgoingCommand_0);
        if (($currentCommand_1 | 0) == ($9 | 0)) {
          var $currentCommand_0 = $currentCommand_1;
          continue L1611;
        }
        var $89 = $currentCommand_1;
        if (HEAP16[$currentCommand_1 + 8 >> 1] << 16 >> 16 != $69 << 16 >> 16) {
          var $currentCommand_0 = $currentCommand_1;
          continue L1611;
        }
        if (HEAP16[$89 + 10 >> 1] << 16 >> 16 != $71 << 16 >> 16) {
          var $currentCommand_0 = $currentCommand_1;
          continue L1611;
        }
        var $currentCommand_1 = HEAP32[$currentCommand_1 >> 2];
        var $outgoingCommand_0 = $89;
      }
    }
    if (label == 1247) {
      label = 0;
      var $101 = HEAP32[$currentCommand_0 >> 2];
    }
    var $101;
    var $102 = $command_0_ph | 0;
    HEAP32[$buffer_0_ph$s2] = $102;
    HEAP32[$buffer_0_ph$s2 + 1] = $29;
    HEAP32[$15$s2] = HEAP32[$15$s2] + $29 | 0;
    _memcpy($102, $24, 48, 1);
    _enet_list_remove($currentCommand_0);
    var $108 = HEAP32[$37$s2];
    if (($108 | 0) == 0) {
      _enet_free($currentCommand_0);
      var $buffer_1 = $buffer_0_ph;
    } else {
      HEAP32[$19 >> 2] = HEAP32[$108 + 8 >> 2] + HEAP32[$currentCommand_0 + 24 >> 2] | 0;
      var $121 = HEAP16[$currentCommand_0 + 28 >> 1] & 65535;
      HEAP32[$buffer_0_ph$s2 + 3] = $121;
      HEAP32[$15$s2] = HEAP32[$15$s2] + $121 | 0;
      _enet_list_insert($18, $currentCommand_0);
      var $buffer_1 = $19;
    }
    var $buffer_1;
    var $currentCommand_0_ph = $101;
    var $command_0_ph = $command_0_ph + 48 | 0;
    var $buffer_0_ph = $buffer_1 + 8 | 0, $buffer_0_ph$s2 = $buffer_0_ph >> 2;
  }
  if (label == 1249) {
    HEAP32[$host + 60 >> 2] = 1;
  }
  HEAP32[$1 >> 2] = ($command_0_ph - $3 | 0) / 48 & -1;
  HEAP32[$5 >> 2] = $buffer_0_ph - $7 >> 3;
  if ((HEAP32[$peer + 36 >> 2] | 0) != 6) {
    return;
  }
  var $144 = $peer + 216 | 0;
  if ((HEAP32[$144 >> 2] | 0) != ($144 | 0)) {
    return;
  }
  if ((HEAP32[$10 >> 2] | 0) != ($9 | 0)) {
    return;
  }
  var $152 = $peer + 200 | 0;
  if ((HEAP32[$152 >> 2] | 0) != ($152 | 0)) {
    return;
  }
  _enet_peer_disconnect($peer, HEAP32[$peer + 376 >> 2]);
  return;
}
_enet_protocol_send_unreliable_outgoing_commands["X"] = 1;
function _enet_protocol_remove_sent_unreliable_commands($peer) {
  var $1 = $peer + 208 | 0;
  var $2 = $1 | 0;
  var $3 = HEAP32[$2 >> 2];
  if (($3 | 0) == ($1 | 0)) {
    return;
  } else {
    var $5 = $3;
  }
  while (1) {
    var $5;
    _enet_list_remove($5);
    var $8 = $5 + 80 | 0;
    var $9 = HEAP32[$8 >> 2];
    do {
      if (($9 | 0) != 0) {
        var $12 = $9 | 0;
        HEAP32[$12 >> 2] = HEAP32[$12 >> 2] - 1 | 0;
        var $15 = HEAP32[$8 >> 2];
        if ((HEAP32[$15 >> 2] | 0) != 0) {
          break;
        }
        _enet_packet_destroy($15);
      }
    } while (0);
    _enet_free($5);
    var $22 = HEAP32[$2 >> 2];
    if (($22 | 0) == ($1 | 0)) {
      break;
    } else {
      var $5 = $22;
    }
  }
  return;
}
function _enet_time_get() {
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var $timeVal = __stackBase__;
  _gettimeofday($timeVal, 0);
  var $10 = ((HEAP32[$timeVal + 4 >> 2] | 0) / 1e3 & -1) + HEAP32[$timeVal >> 2] * 1e3 - HEAP32[_timeBase >> 2] | 0;
  STACKTOP = __stackBase__;
  return $10;
}
function _enet_time_set($newTimeBase) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var $timeVal = __stackBase__;
  _gettimeofday($timeVal, 0);
  HEAP32[_timeBase >> 2] = HEAP32[$timeVal >> 2] * 1e3 - $newTimeBase + ((HEAP32[$timeVal + 4 >> 2] | 0) / 1e3 & -1) | 0;
  STACKTOP = __stackBase__;
  return;
}
function _enet_address_set_host($address, $name) {
  var $1 = _gethostbyname($name);
  do {
    if (($1 | 0) != 0) {
      if ((HEAP32[$1 + 8 >> 2] | 0) != 1) {
        break;
      }
      HEAP32[$address >> 2] = HEAP32[HEAP32[HEAP32[$1 + 16 >> 2] >> 2] >> 2];
      var $_0 = 0;
      var $_0;
      return $_0;
    }
  } while (0);
  var $_0 = ((_inet_aton($name, $address) | 0) == 0) << 31 >> 31;
  var $_0;
  return $_0;
}
function _enet_address_get_host_ip($address, $name, $nameLength) {
  var $3 = _inet_ntoa(HEAP32[$address >> 2]);
  if (($3 | 0) == 0) {
    var $_0 = -1;
    var $_0;
    return $_0;
  }
  _strncpy($name, $3, $nameLength);
  var $_0 = 0;
  var $_0;
  return $_0;
}
function _enet_address_get_host($address, $name, $nameLength) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 4;
  var $in = __stackBase__;
  HEAP32[$in >> 2] = HEAP32[$address >> 2];
  var $5 = _gethostbyaddr($in, 4, 1);
  if (($5 | 0) == 0) {
    var $_0 = _enet_address_get_host_ip($address, $name, $nameLength);
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  } else {
    _strncpy($name, HEAP32[$5 >> 2], $nameLength);
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
}
function _enet_socket_bind($socket, $address) {
  var $1$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 16;
  var $sin = __stackBase__;
  var $1$s2 = $sin >> 2;
  HEAP32[$1$s2] = 0;
  HEAP32[$1$s2 + 1] = 0;
  HEAP32[$1$s2 + 2] = 0;
  HEAP32[$1$s2 + 3] = 0;
  HEAP16[$sin >> 1] = 1;
  if (($address | 0) == 0) {
    HEAP16[$sin + 2 >> 1] = 0;
    HEAP32[$sin + 4 >> 2] = 0;
    var $16 = $sin;
    var $17 = _bind($socket, $16, 16);
    STACKTOP = __stackBase__;
    return $17;
  } else {
    HEAP16[$sin + 2 >> 1] = _htons(HEAP16[$address + 4 >> 1]);
    HEAP32[$sin + 4 >> 2] = HEAP32[$address >> 2];
    var $16 = $sin;
    var $17 = _bind($socket, $16, 16);
    STACKTOP = __stackBase__;
    return $17;
  }
}
function _enet_socket_listen($socket, $backlog) {
  return _listen($socket, ($backlog | 0) < 0 ? 128 : $backlog);
}
function _enet_socket_create($type) {
  return _socket(2, ($type | 0) == 2 ? 20 : 200, 0);
}
function _enet_socket_set_option($socket, $option, $value) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 4;
  var $1 = __stackBase__;
  HEAP32[$1 >> 2] = $value;
  if (($option | 0) == 2) {
    var $result_0 = _setsockopt($socket, 50, 6, $1, 4);
  } else if (($option | 0) == 7) {
    var $result_0 = _setsockopt($socket, 50, 2e3, $1, 4);
  } else if (($option | 0) == 3) {
    var $result_0 = _setsockopt($socket, 50, 60, $1, 4);
  } else if (($option | 0) == 5) {
    var $result_0 = _setsockopt($socket, 50, 30, $1, 4);
  } else if (($option | 0) == 6) {
    var $result_0 = _setsockopt($socket, 50, 1e3, $1, 4);
  } else if (($option | 0) == 4) {
    var $result_0 = _setsockopt($socket, 50, 40, $1, 4);
  } else {
    var $result_0 = -1;
  }
  var $result_0;
  STACKTOP = __stackBase__;
  return (($result_0 | 0) == -1) << 31 >> 31;
}
function _enet_socket_connect($socket, $address) {
  var $1$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 16;
  var $sin = __stackBase__;
  var $1$s2 = $sin >> 2;
  HEAP32[$1$s2] = 0;
  HEAP32[$1$s2 + 1] = 0;
  HEAP32[$1$s2 + 2] = 0;
  HEAP32[$1$s2 + 3] = 0;
  HEAP16[$sin >> 1] = 1;
  HEAP16[$sin + 2 >> 1] = _htons(HEAP16[$address + 4 >> 1]);
  HEAP32[$sin + 4 >> 2] = HEAP32[$address >> 2];
  var $11 = _connect($socket, $sin, 16);
  do {
    if (($11 | 0) == -1) {
      if ((HEAP32[___errno() >> 2] | 0) == 119) {
        var $_0 = 0;
      } else {
        break;
      }
      var $_0;
      STACKTOP = __stackBase__;
      return $_0;
    }
  } while (0);
  var $_0 = $11;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
function _enet_socket_accept($socket, $address) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 20;
  var $sin = __stackBase__;
  var $sinLength = __stackBase__ + 16;
  HEAP32[$sinLength >> 2] = 16;
  var $1 = ($address | 0) != 0;
  if ($1) {
    var $5 = $sin;
  } else {
    var $5 = 0;
  }
  var $5;
  var $6 = _accept($socket, $5, $1 ? $sinLength : 0);
  if (($6 | 0) == -1 | $1 ^ 1) {
    STACKTOP = __stackBase__;
    return $6;
  }
  HEAP32[$address >> 2] = HEAP32[$sin + 4 >> 2];
  HEAP16[$address + 4 >> 1] = _ntohs(HEAP16[$sin + 2 >> 1]);
  STACKTOP = __stackBase__;
  return $6;
}
function _enet_socket_shutdown($socket, $how) {
  return _shutdown($socket, $how);
}
function _enet_socket_destroy($socket) {
  if (($socket | 0) == -1) {
    return;
  }
  _close($socket);
  return;
}
function _enet_socket_send($socket, $address, $buffers, $bufferCount) {
  var $4$s2;
  var $1$s2;
  var $msgHdr$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 44;
  var $msgHdr = __stackBase__, $msgHdr$s2 = $msgHdr >> 2;
  var $sin = __stackBase__ + 28;
  var $1$s2 = $msgHdr >> 2;
  HEAP32[$1$s2] = 0;
  HEAP32[$1$s2 + 1] = 0;
  HEAP32[$1$s2 + 2] = 0;
  HEAP32[$1$s2 + 3] = 0;
  HEAP32[$1$s2 + 4] = 0;
  HEAP32[$1$s2 + 5] = 0;
  HEAP32[$1$s2 + 6] = 0;
  if (($address | 0) != 0) {
    var $4 = $sin, $4$s2 = $4 >> 2;
    HEAP32[$4$s2] = 0;
    HEAP32[$4$s2 + 1] = 0;
    HEAP32[$4$s2 + 2] = 0;
    HEAP32[$4$s2 + 3] = 0;
    HEAP16[$sin >> 1] = 1;
    HEAP16[$sin + 2 >> 1] = _htons(HEAP16[$address + 4 >> 1]);
    HEAP32[$sin + 4 >> 2] = HEAP32[$address >> 2];
    HEAP32[$msgHdr$s2] = $4;
    HEAP32[$msgHdr$s2 + 1] = 16;
  }
  HEAP32[$msgHdr$s2 + 2] = $buffers;
  HEAP32[$msgHdr$s2 + 3] = $bufferCount;
  var $19 = _sendmsg($socket, $msgHdr, 0);
  if (($19 | 0) != -1) {
    var $_0 = $19;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $_0 = ((HEAP32[___errno() >> 2] | 0) != 11) << 31 >> 31;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
function _enet_socket_receive($socket, $address, $buffers, $bufferCount) {
  var $1$s2;
  var $msgHdr$s2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 44;
  var $msgHdr = __stackBase__, $msgHdr$s2 = $msgHdr >> 2;
  var $sin = __stackBase__ + 28;
  var $1$s2 = $msgHdr >> 2;
  HEAP32[$1$s2] = 0;
  HEAP32[$1$s2 + 1] = 0;
  HEAP32[$1$s2 + 2] = 0;
  HEAP32[$1$s2 + 3] = 0;
  HEAP32[$1$s2 + 4] = 0;
  HEAP32[$1$s2 + 5] = 0;
  HEAP32[$1$s2 + 6] = 0;
  var $2 = ($address | 0) != 0;
  if ($2) {
    HEAP32[$msgHdr$s2] = $sin;
    HEAP32[$msgHdr$s2 + 1] = 16;
  }
  HEAP32[$msgHdr$s2 + 2] = $buffers;
  HEAP32[$msgHdr$s2 + 3] = $bufferCount;
  var $11 = _recvmsg($socket, $msgHdr, 0);
  if (($11 | 0) == -1) {
    var $_0 = ((HEAP32[___errno() >> 2] | 0) != 11) << 31 >> 31;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  if (!$2) {
    var $_0 = $11;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  HEAP32[$address >> 2] = HEAP32[$sin + 4 >> 2];
  HEAP16[$address + 4 >> 1] = _ntohs(HEAP16[$sin + 2 >> 1]);
  var $_0 = $11;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
function _enet_socketset_select($maxSocket, $readSet, $writeSet, $timeout) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 8;
  var $timeVal = __stackBase__;
  HEAP32[$timeVal >> 2] = Math.floor(($timeout >>> 0) / 1e3);
  HEAP32[$timeVal + 4 >> 2] = ($timeout >>> 0) % 1e3 * 1e3 | 0;
  var $8 = _select($maxSocket + 1 | 0, $readSet, $writeSet, 0, $timeVal);
  STACKTOP = __stackBase__;
  return $8;
}
function _enet_socket_wait($socket, $condition, $timeout) {
  var $condition$s2 = $condition >> 2;
  var __stackBase__ = STACKTOP;
  STACKTOP += 24;
  var $readSet = __stackBase__;
  var $writeSet = __stackBase__ + 8;
  var $timeVal = __stackBase__ + 16;
  HEAP32[$timeVal >> 2] = Math.floor(($timeout >>> 0) / 1e3);
  HEAP32[$timeVal + 4 >> 2] = ($timeout >>> 0) % 1e3 * 1e3 | 0;
  var $6 = $readSet;
  HEAP32[$6 >> 2] = 0;
  HEAP32[$6 + 4 >> 2] = 0;
  var $7 = $writeSet;
  HEAP32[$7 >> 2] = 0;
  HEAP32[$7 + 4 >> 2] = 0;
  if ((HEAP32[$condition$s2] & 1 | 0) != 0) {
    var $15 = ($socket >>> 5 << 2) + $writeSet | 0;
    HEAP32[$15 >> 2] = HEAP32[$15 >> 2] | 1 << ($socket & 31);
  }
  if ((HEAP32[$condition$s2] & 2 | 0) != 0) {
    var $26 = ($socket >>> 5 << 2) + $readSet | 0;
    HEAP32[$26 >> 2] = HEAP32[$26 >> 2] | 1 << ($socket & 31);
  }
  var $32 = _select($socket + 1 | 0, $readSet, $writeSet, 0, $timeVal);
  if (($32 | 0) < 0) {
    var $_0 = -1;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  HEAP32[$condition$s2] = 0;
  if (($32 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  var $37 = $socket >>> 5;
  var $41 = 1 << ($socket & 31);
  if ((HEAP32[$writeSet + ($37 << 2) >> 2] & $41 | 0) != 0) {
    HEAP32[$condition$s2] = 1;
  }
  if ((HEAP32[$readSet + ($37 << 2) >> 2] & $41 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    STACKTOP = __stackBase__;
    return $_0;
  }
  HEAP32[$condition$s2] = HEAP32[$condition$s2] | 2;
  var $_0 = 0;
  var $_0;
  STACKTOP = __stackBase__;
  return $_0;
}
_enet_socket_wait["X"] = 1;
function _malloc($bytes) {
  do {
    if ($bytes >>> 0 < 245) {
      if ($bytes >>> 0 < 11) {
        var $8 = 16;
      } else {
        var $8 = $bytes + 11 & -8;
      }
      var $8;
      var $9 = $8 >>> 3;
      var $10 = HEAP32[__gm_ >> 2];
      var $11 = $10 >>> ($9 >>> 0);
      if (($11 & 3 | 0) != 0) {
        var $17 = ($11 & 1 ^ 1) + $9 | 0;
        var $18 = $17 << 1;
        var $20 = ($18 << 2) + __gm_ + 40 | 0;
        var $21 = ($18 + 2 << 2) + __gm_ + 40 | 0;
        var $22 = HEAP32[$21 >> 2];
        var $23 = $22 + 8 | 0;
        var $24 = HEAP32[$23 >> 2];
        do {
          if (($20 | 0) == ($24 | 0)) {
            HEAP32[__gm_ >> 2] = $10 & (1 << $17 ^ -1);
          } else {
            if ($24 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
              _abort();
            } else {
              HEAP32[$21 >> 2] = $24;
              HEAP32[$24 + 12 >> 2] = $20;
              break;
            }
          }
        } while (0);
        var $38 = $17 << 3;
        HEAP32[$22 + 4 >> 2] = $38 | 3;
        var $43 = $22 + ($38 | 4) | 0;
        HEAP32[$43 >> 2] = HEAP32[$43 >> 2] | 1;
        var $mem_0 = $23;
        var $mem_0;
        return $mem_0;
      }
      if ($8 >>> 0 <= HEAP32[__gm_ + 8 >> 2] >>> 0) {
        var $nb_0 = $8;
        break;
      }
      if (($11 | 0) == 0) {
        if ((HEAP32[__gm_ + 4 >> 2] | 0) == 0) {
          var $nb_0 = $8;
          break;
        }
        var $146 = _tmalloc_small($8);
        if (($146 | 0) == 0) {
          var $nb_0 = $8;
          break;
        } else {
          var $mem_0 = $146;
        }
        var $mem_0;
        return $mem_0;
      }
      var $54 = 2 << $9;
      var $57 = $11 << $9 & ($54 | -$54);
      var $60 = ($57 & -$57) - 1 | 0;
      var $62 = $60 >>> 12 & 16;
      var $63 = $60 >>> ($62 >>> 0);
      var $65 = $63 >>> 5 & 8;
      var $66 = $63 >>> ($65 >>> 0);
      var $68 = $66 >>> 2 & 4;
      var $69 = $66 >>> ($68 >>> 0);
      var $71 = $69 >>> 1 & 2;
      var $72 = $69 >>> ($71 >>> 0);
      var $74 = $72 >>> 1 & 1;
      var $80 = ($65 | $62 | $68 | $71 | $74) + ($72 >>> ($74 >>> 0)) | 0;
      var $81 = $80 << 1;
      var $83 = ($81 << 2) + __gm_ + 40 | 0;
      var $84 = ($81 + 2 << 2) + __gm_ + 40 | 0;
      var $85 = HEAP32[$84 >> 2];
      var $86 = $85 + 8 | 0;
      var $87 = HEAP32[$86 >> 2];
      do {
        if (($83 | 0) == ($87 | 0)) {
          HEAP32[__gm_ >> 2] = $10 & (1 << $80 ^ -1);
        } else {
          if ($87 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          } else {
            HEAP32[$84 >> 2] = $87;
            HEAP32[$87 + 12 >> 2] = $83;
            break;
          }
        }
      } while (0);
      var $101 = $80 << 3;
      var $102 = $101 - $8 | 0;
      HEAP32[$85 + 4 >> 2] = $8 | 3;
      var $105 = $85;
      var $107 = $105 + $8 | 0;
      HEAP32[$105 + ($8 | 4) >> 2] = $102 | 1;
      HEAP32[$105 + $101 >> 2] = $102;
      var $113 = HEAP32[__gm_ + 8 >> 2];
      if (($113 | 0) != 0) {
        var $116 = HEAP32[__gm_ + 20 >> 2];
        var $119 = $113 >>> 2 & 1073741822;
        var $121 = ($119 << 2) + __gm_ + 40 | 0;
        var $122 = HEAP32[__gm_ >> 2];
        var $123 = 1 << ($113 >>> 3);
        do {
          if (($122 & $123 | 0) == 0) {
            HEAP32[__gm_ >> 2] = $122 | $123;
            var $F4_0 = $121;
          } else {
            var $130 = HEAP32[__gm_ + ($119 + 2 << 2) + 40 >> 2];
            if ($130 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
              var $F4_0 = $130;
              break;
            }
            _abort();
          }
        } while (0);
        var $F4_0;
        HEAP32[__gm_ + ($119 + 2 << 2) + 40 >> 2] = $116;
        HEAP32[$F4_0 + 12 >> 2] = $116;
        HEAP32[$116 + 8 >> 2] = $F4_0;
        HEAP32[$116 + 12 >> 2] = $121;
      }
      HEAP32[__gm_ + 8 >> 2] = $102;
      HEAP32[__gm_ + 20 >> 2] = $107;
      var $mem_0 = $86;
      var $mem_0;
      return $mem_0;
    } else {
      if ($bytes >>> 0 > 4294967231) {
        var $nb_0 = -1;
        break;
      }
      var $152 = $bytes + 11 & -8;
      if ((HEAP32[__gm_ + 4 >> 2] | 0) == 0) {
        var $nb_0 = $152;
        break;
      }
      var $156 = _tmalloc_large($152);
      if (($156 | 0) == 0) {
        var $nb_0 = $152;
        break;
      } else {
        var $mem_0 = $156;
      }
      var $mem_0;
      return $mem_0;
    }
  } while (0);
  var $nb_0;
  var $159 = HEAP32[__gm_ + 8 >> 2];
  if ($nb_0 >>> 0 > $159 >>> 0) {
    var $188 = HEAP32[__gm_ + 12 >> 2];
    if ($nb_0 >>> 0 < $188 >>> 0) {
      var $191 = $188 - $nb_0 | 0;
      HEAP32[__gm_ + 12 >> 2] = $191;
      var $192 = HEAP32[__gm_ + 24 >> 2];
      var $193 = $192;
      HEAP32[__gm_ + 24 >> 2] = $193 + $nb_0 | 0;
      HEAP32[$nb_0 + ($193 + 4) >> 2] = $191 | 1;
      HEAP32[$192 + 4 >> 2] = $nb_0 | 3;
      var $mem_0 = $192 + 8 | 0;
      var $mem_0;
      return $mem_0;
    } else {
      var $mem_0 = _sys_alloc($nb_0);
      var $mem_0;
      return $mem_0;
    }
  } else {
    var $162 = $159 - $nb_0 | 0;
    var $163 = HEAP32[__gm_ + 20 >> 2];
    if ($162 >>> 0 > 15) {
      var $166 = $163;
      HEAP32[__gm_ + 20 >> 2] = $166 + $nb_0 | 0;
      HEAP32[__gm_ + 8 >> 2] = $162;
      HEAP32[$nb_0 + ($166 + 4) >> 2] = $162 | 1;
      HEAP32[$166 + $159 >> 2] = $162;
      HEAP32[$163 + 4 >> 2] = $nb_0 | 3;
    } else {
      HEAP32[__gm_ + 8 >> 2] = 0;
      HEAP32[__gm_ + 20 >> 2] = 0;
      HEAP32[$163 + 4 >> 2] = $159 | 3;
      var $181 = $159 + ($163 + 4) | 0;
      HEAP32[$181 >> 2] = HEAP32[$181 >> 2] | 1;
    }
    var $mem_0 = $163 + 8 | 0;
    var $mem_0;
    return $mem_0;
  }
}
Module["_malloc"] = _malloc;
_malloc["X"] = 1;
function _tmalloc_small($nb) {
  var $R_1$s2;
  var $v_0$s2;
  var $1 = HEAP32[__gm_ + 4 >> 2];
  var $4 = ($1 & -$1) - 1 | 0;
  var $6 = $4 >>> 12 & 16;
  var $7 = $4 >>> ($6 >>> 0);
  var $9 = $7 >>> 5 & 8;
  var $10 = $7 >>> ($9 >>> 0);
  var $12 = $10 >>> 2 & 4;
  var $13 = $10 >>> ($12 >>> 0);
  var $15 = $13 >>> 1 & 2;
  var $16 = $13 >>> ($15 >>> 0);
  var $18 = $16 >>> 1 & 1;
  var $26 = HEAP32[__gm_ + (($9 | $6 | $12 | $15 | $18) + ($16 >>> ($18 >>> 0)) << 2) + 304 >> 2];
  var $t_0 = $26;
  var $v_0 = $26, $v_0$s2 = $v_0 >> 2;
  var $rsize_0 = (HEAP32[$26 + 4 >> 2] & -8) - $nb | 0;
  while (1) {
    var $rsize_0;
    var $v_0;
    var $t_0;
    var $33 = HEAP32[$t_0 + 16 >> 2];
    if (($33 | 0) == 0) {
      var $37 = HEAP32[$t_0 + 20 >> 2];
      if (($37 | 0) == 0) {
        break;
      } else {
        var $39 = $37;
      }
    } else {
      var $39 = $33;
    }
    var $39;
    var $43 = (HEAP32[$39 + 4 >> 2] & -8) - $nb | 0;
    var $44 = $43 >>> 0 < $rsize_0 >>> 0;
    var $t_0 = $39;
    var $v_0 = $44 ? $39 : $v_0, $v_0$s2 = $v_0 >> 2;
    var $rsize_0 = $44 ? $43 : $rsize_0;
  }
  var $46 = $v_0;
  var $47 = HEAP32[__gm_ + 16 >> 2];
  if ($46 >>> 0 < $47 >>> 0) {
    _abort();
  }
  var $50 = $46 + $nb | 0;
  var $51 = $50;
  if ($46 >>> 0 >= $50 >>> 0) {
    _abort();
  }
  var $55 = HEAP32[$v_0$s2 + 6];
  var $57 = HEAP32[$v_0$s2 + 3];
  var $58 = ($57 | 0) == ($v_0 | 0);
  L1830 : do {
    if ($58) {
      var $69 = $v_0 + 20 | 0;
      var $70 = HEAP32[$69 >> 2];
      do {
        if (($70 | 0) == 0) {
          var $73 = $v_0 + 16 | 0;
          var $74 = HEAP32[$73 >> 2];
          if (($74 | 0) == 0) {
            var $R_1 = 0, $R_1$s2 = $R_1 >> 2;
            break L1830;
          } else {
            var $RP_0 = $73;
            var $R_0 = $74;
            break;
          }
        } else {
          var $RP_0 = $69;
          var $R_0 = $70;
        }
      } while (0);
      while (1) {
        var $R_0;
        var $RP_0;
        var $76 = $R_0 + 20 | 0;
        if ((HEAP32[$76 >> 2] | 0) == 0) {
          var $80 = $R_0 + 16 | 0;
          if ((HEAP32[$80 >> 2] | 0) == 0) {
            break;
          } else {
            var $CP_0 = $80;
          }
        } else {
          var $CP_0 = $76;
        }
        var $CP_0;
        var $RP_0 = $CP_0;
        var $R_0 = HEAP32[$CP_0 >> 2];
      }
      if ($RP_0 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      } else {
        HEAP32[$RP_0 >> 2] = 0;
        var $R_1 = $R_0, $R_1$s2 = $R_1 >> 2;
        break;
      }
    } else {
      var $61 = HEAP32[$v_0$s2 + 2];
      if ($61 >>> 0 < $47 >>> 0) {
        _abort();
      } else {
        HEAP32[$61 + 12 >> 2] = $57;
        HEAP32[$57 + 8 >> 2] = $61;
        var $R_1 = $57, $R_1$s2 = $R_1 >> 2;
        break;
      }
    }
  } while (0);
  var $R_1;
  var $91 = ($55 | 0) == 0;
  L1848 : do {
    if (!$91) {
      var $93 = $v_0 + 28 | 0;
      var $95 = (HEAP32[$93 >> 2] << 2) + __gm_ + 304 | 0;
      do {
        if (($v_0 | 0) == (HEAP32[$95 >> 2] | 0)) {
          HEAP32[$95 >> 2] = $R_1;
          if (($R_1 | 0) != 0) {
            break;
          }
          HEAP32[__gm_ + 4 >> 2] = HEAP32[__gm_ + 4 >> 2] & (1 << HEAP32[$93 >> 2] ^ -1);
          break L1848;
        } else {
          if ($55 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          }
          var $109 = $55 + 16 | 0;
          if ((HEAP32[$109 >> 2] | 0) == ($v_0 | 0)) {
            HEAP32[$109 >> 2] = $R_1;
          } else {
            HEAP32[$55 + 20 >> 2] = $R_1;
          }
          if (($R_1 | 0) == 0) {
            break L1848;
          }
        }
      } while (0);
      if ($R_1 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      }
      HEAP32[$R_1$s2 + 6] = $55;
      var $125 = HEAP32[$v_0$s2 + 4];
      do {
        if (($125 | 0) != 0) {
          if ($125 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          } else {
            HEAP32[$R_1$s2 + 4] = $125;
            HEAP32[$125 + 24 >> 2] = $R_1;
            break;
          }
        }
      } while (0);
      var $137 = HEAP32[$v_0$s2 + 5];
      if (($137 | 0) == 0) {
        break;
      }
      if ($137 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      } else {
        HEAP32[$R_1$s2 + 5] = $137;
        HEAP32[$137 + 24 >> 2] = $R_1;
        break;
      }
    }
  } while (0);
  if ($rsize_0 >>> 0 < 16) {
    var $151 = $rsize_0 + $nb | 0;
    HEAP32[$v_0$s2 + 1] = $151 | 3;
    var $155 = $151 + ($46 + 4) | 0;
    HEAP32[$155 >> 2] = HEAP32[$155 >> 2] | 1;
    var $195 = $v_0 + 8 | 0;
    var $196 = $195;
    return $196;
  }
  HEAP32[$v_0$s2 + 1] = $nb | 3;
  HEAP32[$nb + ($46 + 4) >> 2] = $rsize_0 | 1;
  HEAP32[$46 + $rsize_0 + $nb >> 2] = $rsize_0;
  var $166 = HEAP32[__gm_ + 8 >> 2];
  if (($166 | 0) != 0) {
    var $169 = HEAP32[__gm_ + 20 >> 2];
    var $172 = $166 >>> 2 & 1073741822;
    var $174 = ($172 << 2) + __gm_ + 40 | 0;
    var $175 = HEAP32[__gm_ >> 2];
    var $176 = 1 << ($166 >>> 3);
    do {
      if (($175 & $176 | 0) == 0) {
        HEAP32[__gm_ >> 2] = $175 | $176;
        var $F1_0 = $174;
      } else {
        var $183 = HEAP32[__gm_ + ($172 + 2 << 2) + 40 >> 2];
        if ($183 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
          var $F1_0 = $183;
          break;
        }
        _abort();
      }
    } while (0);
    var $F1_0;
    HEAP32[__gm_ + ($172 + 2 << 2) + 40 >> 2] = $169;
    HEAP32[$F1_0 + 12 >> 2] = $169;
    HEAP32[$169 + 8 >> 2] = $F1_0;
    HEAP32[$169 + 12 >> 2] = $174;
  }
  HEAP32[__gm_ + 8 >> 2] = $rsize_0;
  HEAP32[__gm_ + 20 >> 2] = $51;
  var $195 = $v_0 + 8 | 0;
  var $196 = $195;
  return $196;
}
_tmalloc_small["X"] = 1;
function _sys_alloc($nb) {
  var $sp_0$s2;
  var label;
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  var $7 = (HEAP32[__gm_ + 440 >> 2] & 4 | 0) == 0;
  L1893 : do {
    if ($7) {
      var $9 = HEAP32[__gm_ + 24 >> 2];
      do {
        if (($9 | 0) == 0) {
          label = 1474;
        } else {
          var $13 = _segment_holding($9);
          if (($13 | 0) == 0) {
            label = 1474;
            break;
          }
          var $41 = HEAP32[_mparams + 8 >> 2];
          var $46 = $nb + 47 - HEAP32[__gm_ + 12 >> 2] + $41 & -$41;
          if ($46 >>> 0 >= 2147483647) {
            var $tsize_0121720_ph = 0;
            break;
          }
          var $49 = _sbrk($46);
          var $55 = ($49 | 0) == (HEAP32[$13 >> 2] + HEAP32[$13 + 4 >> 2] | 0);
          var $tbase_0 = $55 ? $49 : -1;
          var $tsize_0 = $55 ? $46 : 0;
          var $asize_1 = $46;
          var $br_0 = $49;
          label = 1481;
          break;
        }
      } while (0);
      do {
        if (label == 1474) {
          var $15 = _sbrk(0);
          if (($15 | 0) == -1) {
            var $tsize_0121720_ph = 0;
            break;
          }
          var $18 = HEAP32[_mparams + 8 >> 2];
          var $22 = $18 + ($nb + 47) & -$18;
          var $23 = $15;
          var $24 = HEAP32[_mparams + 4 >> 2];
          var $25 = $24 - 1 | 0;
          if (($25 & $23 | 0) == 0) {
            var $asize_0 = $22;
          } else {
            var $asize_0 = $22 - $23 + ($25 + $23 & -$24) | 0;
          }
          var $asize_0;
          if ($asize_0 >>> 0 >= 2147483647) {
            var $tsize_0121720_ph = 0;
            break;
          }
          var $37 = _sbrk($asize_0);
          var $38 = ($37 | 0) == ($15 | 0);
          var $tbase_0 = $38 ? $15 : -1;
          var $tsize_0 = $38 ? $asize_0 : 0;
          var $asize_1 = $asize_0;
          var $br_0 = $37;
          label = 1481;
          break;
        }
      } while (0);
      L1906 : do {
        if (label == 1481) {
          var $br_0;
          var $asize_1;
          var $tsize_0;
          var $tbase_0;
          var $57 = -$asize_1 | 0;
          if (($tbase_0 | 0) != -1) {
            var $tsize_229 = $tsize_0;
            var $tbase_230 = $tbase_0;
            label = 1494;
            break L1893;
          }
          do {
            if (($br_0 | 0) != -1 & $asize_1 >>> 0 < 2147483647) {
              if ($asize_1 >>> 0 >= ($nb + 48 | 0) >>> 0) {
                var $asize_2 = $asize_1;
                break;
              }
              var $66 = HEAP32[_mparams + 8 >> 2];
              var $71 = $nb + 47 - $asize_1 + $66 & -$66;
              if ($71 >>> 0 >= 2147483647) {
                var $asize_2 = $asize_1;
                break;
              }
              if ((_sbrk($71) | 0) == -1) {
                _sbrk($57);
                var $tsize_0121720_ph = $tsize_0;
                break L1906;
              } else {
                var $asize_2 = $71 + $asize_1 | 0;
                break;
              }
            } else {
              var $asize_2 = $asize_1;
            }
          } while (0);
          var $asize_2;
          if (($br_0 | 0) != -1) {
            var $tsize_229 = $asize_2;
            var $tbase_230 = $br_0;
            label = 1494;
            break L1893;
          }
          HEAP32[__gm_ + 440 >> 2] = HEAP32[__gm_ + 440 >> 2] | 4;
          var $tsize_125 = $tsize_0;
          label = 1491;
          break L1893;
        }
      } while (0);
      var $tsize_0121720_ph;
      HEAP32[__gm_ + 440 >> 2] = HEAP32[__gm_ + 440 >> 2] | 4;
      var $tsize_125 = $tsize_0121720_ph;
      label = 1491;
      break;
    } else {
      var $tsize_125 = 0;
      label = 1491;
    }
  } while (0);
  do {
    if (label == 1491) {
      var $tsize_125;
      var $86 = HEAP32[_mparams + 8 >> 2];
      var $90 = $86 + ($nb + 47) & -$86;
      if ($90 >>> 0 >= 2147483647) {
        break;
      }
      var $93 = _sbrk($90);
      var $94 = _sbrk(0);
      if (!(($94 | 0) != -1 & ($93 | 0) != -1 & $93 >>> 0 < $94 >>> 0)) {
        break;
      }
      var $98 = $94 - $93 | 0;
      var $100 = $98 >>> 0 > ($nb + 40 | 0) >>> 0;
      var $_tbase_1 = $100 ? $93 : -1;
      if (($_tbase_1 | 0) == -1) {
        break;
      } else {
        var $tsize_229 = $100 ? $98 : $tsize_125;
        var $tbase_230 = $_tbase_1;
        label = 1494;
        break;
      }
    }
  } while (0);
  do {
    if (label == 1494) {
      var $tbase_230;
      var $tsize_229;
      var $103 = HEAP32[__gm_ + 432 >> 2] + $tsize_229 | 0;
      HEAP32[__gm_ + 432 >> 2] = $103;
      if ($103 >>> 0 > HEAP32[__gm_ + 436 >> 2] >>> 0) {
        HEAP32[__gm_ + 436 >> 2] = $103;
      }
      var $109 = (HEAP32[__gm_ + 24 >> 2] | 0) == 0;
      L1928 : do {
        if ($109) {
          var $111 = HEAP32[__gm_ + 16 >> 2];
          if (($111 | 0) == 0 | $tbase_230 >>> 0 < $111 >>> 0) {
            HEAP32[__gm_ + 16 >> 2] = $tbase_230;
          }
          HEAP32[__gm_ + 444 >> 2] = $tbase_230;
          HEAP32[__gm_ + 448 >> 2] = $tsize_229;
          HEAP32[__gm_ + 456 >> 2] = 0;
          HEAP32[__gm_ + 36 >> 2] = HEAP32[_mparams >> 2];
          HEAP32[__gm_ + 32 >> 2] = -1;
          _init_bins();
          _init_top($tbase_230, $tsize_229 - 40 | 0);
        } else {
          var $sp_0 = __gm_ + 444 | 0, $sp_0$s2 = $sp_0 >> 2;
          while (1) {
            var $sp_0;
            if (($sp_0 | 0) == 0) {
              break;
            }
            var $122 = HEAP32[$sp_0$s2];
            var $123 = $sp_0 + 4 | 0;
            var $124 = HEAP32[$123 >> 2];
            var $125 = $122 + $124 | 0;
            if (($tbase_230 | 0) == ($125 | 0)) {
              label = 1503;
              break;
            }
            var $sp_0 = HEAP32[$sp_0$s2 + 2], $sp_0$s2 = $sp_0 >> 2;
          }
          do {
            if (label == 1503) {
              if ((HEAP32[$sp_0$s2 + 3] & 8 | 0) != 0) {
                break;
              }
              var $136 = HEAP32[__gm_ + 24 >> 2];
              if (!($136 >>> 0 >= $122 >>> 0 & $136 >>> 0 < $125 >>> 0)) {
                break;
              }
              HEAP32[$123 >> 2] = $124 + $tsize_229 | 0;
              _init_top(HEAP32[__gm_ + 24 >> 2], HEAP32[__gm_ + 12 >> 2] + $tsize_229 | 0);
              break L1928;
            }
          } while (0);
          if ($tbase_230 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            HEAP32[__gm_ + 16 >> 2] = $tbase_230;
          }
          var $147 = $tbase_230 + $tsize_229 | 0;
          var $sp_1 = __gm_ + 444 | 0;
          while (1) {
            var $sp_1;
            if (($sp_1 | 0) == 0) {
              break;
            }
            var $151 = $sp_1 | 0;
            var $152 = HEAP32[$151 >> 2];
            if (($152 | 0) == ($147 | 0)) {
              label = 1512;
              break;
            }
            var $sp_1 = HEAP32[$sp_1 + 8 >> 2];
          }
          do {
            if (label == 1512) {
              if ((HEAP32[$sp_1 + 12 >> 2] & 8 | 0) != 0) {
                break;
              }
              HEAP32[$151 >> 2] = $tbase_230;
              var $162 = $sp_1 + 4 | 0;
              HEAP32[$162 >> 2] = HEAP32[$162 >> 2] + $tsize_229 | 0;
              var $_0 = _prepend_alloc($tbase_230, $152, $nb);
              var $_0;
              return $_0;
            }
          } while (0);
          _add_segment($tbase_230, $tsize_229);
        }
      } while (0);
      var $167 = HEAP32[__gm_ + 12 >> 2];
      if ($167 >>> 0 <= $nb >>> 0) {
        break;
      }
      var $170 = $167 - $nb | 0;
      HEAP32[__gm_ + 12 >> 2] = $170;
      var $171 = HEAP32[__gm_ + 24 >> 2];
      var $172 = $171;
      HEAP32[__gm_ + 24 >> 2] = $172 + $nb | 0;
      HEAP32[$nb + ($172 + 4) >> 2] = $170 | 1;
      HEAP32[$171 + 4 >> 2] = $nb | 3;
      var $_0 = $171 + 8 | 0;
      var $_0;
      return $_0;
    }
  } while (0);
  HEAP32[___errno() >> 2] = 12;
  var $_0 = 0;
  var $_0;
  return $_0;
}
_sys_alloc["X"] = 1;
function _tmalloc_large($nb) {
  var $R_1$s2;
  var $112$s2;
  var $t_224$s2;
  var $v_3_lcssa$s2;
  var $t_0$s2;
  var $nb$s2 = $nb >> 2;
  var label;
  var $1 = -$nb | 0;
  var $2 = $nb >>> 8;
  do {
    if (($2 | 0) == 0) {
      var $idx_0 = 0;
    } else {
      if ($nb >>> 0 > 16777215) {
        var $idx_0 = 31;
        break;
      }
      var $9 = ($2 + 1048320 | 0) >>> 16 & 8;
      var $10 = $2 << $9;
      var $13 = ($10 + 520192 | 0) >>> 16 & 4;
      var $14 = $10 << $13;
      var $17 = ($14 + 245760 | 0) >>> 16 & 2;
      var $23 = 14 - ($13 | $9 | $17) + ($14 << $17 >>> 15) | 0;
      var $idx_0 = $nb >>> (($23 + 7 | 0) >>> 0) & 1 | $23 << 1;
    }
  } while (0);
  var $idx_0;
  var $31 = HEAP32[__gm_ + ($idx_0 << 2) + 304 >> 2];
  var $32 = ($31 | 0) == 0;
  L1964 : do {
    if ($32) {
      var $v_2 = 0;
      var $rsize_2 = $1;
      var $t_1 = 0;
    } else {
      if (($idx_0 | 0) == 31) {
        var $39 = 0;
      } else {
        var $39 = 25 - ($idx_0 >>> 1) | 0;
      }
      var $39;
      var $v_0 = 0;
      var $rsize_0 = $1;
      var $t_0 = $31, $t_0$s2 = $t_0 >> 2;
      var $sizebits_0 = $nb << $39;
      var $rst_0 = 0;
      while (1) {
        var $rst_0;
        var $sizebits_0;
        var $t_0;
        var $rsize_0;
        var $v_0;
        var $44 = HEAP32[$t_0$s2 + 1] & -8;
        var $45 = $44 - $nb | 0;
        if ($45 >>> 0 < $rsize_0 >>> 0) {
          if (($44 | 0) == ($nb | 0)) {
            var $v_2 = $t_0;
            var $rsize_2 = $45;
            var $t_1 = $t_0;
            break L1964;
          } else {
            var $v_1 = $t_0;
            var $rsize_1 = $45;
          }
        } else {
          var $v_1 = $v_0;
          var $rsize_1 = $rsize_0;
        }
        var $rsize_1;
        var $v_1;
        var $51 = HEAP32[$t_0$s2 + 5];
        var $54 = HEAP32[(($sizebits_0 >>> 31 << 2) + 16 >> 2) + $t_0$s2];
        var $rst_1 = ($51 | 0) == 0 | ($51 | 0) == ($54 | 0) ? $rst_0 : $51;
        if (($54 | 0) == 0) {
          var $v_2 = $v_1;
          var $rsize_2 = $rsize_1;
          var $t_1 = $rst_1;
          break L1964;
        } else {
          var $v_0 = $v_1;
          var $rsize_0 = $rsize_1;
          var $t_0 = $54, $t_0$s2 = $t_0 >> 2;
          var $sizebits_0 = $sizebits_0 << 1;
          var $rst_0 = $rst_1;
        }
      }
    }
  } while (0);
  var $t_1;
  var $rsize_2;
  var $v_2;
  do {
    if (($t_1 | 0) == 0 & ($v_2 | 0) == 0) {
      var $62 = 2 << $idx_0;
      var $66 = HEAP32[__gm_ + 4 >> 2] & ($62 | -$62);
      if (($66 | 0) == 0) {
        var $t_2_ph = $t_1;
        break;
      }
      var $71 = ($66 & -$66) - 1 | 0;
      var $73 = $71 >>> 12 & 16;
      var $74 = $71 >>> ($73 >>> 0);
      var $76 = $74 >>> 5 & 8;
      var $77 = $74 >>> ($76 >>> 0);
      var $79 = $77 >>> 2 & 4;
      var $80 = $77 >>> ($79 >>> 0);
      var $82 = $80 >>> 1 & 2;
      var $83 = $80 >>> ($82 >>> 0);
      var $85 = $83 >>> 1 & 1;
      var $t_2_ph = HEAP32[__gm_ + (($76 | $73 | $79 | $82 | $85) + ($83 >>> ($85 >>> 0)) << 2) + 304 >> 2];
    } else {
      var $t_2_ph = $t_1;
    }
  } while (0);
  var $t_2_ph;
  var $94 = ($t_2_ph | 0) == 0;
  L1979 : do {
    if ($94) {
      var $rsize_3_lcssa = $rsize_2;
      var $v_3_lcssa = $v_2, $v_3_lcssa$s2 = $v_3_lcssa >> 2;
    } else {
      var $t_224 = $t_2_ph, $t_224$s2 = $t_224 >> 2;
      var $rsize_325 = $rsize_2;
      var $v_326 = $v_2;
      while (1) {
        var $v_326;
        var $rsize_325;
        var $t_224;
        var $98 = (HEAP32[$t_224$s2 + 1] & -8) - $nb | 0;
        var $99 = $98 >>> 0 < $rsize_325 >>> 0;
        var $_rsize_3 = $99 ? $98 : $rsize_325;
        var $t_2_v_3 = $99 ? $t_224 : $v_326;
        var $101 = HEAP32[$t_224$s2 + 4];
        if (($101 | 0) != 0) {
          var $t_224 = $101, $t_224$s2 = $t_224 >> 2;
          var $rsize_325 = $_rsize_3;
          var $v_326 = $t_2_v_3;
          continue;
        }
        var $104 = HEAP32[$t_224$s2 + 5];
        if (($104 | 0) == 0) {
          var $rsize_3_lcssa = $_rsize_3;
          var $v_3_lcssa = $t_2_v_3, $v_3_lcssa$s2 = $v_3_lcssa >> 2;
          break L1979;
        } else {
          var $t_224 = $104, $t_224$s2 = $t_224 >> 2;
          var $rsize_325 = $_rsize_3;
          var $v_326 = $t_2_v_3;
        }
      }
    }
  } while (0);
  var $v_3_lcssa;
  var $rsize_3_lcssa;
  if (($v_3_lcssa | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  if ($rsize_3_lcssa >>> 0 >= (HEAP32[__gm_ + 8 >> 2] - $nb | 0) >>> 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $112 = $v_3_lcssa, $112$s2 = $112 >> 2;
  var $113 = HEAP32[__gm_ + 16 >> 2];
  if ($112 >>> 0 < $113 >>> 0) {
    _abort();
  }
  var $116 = $112 + $nb | 0;
  var $117 = $116;
  if ($112 >>> 0 >= $116 >>> 0) {
    _abort();
  }
  var $121 = HEAP32[$v_3_lcssa$s2 + 6];
  var $123 = HEAP32[$v_3_lcssa$s2 + 3];
  var $124 = ($123 | 0) == ($v_3_lcssa | 0);
  L1996 : do {
    if ($124) {
      var $135 = $v_3_lcssa + 20 | 0;
      var $136 = HEAP32[$135 >> 2];
      do {
        if (($136 | 0) == 0) {
          var $139 = $v_3_lcssa + 16 | 0;
          var $140 = HEAP32[$139 >> 2];
          if (($140 | 0) == 0) {
            var $R_1 = 0, $R_1$s2 = $R_1 >> 2;
            break L1996;
          } else {
            var $RP_0 = $139;
            var $R_0 = $140;
            break;
          }
        } else {
          var $RP_0 = $135;
          var $R_0 = $136;
        }
      } while (0);
      while (1) {
        var $R_0;
        var $RP_0;
        var $142 = $R_0 + 20 | 0;
        if ((HEAP32[$142 >> 2] | 0) == 0) {
          var $146 = $R_0 + 16 | 0;
          if ((HEAP32[$146 >> 2] | 0) == 0) {
            break;
          } else {
            var $CP_0 = $146;
          }
        } else {
          var $CP_0 = $142;
        }
        var $CP_0;
        var $RP_0 = $CP_0;
        var $R_0 = HEAP32[$CP_0 >> 2];
      }
      if ($RP_0 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      } else {
        HEAP32[$RP_0 >> 2] = 0;
        var $R_1 = $R_0, $R_1$s2 = $R_1 >> 2;
        break;
      }
    } else {
      var $127 = HEAP32[$v_3_lcssa$s2 + 2];
      if ($127 >>> 0 < $113 >>> 0) {
        _abort();
      } else {
        HEAP32[$127 + 12 >> 2] = $123;
        HEAP32[$123 + 8 >> 2] = $127;
        var $R_1 = $123, $R_1$s2 = $R_1 >> 2;
        break;
      }
    }
  } while (0);
  var $R_1;
  var $157 = ($121 | 0) == 0;
  L2014 : do {
    if (!$157) {
      var $159 = $v_3_lcssa + 28 | 0;
      var $161 = (HEAP32[$159 >> 2] << 2) + __gm_ + 304 | 0;
      do {
        if (($v_3_lcssa | 0) == (HEAP32[$161 >> 2] | 0)) {
          HEAP32[$161 >> 2] = $R_1;
          if (($R_1 | 0) != 0) {
            break;
          }
          HEAP32[__gm_ + 4 >> 2] = HEAP32[__gm_ + 4 >> 2] & (1 << HEAP32[$159 >> 2] ^ -1);
          break L2014;
        } else {
          if ($121 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          }
          var $175 = $121 + 16 | 0;
          if ((HEAP32[$175 >> 2] | 0) == ($v_3_lcssa | 0)) {
            HEAP32[$175 >> 2] = $R_1;
          } else {
            HEAP32[$121 + 20 >> 2] = $R_1;
          }
          if (($R_1 | 0) == 0) {
            break L2014;
          }
        }
      } while (0);
      if ($R_1 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      }
      HEAP32[$R_1$s2 + 6] = $121;
      var $191 = HEAP32[$v_3_lcssa$s2 + 4];
      do {
        if (($191 | 0) != 0) {
          if ($191 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          } else {
            HEAP32[$R_1$s2 + 4] = $191;
            HEAP32[$191 + 24 >> 2] = $R_1;
            break;
          }
        }
      } while (0);
      var $203 = HEAP32[$v_3_lcssa$s2 + 5];
      if (($203 | 0) == 0) {
        break;
      }
      if ($203 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      } else {
        HEAP32[$R_1$s2 + 5] = $203;
        HEAP32[$203 + 24 >> 2] = $R_1;
        break;
      }
    }
  } while (0);
  do {
    if ($rsize_3_lcssa >>> 0 < 16) {
      var $217 = $rsize_3_lcssa + $nb | 0;
      HEAP32[$v_3_lcssa$s2 + 1] = $217 | 3;
      var $221 = $217 + ($112 + 4) | 0;
      HEAP32[$221 >> 2] = HEAP32[$221 >> 2] | 1;
    } else {
      HEAP32[$v_3_lcssa$s2 + 1] = $nb | 3;
      HEAP32[$nb$s2 + ($112$s2 + 1)] = $rsize_3_lcssa | 1;
      HEAP32[($rsize_3_lcssa >> 2) + $112$s2 + $nb$s2] = $rsize_3_lcssa;
      if ($rsize_3_lcssa >>> 0 < 256) {
        var $236 = $rsize_3_lcssa >>> 2 & 1073741822;
        var $238 = ($236 << 2) + __gm_ + 40 | 0;
        var $239 = HEAP32[__gm_ >> 2];
        var $240 = 1 << ($rsize_3_lcssa >>> 3);
        do {
          if (($239 & $240 | 0) == 0) {
            HEAP32[__gm_ >> 2] = $239 | $240;
            var $F5_0 = $238;
          } else {
            var $247 = HEAP32[__gm_ + ($236 + 2 << 2) + 40 >> 2];
            if ($247 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
              var $F5_0 = $247;
              break;
            }
            _abort();
          }
        } while (0);
        var $F5_0;
        HEAP32[__gm_ + ($236 + 2 << 2) + 40 >> 2] = $117;
        HEAP32[$F5_0 + 12 >> 2] = $117;
        HEAP32[$nb$s2 + ($112$s2 + 2)] = $F5_0;
        HEAP32[$nb$s2 + ($112$s2 + 3)] = $238;
        break;
      }
      var $260 = $116;
      var $261 = $rsize_3_lcssa >>> 8;
      do {
        if (($261 | 0) == 0) {
          var $I7_0 = 0;
        } else {
          if ($rsize_3_lcssa >>> 0 > 16777215) {
            var $I7_0 = 31;
            break;
          }
          var $268 = ($261 + 1048320 | 0) >>> 16 & 8;
          var $269 = $261 << $268;
          var $272 = ($269 + 520192 | 0) >>> 16 & 4;
          var $273 = $269 << $272;
          var $276 = ($273 + 245760 | 0) >>> 16 & 2;
          var $282 = 14 - ($272 | $268 | $276) + ($273 << $276 >>> 15) | 0;
          var $I7_0 = $rsize_3_lcssa >>> (($282 + 7 | 0) >>> 0) & 1 | $282 << 1;
        }
      } while (0);
      var $I7_0;
      var $289 = ($I7_0 << 2) + __gm_ + 304 | 0;
      HEAP32[$nb$s2 + ($112$s2 + 7)] = $I7_0;
      HEAP32[$nb$s2 + ($112$s2 + 5)] = 0;
      HEAP32[$nb$s2 + ($112$s2 + 4)] = 0;
      var $296 = HEAP32[__gm_ + 4 >> 2];
      var $297 = 1 << $I7_0;
      if (($296 & $297 | 0) == 0) {
        HEAP32[__gm_ + 4 >> 2] = $296 | $297;
        HEAP32[$289 >> 2] = $260;
        HEAP32[$nb$s2 + ($112$s2 + 6)] = $289;
        HEAP32[$nb$s2 + ($112$s2 + 3)] = $260;
        HEAP32[$nb$s2 + ($112$s2 + 2)] = $260;
        break;
      }
      if (($I7_0 | 0) == 31) {
        var $316 = 0;
      } else {
        var $316 = 25 - ($I7_0 >>> 1) | 0;
      }
      var $316;
      var $K12_0 = $rsize_3_lcssa << $316;
      var $T_0 = HEAP32[$289 >> 2];
      while (1) {
        var $T_0;
        var $K12_0;
        if ((HEAP32[$T_0 + 4 >> 2] & -8 | 0) == ($rsize_3_lcssa | 0)) {
          break;
        }
        var $325 = ($K12_0 >>> 31 << 2) + $T_0 + 16 | 0;
        var $326 = HEAP32[$325 >> 2];
        if (($326 | 0) == 0) {
          label = 1592;
          break;
        } else {
          var $K12_0 = $K12_0 << 1;
          var $T_0 = $326;
        }
      }
      if (label == 1592) {
        if ($325 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
          _abort();
        } else {
          HEAP32[$325 >> 2] = $260;
          HEAP32[$nb$s2 + ($112$s2 + 6)] = $T_0;
          HEAP32[$nb$s2 + ($112$s2 + 3)] = $260;
          HEAP32[$nb$s2 + ($112$s2 + 2)] = $260;
          break;
        }
      }
      var $342 = $T_0 + 8 | 0;
      var $343 = HEAP32[$342 >> 2];
      var $345 = HEAP32[__gm_ + 16 >> 2];
      if ($T_0 >>> 0 < $345 >>> 0) {
        _abort();
      }
      if ($343 >>> 0 < $345 >>> 0) {
        _abort();
      } else {
        HEAP32[$343 + 12 >> 2] = $260;
        HEAP32[$342 >> 2] = $260;
        HEAP32[$nb$s2 + ($112$s2 + 2)] = $343;
        HEAP32[$nb$s2 + ($112$s2 + 3)] = $T_0;
        HEAP32[$nb$s2 + ($112$s2 + 6)] = 0;
        break;
      }
    }
  } while (0);
  var $_0 = $v_3_lcssa + 8 | 0;
  var $_0;
  return $_0;
}
_tmalloc_large["X"] = 1;
function _sys_trim($pad) {
  var $22$s2;
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  if ($pad >>> 0 >= 4294967232) {
    var $released_2 = 0;
    var $released_2;
    var $62 = $released_2 & 1;
    return $62;
  }
  var $7 = HEAP32[__gm_ + 24 >> 2];
  if (($7 | 0) == 0) {
    var $released_2 = 0;
    var $released_2;
    var $62 = $released_2 & 1;
    return $62;
  }
  var $11 = HEAP32[__gm_ + 12 >> 2];
  do {
    if ($11 >>> 0 > ($pad + 40 | 0) >>> 0) {
      var $14 = HEAP32[_mparams + 8 >> 2];
      var $20 = (Math.floor(((-40 - $pad - 1 + $11 + $14 | 0) >>> 0) / ($14 >>> 0)) - 1) * $14 | 0;
      var $22 = _segment_holding($7), $22$s2 = $22 >> 2;
      if ((HEAP32[$22$s2 + 3] & 8 | 0) != 0) {
        break;
      }
      var $28 = _sbrk(0);
      if (($28 | 0) != (HEAP32[$22$s2] + HEAP32[$22$s2 + 1] | 0)) {
        break;
      }
      var $39 = _sbrk(-($20 >>> 0 > 2147483646 ? -2147483648 - $14 | 0 : $20) | 0);
      var $40 = _sbrk(0);
      if (!(($39 | 0) != -1 & $40 >>> 0 < $28 >>> 0)) {
        break;
      }
      var $46 = $28 - $40 | 0;
      if (($28 | 0) == ($40 | 0)) {
        break;
      }
      var $49 = $22 + 4 | 0;
      HEAP32[$49 >> 2] = HEAP32[$49 >> 2] - $46 | 0;
      HEAP32[__gm_ + 432 >> 2] = HEAP32[__gm_ + 432 >> 2] - $46 | 0;
      _init_top(HEAP32[__gm_ + 24 >> 2], HEAP32[__gm_ + 12 >> 2] - $46 | 0);
      var $released_2 = ($28 | 0) != ($40 | 0);
      var $released_2;
      var $62 = $released_2 & 1;
      return $62;
    }
  } while (0);
  if (HEAP32[__gm_ + 12 >> 2] >>> 0 <= HEAP32[__gm_ + 28 >> 2] >>> 0) {
    var $released_2 = 0;
    var $released_2;
    var $62 = $released_2 & 1;
    return $62;
  }
  HEAP32[__gm_ + 28 >> 2] = -1;
  var $released_2 = 0;
  var $released_2;
  var $62 = $released_2 & 1;
  return $62;
}
_sys_trim["X"] = 1;
function _free($mem) {
  var $R7_1$s2;
  var $179$s2;
  var $R_1$s2;
  var $p_0$s2;
  var $167$s2;
  var $_sum2$s2;
  var $14$s2;
  var $mem$s2 = $mem >> 2;
  var label;
  if (($mem | 0) == 0) {
    return;
  }
  var $3 = $mem - 8 | 0;
  var $4 = $3;
  var $5 = HEAP32[__gm_ + 16 >> 2];
  if ($3 >>> 0 < $5 >>> 0) {
    _abort();
  }
  var $10 = HEAP32[$mem - 4 >> 2];
  var $11 = $10 & 3;
  if (($11 | 0) == 1) {
    _abort();
  }
  var $14 = $10 & -8, $14$s2 = $14 >> 2;
  var $15 = $mem + ($14 - 8) | 0;
  var $16 = $15;
  var $18 = ($10 & 1 | 0) == 0;
  L2112 : do {
    if ($18) {
      var $21 = HEAP32[$3 >> 2];
      if (($11 | 0) == 0) {
        return;
      }
      var $_sum2 = -8 - $21 | 0, $_sum2$s2 = $_sum2 >> 2;
      var $24 = $mem + $_sum2 | 0;
      var $25 = $24;
      var $26 = $21 + $14 | 0;
      if ($24 >>> 0 < $5 >>> 0) {
        _abort();
      }
      if (($25 | 0) == (HEAP32[__gm_ + 20 >> 2] | 0)) {
        var $167$s2 = ($mem + ($14 - 4) | 0) >> 2;
        if ((HEAP32[$167$s2] & 3 | 0) != 3) {
          var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
          var $psize_0 = $26;
          break;
        }
        HEAP32[__gm_ + 8 >> 2] = $26;
        HEAP32[$167$s2] = HEAP32[$167$s2] & -2;
        HEAP32[$_sum2$s2 + ($mem$s2 + 1)] = $26 | 1;
        HEAP32[$15 >> 2] = $26;
        return;
      }
      var $32 = $21 >>> 3;
      if ($21 >>> 0 < 256) {
        var $37 = HEAP32[$_sum2$s2 + ($mem$s2 + 2)];
        var $40 = HEAP32[$_sum2$s2 + ($mem$s2 + 3)];
        if (($37 | 0) == ($40 | 0)) {
          HEAP32[__gm_ >> 2] = HEAP32[__gm_ >> 2] & (1 << $32 ^ -1);
          var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
          var $psize_0 = $26;
          break;
        }
        var $51 = (($21 >>> 2 & 1073741822) << 2) + __gm_ + 40 | 0;
        if (($37 | 0) != ($51 | 0) & $37 >>> 0 < $5 >>> 0) {
          _abort();
        }
        if (($40 | 0) == ($51 | 0) | $40 >>> 0 >= $5 >>> 0) {
          HEAP32[$37 + 12 >> 2] = $40;
          HEAP32[$40 + 8 >> 2] = $37;
          var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
          var $psize_0 = $26;
          break;
        } else {
          _abort();
        }
      }
      var $62 = $24;
      var $65 = HEAP32[$_sum2$s2 + ($mem$s2 + 6)];
      var $68 = HEAP32[$_sum2$s2 + ($mem$s2 + 3)];
      var $69 = ($68 | 0) == ($62 | 0);
      L2137 : do {
        if ($69) {
          var $82 = $_sum2 + ($mem + 20) | 0;
          var $83 = HEAP32[$82 >> 2];
          do {
            if (($83 | 0) == 0) {
              var $87 = $_sum2 + ($mem + 16) | 0;
              var $88 = HEAP32[$87 >> 2];
              if (($88 | 0) == 0) {
                var $R_1 = 0, $R_1$s2 = $R_1 >> 2;
                break L2137;
              } else {
                var $RP_0 = $87;
                var $R_0 = $88;
                break;
              }
            } else {
              var $RP_0 = $82;
              var $R_0 = $83;
            }
          } while (0);
          while (1) {
            var $R_0;
            var $RP_0;
            var $90 = $R_0 + 20 | 0;
            if ((HEAP32[$90 >> 2] | 0) == 0) {
              var $94 = $R_0 + 16 | 0;
              if ((HEAP32[$94 >> 2] | 0) == 0) {
                break;
              } else {
                var $CP_0 = $94;
              }
            } else {
              var $CP_0 = $90;
            }
            var $CP_0;
            var $RP_0 = $CP_0;
            var $R_0 = HEAP32[$CP_0 >> 2];
          }
          if ($RP_0 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          } else {
            HEAP32[$RP_0 >> 2] = 0;
            var $R_1 = $R_0, $R_1$s2 = $R_1 >> 2;
            break;
          }
        } else {
          var $73 = HEAP32[$_sum2$s2 + ($mem$s2 + 2)];
          if ($73 >>> 0 < $5 >>> 0) {
            _abort();
          } else {
            HEAP32[$73 + 12 >> 2] = $68;
            HEAP32[$68 + 8 >> 2] = $73;
            var $R_1 = $68, $R_1$s2 = $R_1 >> 2;
            break;
          }
        }
      } while (0);
      var $R_1;
      if (($65 | 0) == 0) {
        var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
        var $psize_0 = $26;
        break;
      }
      var $108 = $_sum2 + ($mem + 28) | 0;
      var $110 = (HEAP32[$108 >> 2] << 2) + __gm_ + 304 | 0;
      do {
        if (($62 | 0) == (HEAP32[$110 >> 2] | 0)) {
          HEAP32[$110 >> 2] = $R_1;
          if (($R_1 | 0) != 0) {
            break;
          }
          HEAP32[__gm_ + 4 >> 2] = HEAP32[__gm_ + 4 >> 2] & (1 << HEAP32[$108 >> 2] ^ -1);
          var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
          var $psize_0 = $26;
          break L2112;
        } else {
          if ($65 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          }
          var $124 = $65 + 16 | 0;
          if ((HEAP32[$124 >> 2] | 0) == ($62 | 0)) {
            HEAP32[$124 >> 2] = $R_1;
          } else {
            HEAP32[$65 + 20 >> 2] = $R_1;
          }
          if (($R_1 | 0) == 0) {
            var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
            var $psize_0 = $26;
            break L2112;
          }
        }
      } while (0);
      if ($R_1 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      }
      HEAP32[$R_1$s2 + 6] = $65;
      var $141 = HEAP32[$_sum2$s2 + ($mem$s2 + 4)];
      do {
        if (($141 | 0) != 0) {
          if ($141 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          } else {
            HEAP32[$R_1$s2 + 4] = $141;
            HEAP32[$141 + 24 >> 2] = $R_1;
            break;
          }
        }
      } while (0);
      var $154 = HEAP32[$_sum2$s2 + ($mem$s2 + 5)];
      if (($154 | 0) == 0) {
        var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
        var $psize_0 = $26;
        break;
      }
      if ($154 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
        _abort();
      } else {
        HEAP32[$R_1$s2 + 5] = $154;
        HEAP32[$154 + 24 >> 2] = $R_1;
        var $p_0 = $25, $p_0$s2 = $p_0 >> 2;
        var $psize_0 = $26;
        break;
      }
    } else {
      var $p_0 = $4, $p_0$s2 = $p_0 >> 2;
      var $psize_0 = $14;
    }
  } while (0);
  var $psize_0;
  var $p_0;
  var $179 = $p_0, $179$s2 = $179 >> 2;
  if ($179 >>> 0 >= $15 >>> 0) {
    _abort();
  }
  var $183 = $mem + ($14 - 4) | 0;
  var $184 = HEAP32[$183 >> 2];
  if (($184 & 1 | 0) == 0) {
    _abort();
  }
  do {
    if (($184 & 2 | 0) == 0) {
      if (($16 | 0) == (HEAP32[__gm_ + 24 >> 2] | 0)) {
        var $195 = HEAP32[__gm_ + 12 >> 2] + $psize_0 | 0;
        HEAP32[__gm_ + 12 >> 2] = $195;
        HEAP32[__gm_ + 24 >> 2] = $p_0;
        HEAP32[$p_0$s2 + 1] = $195 | 1;
        if (($p_0 | 0) == (HEAP32[__gm_ + 20 >> 2] | 0)) {
          HEAP32[__gm_ + 20 >> 2] = 0;
          HEAP32[__gm_ + 8 >> 2] = 0;
        }
        if ($195 >>> 0 <= HEAP32[__gm_ + 28 >> 2] >>> 0) {
          return;
        }
        _sys_trim(0);
        return;
      }
      if (($16 | 0) == (HEAP32[__gm_ + 20 >> 2] | 0)) {
        var $211 = HEAP32[__gm_ + 8 >> 2] + $psize_0 | 0;
        HEAP32[__gm_ + 8 >> 2] = $211;
        HEAP32[__gm_ + 20 >> 2] = $p_0;
        HEAP32[$p_0$s2 + 1] = $211 | 1;
        HEAP32[($211 >> 2) + $179$s2] = $211;
        return;
      }
      var $218 = ($184 & -8) + $psize_0 | 0;
      var $219 = $184 >>> 3;
      var $220 = $184 >>> 0 < 256;
      L2205 : do {
        if ($220) {
          var $224 = HEAP32[$mem$s2 + $14$s2];
          var $227 = HEAP32[(($14 | 4) >> 2) + $mem$s2];
          if (($224 | 0) == ($227 | 0)) {
            HEAP32[__gm_ >> 2] = HEAP32[__gm_ >> 2] & (1 << $219 ^ -1);
            break;
          }
          var $238 = (($184 >>> 2 & 1073741822) << 2) + __gm_ + 40 | 0;
          do {
            if (($224 | 0) != ($238 | 0)) {
              if ($224 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
                break;
              }
              _abort();
            }
          } while (0);
          do {
            if (($227 | 0) != ($238 | 0)) {
              if ($227 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
                break;
              }
              _abort();
            }
          } while (0);
          HEAP32[$224 + 12 >> 2] = $227;
          HEAP32[$227 + 8 >> 2] = $224;
        } else {
          var $253 = $15;
          var $256 = HEAP32[$14$s2 + ($mem$s2 + 4)];
          var $259 = HEAP32[(($14 | 4) >> 2) + $mem$s2];
          var $260 = ($259 | 0) == ($253 | 0);
          L2207 : do {
            if ($260) {
              var $274 = $14 + ($mem + 12) | 0;
              var $275 = HEAP32[$274 >> 2];
              do {
                if (($275 | 0) == 0) {
                  var $279 = $14 + ($mem + 8) | 0;
                  var $280 = HEAP32[$279 >> 2];
                  if (($280 | 0) == 0) {
                    var $R7_1 = 0, $R7_1$s2 = $R7_1 >> 2;
                    break L2207;
                  } else {
                    var $RP9_0 = $279;
                    var $R7_0 = $280;
                    break;
                  }
                } else {
                  var $RP9_0 = $274;
                  var $R7_0 = $275;
                }
              } while (0);
              while (1) {
                var $R7_0;
                var $RP9_0;
                var $282 = $R7_0 + 20 | 0;
                if ((HEAP32[$282 >> 2] | 0) == 0) {
                  var $286 = $R7_0 + 16 | 0;
                  if ((HEAP32[$286 >> 2] | 0) == 0) {
                    break;
                  } else {
                    var $CP10_0 = $286;
                  }
                } else {
                  var $CP10_0 = $282;
                }
                var $CP10_0;
                var $RP9_0 = $CP10_0;
                var $R7_0 = HEAP32[$CP10_0 >> 2];
              }
              if ($RP9_0 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
                _abort();
              } else {
                HEAP32[$RP9_0 >> 2] = 0;
                var $R7_1 = $R7_0, $R7_1$s2 = $R7_1 >> 2;
                break;
              }
            } else {
              var $264 = HEAP32[$mem$s2 + $14$s2];
              if ($264 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
                _abort();
              } else {
                HEAP32[$264 + 12 >> 2] = $259;
                HEAP32[$259 + 8 >> 2] = $264;
                var $R7_1 = $259, $R7_1$s2 = $R7_1 >> 2;
                break;
              }
            }
          } while (0);
          var $R7_1;
          if (($256 | 0) == 0) {
            break;
          }
          var $300 = $14 + ($mem + 20) | 0;
          var $302 = (HEAP32[$300 >> 2] << 2) + __gm_ + 304 | 0;
          do {
            if (($253 | 0) == (HEAP32[$302 >> 2] | 0)) {
              HEAP32[$302 >> 2] = $R7_1;
              if (($R7_1 | 0) != 0) {
                break;
              }
              HEAP32[__gm_ + 4 >> 2] = HEAP32[__gm_ + 4 >> 2] & (1 << HEAP32[$300 >> 2] ^ -1);
              break L2205;
            } else {
              if ($256 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
                _abort();
              }
              var $316 = $256 + 16 | 0;
              if ((HEAP32[$316 >> 2] | 0) == ($253 | 0)) {
                HEAP32[$316 >> 2] = $R7_1;
              } else {
                HEAP32[$256 + 20 >> 2] = $R7_1;
              }
              if (($R7_1 | 0) == 0) {
                break L2205;
              }
            }
          } while (0);
          if ($R7_1 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          }
          HEAP32[$R7_1$s2 + 6] = $256;
          var $333 = HEAP32[$14$s2 + ($mem$s2 + 2)];
          do {
            if (($333 | 0) != 0) {
              if ($333 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
                _abort();
              } else {
                HEAP32[$R7_1$s2 + 4] = $333;
                HEAP32[$333 + 24 >> 2] = $R7_1;
                break;
              }
            }
          } while (0);
          var $346 = HEAP32[$14$s2 + ($mem$s2 + 3)];
          if (($346 | 0) == 0) {
            break;
          }
          if ($346 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
            _abort();
          } else {
            HEAP32[$R7_1$s2 + 5] = $346;
            HEAP32[$346 + 24 >> 2] = $R7_1;
            break;
          }
        }
      } while (0);
      HEAP32[$p_0$s2 + 1] = $218 | 1;
      HEAP32[($218 >> 2) + $179$s2] = $218;
      if (($p_0 | 0) != (HEAP32[__gm_ + 20 >> 2] | 0)) {
        var $psize_1 = $218;
        break;
      }
      HEAP32[__gm_ + 8 >> 2] = $218;
      return;
    } else {
      HEAP32[$183 >> 2] = $184 & -2;
      HEAP32[$p_0$s2 + 1] = $psize_0 | 1;
      HEAP32[($psize_0 >> 2) + $179$s2] = $psize_0;
      var $psize_1 = $psize_0;
    }
  } while (0);
  var $psize_1;
  if ($psize_1 >>> 0 < 256) {
    var $376 = $psize_1 >>> 2 & 1073741822;
    var $378 = ($376 << 2) + __gm_ + 40 | 0;
    var $379 = HEAP32[__gm_ >> 2];
    var $380 = 1 << ($psize_1 >>> 3);
    do {
      if (($379 & $380 | 0) == 0) {
        HEAP32[__gm_ >> 2] = $379 | $380;
        var $F16_0 = $378;
      } else {
        var $387 = HEAP32[__gm_ + ($376 + 2 << 2) + 40 >> 2];
        if ($387 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
          var $F16_0 = $387;
          break;
        }
        _abort();
      }
    } while (0);
    var $F16_0;
    HEAP32[__gm_ + ($376 + 2 << 2) + 40 >> 2] = $p_0;
    HEAP32[$F16_0 + 12 >> 2] = $p_0;
    HEAP32[$p_0$s2 + 2] = $F16_0;
    HEAP32[$p_0$s2 + 3] = $378;
    return;
  }
  var $398 = $p_0;
  var $399 = $psize_1 >>> 8;
  do {
    if (($399 | 0) == 0) {
      var $I18_0 = 0;
    } else {
      if ($psize_1 >>> 0 > 16777215) {
        var $I18_0 = 31;
        break;
      }
      var $406 = ($399 + 1048320 | 0) >>> 16 & 8;
      var $407 = $399 << $406;
      var $410 = ($407 + 520192 | 0) >>> 16 & 4;
      var $411 = $407 << $410;
      var $414 = ($411 + 245760 | 0) >>> 16 & 2;
      var $420 = 14 - ($410 | $406 | $414) + ($411 << $414 >>> 15) | 0;
      var $I18_0 = $psize_1 >>> (($420 + 7 | 0) >>> 0) & 1 | $420 << 1;
    }
  } while (0);
  var $I18_0;
  var $427 = ($I18_0 << 2) + __gm_ + 304 | 0;
  HEAP32[$p_0$s2 + 7] = $I18_0;
  HEAP32[$p_0$s2 + 5] = 0;
  HEAP32[$p_0$s2 + 4] = 0;
  var $431 = HEAP32[__gm_ + 4 >> 2];
  var $432 = 1 << $I18_0;
  do {
    if (($431 & $432 | 0) == 0) {
      HEAP32[__gm_ + 4 >> 2] = $431 | $432;
      HEAP32[$427 >> 2] = $398;
      HEAP32[$p_0$s2 + 6] = $427;
      HEAP32[$p_0$s2 + 3] = $p_0;
      HEAP32[$p_0$s2 + 2] = $p_0;
    } else {
      if (($I18_0 | 0) == 31) {
        var $447 = 0;
      } else {
        var $447 = 25 - ($I18_0 >>> 1) | 0;
      }
      var $447;
      var $K19_0 = $psize_1 << $447;
      var $T_0 = HEAP32[$427 >> 2];
      while (1) {
        var $T_0;
        var $K19_0;
        if ((HEAP32[$T_0 + 4 >> 2] & -8 | 0) == ($psize_1 | 0)) {
          break;
        }
        var $456 = ($K19_0 >>> 31 << 2) + $T_0 + 16 | 0;
        var $457 = HEAP32[$456 >> 2];
        if (($457 | 0) == 0) {
          label = 1745;
          break;
        } else {
          var $K19_0 = $K19_0 << 1;
          var $T_0 = $457;
        }
      }
      if (label == 1745) {
        if ($456 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
          _abort();
        } else {
          HEAP32[$456 >> 2] = $398;
          HEAP32[$p_0$s2 + 6] = $T_0;
          HEAP32[$p_0$s2 + 3] = $p_0;
          HEAP32[$p_0$s2 + 2] = $p_0;
          break;
        }
      }
      var $470 = $T_0 + 8 | 0;
      var $471 = HEAP32[$470 >> 2];
      var $473 = HEAP32[__gm_ + 16 >> 2];
      if ($T_0 >>> 0 < $473 >>> 0) {
        _abort();
      }
      if ($471 >>> 0 < $473 >>> 0) {
        _abort();
      } else {
        HEAP32[$471 + 12 >> 2] = $398;
        HEAP32[$470 >> 2] = $398;
        HEAP32[$p_0$s2 + 2] = $471;
        HEAP32[$p_0$s2 + 3] = $T_0;
        HEAP32[$p_0$s2 + 6] = 0;
        break;
      }
    }
  } while (0);
  var $485 = HEAP32[__gm_ + 32 >> 2] - 1 | 0;
  HEAP32[__gm_ + 32 >> 2] = $485;
  if (($485 | 0) != 0) {
    return;
  }
  _release_unused_segments();
  return;
}
Module["_free"] = _free;
_free["X"] = 1;
function _malloc_footprint() {
  return HEAP32[__gm_ + 432 >> 2];
}
function _malloc_max_footprint() {
  return HEAP32[__gm_ + 436 >> 2];
}
function _release_unused_segments() {
  var $sp_0_in = __gm_ + 452 | 0;
  while (1) {
    var $sp_0_in;
    var $sp_0 = HEAP32[$sp_0_in >> 2];
    if (($sp_0 | 0) == 0) {
      break;
    } else {
      var $sp_0_in = $sp_0 + 8 | 0;
    }
  }
  HEAP32[__gm_ + 32 >> 2] = -1;
  return;
}
function _calloc($n_elements, $elem_size) {
  do {
    if (($n_elements | 0) == 0) {
      var $req_0 = 0;
    } else {
      var $3 = $elem_size * $n_elements | 0;
      if (($elem_size | $n_elements) >>> 0 <= 65535) {
        var $req_0 = $3;
        break;
      }
      var $req_0 = (Math.floor(($3 >>> 0) / ($n_elements >>> 0)) | 0) == ($elem_size | 0) ? $3 : -1;
    }
  } while (0);
  var $req_0;
  var $10 = _malloc($req_0);
  if (($10 | 0) == 0) {
    return $10;
  }
  if ((HEAP32[$10 - 4 >> 2] & 3 | 0) == 0) {
    return $10;
  }
  _memset($10, 0, $req_0, 1);
  return $10;
}
function _realloc($oldmem, $bytes) {
  if (($oldmem | 0) == 0) {
    var $_0 = _malloc($bytes);
    var $_0;
    return $_0;
  } else {
    var $_0 = _internal_realloc($oldmem, $bytes);
    var $_0;
    return $_0;
  }
}
function _memalign($alignment, $bytes) {
  return _internal_memalign($alignment, $bytes);
}
function _internal_memalign($alignment, $bytes) {
  var $49$s2;
  if ($alignment >>> 0 < 9) {
    var $_0 = _malloc($bytes);
    var $_0;
    return $_0;
  }
  var $_alignment = $alignment >>> 0 < 16 ? 16 : $alignment;
  var $8 = ($_alignment - 1 & $_alignment | 0) == 0;
  L2336 : do {
    if ($8) {
      var $_1 = $_alignment;
    } else {
      var $a_0 = 16;
      while (1) {
        var $a_0;
        if ($a_0 >>> 0 < $_alignment >>> 0) {
          var $a_0 = $a_0 << 1;
        } else {
          var $_1 = $a_0;
          break L2336;
        }
      }
    }
  } while (0);
  var $_1;
  if ((-64 - $_1 | 0) >>> 0 <= $bytes >>> 0) {
    HEAP32[___errno() >> 2] = 12;
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  if ($bytes >>> 0 < 11) {
    var $21 = 16;
  } else {
    var $21 = $bytes + 11 & -8;
  }
  var $21;
  var $24 = _malloc($21 + ($_1 + 12) | 0);
  if (($24 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $27 = $24 - 8 | 0;
  do {
    if ((($24 >>> 0) % ($_1 >>> 0) | 0) == 0) {
      var $p_0_in = $27;
      var $leader_1 = 0;
    } else {
      var $36 = $24 + ($_1 - 1) & -$_1;
      var $37 = $36 - 8 | 0;
      var $39 = $27;
      if (($37 - $39 | 0) >>> 0 > 15) {
        var $45 = $37;
      } else {
        var $45 = $36 + ($_1 - 8) | 0;
      }
      var $45;
      var $47 = $45 - $39 | 0;
      var $49$s2 = ($24 - 4 | 0) >> 2;
      var $50 = HEAP32[$49$s2];
      var $52 = ($50 & -8) - $47 | 0;
      if (($50 & 3 | 0) == 0) {
        HEAP32[$45 >> 2] = HEAP32[$27 >> 2] + $47 | 0;
        HEAP32[$45 + 4 >> 2] = $52;
        var $p_0_in = $45;
        var $leader_1 = 0;
        break;
      } else {
        var $64 = $45 + 4 | 0;
        HEAP32[$64 >> 2] = $52 | HEAP32[$64 >> 2] & 1 | 2;
        var $70 = $52 + ($45 + 4) | 0;
        HEAP32[$70 >> 2] = HEAP32[$70 >> 2] | 1;
        HEAP32[$49$s2] = $47 | HEAP32[$49$s2] & 1 | 2;
        var $78 = $24 + ($47 - 4) | 0;
        HEAP32[$78 >> 2] = HEAP32[$78 >> 2] | 1;
        var $p_0_in = $45;
        var $leader_1 = $24;
        break;
      }
    }
  } while (0);
  var $leader_1;
  var $p_0_in;
  var $83 = $p_0_in + 4 | 0;
  var $84 = HEAP32[$83 >> 2];
  do {
    if (($84 & 3 | 0) == 0) {
      var $trailer_0 = 0;
    } else {
      var $88 = $84 & -8;
      if ($88 >>> 0 <= ($21 + 16 | 0) >>> 0) {
        var $trailer_0 = 0;
        break;
      }
      HEAP32[$83 >> 2] = $21 | $84 & 1 | 2;
      HEAP32[$p_0_in + ($21 | 4) >> 2] = $88 - $21 | 3;
      var $100 = $p_0_in + ($88 | 4) | 0;
      HEAP32[$100 >> 2] = HEAP32[$100 >> 2] | 1;
      var $trailer_0 = $21 + ($p_0_in + 8) | 0;
    }
  } while (0);
  var $trailer_0;
  if (($leader_1 | 0) != 0) {
    _free($leader_1);
  }
  if (($trailer_0 | 0) != 0) {
    _free($trailer_0);
  }
  var $_0 = $p_0_in + 8 | 0;
  var $_0;
  return $_0;
}
_internal_memalign["X"] = 1;
function _independent_calloc($n_elements, $elem_size, $chunks) {
  var __stackBase__ = STACKTOP;
  STACKTOP += 4;
  var $sz = __stackBase__;
  HEAP32[$sz >> 2] = $elem_size;
  var $1 = _ialloc($n_elements, $sz, 3, $chunks);
  STACKTOP = __stackBase__;
  return $1;
}
function _ialloc($n_elements, $sizes, $opts, $chunks) {
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  var $6 = ($n_elements | 0) == 0;
  do {
    if (($chunks | 0) == 0) {
      if ($6) {
        var $_0 = _malloc(0);
        var $_0;
        return $_0;
      } else {
        var $13 = $n_elements << 2;
        if ($13 >>> 0 < 11) {
          var $marray_0 = 0;
          var $array_size_0 = 16;
          break;
        }
        var $marray_0 = 0;
        var $array_size_0 = $13 + 11 & -8;
        break;
      }
    } else {
      if ($6) {
        var $_0 = $chunks;
      } else {
        var $marray_0 = $chunks;
        var $array_size_0 = 0;
        break;
      }
      var $_0;
      return $_0;
    }
  } while (0);
  var $array_size_0;
  var $marray_0;
  var $20 = ($opts & 1 | 0) == 0;
  L2385 : do {
    if ($20) {
      if (($n_elements | 0) == 0) {
        var $element_size_0 = 0;
        var $contents_size_1 = 0;
        break;
      } else {
        var $contents_size_07 = 0;
        var $i_08 = 0;
      }
      while (1) {
        var $i_08;
        var $contents_size_07;
        var $32 = HEAP32[$sizes + ($i_08 << 2) >> 2];
        if ($32 >>> 0 < 11) {
          var $38 = 16;
        } else {
          var $38 = $32 + 11 & -8;
        }
        var $38;
        var $39 = $38 + $contents_size_07 | 0;
        var $40 = $i_08 + 1 | 0;
        if (($40 | 0) == ($n_elements | 0)) {
          var $element_size_0 = 0;
          var $contents_size_1 = $39;
          break L2385;
        } else {
          var $contents_size_07 = $39;
          var $i_08 = $40;
        }
      }
    } else {
      var $23 = HEAP32[$sizes >> 2];
      if ($23 >>> 0 < 11) {
        var $29 = 16;
      } else {
        var $29 = $23 + 11 & -8;
      }
      var $29;
      var $element_size_0 = $29;
      var $contents_size_1 = $29 * $n_elements | 0;
    }
  } while (0);
  var $contents_size_1;
  var $element_size_0;
  var $44 = _malloc($array_size_0 - 4 + $contents_size_1 | 0);
  if (($44 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $47 = $44 - 8 | 0;
  var $51 = HEAP32[$44 - 4 >> 2] & -8;
  if (($opts & 2 | 0) != 0) {
    _memset($44, 0, -4 - $array_size_0 + $51 | 0, 4);
  }
  if (($marray_0 | 0) == 0) {
    HEAP32[$44 + ($contents_size_1 - 4) >> 2] = $51 - $contents_size_1 | 3;
    var $marray_1 = $44 + $contents_size_1 | 0;
    var $remainder_size_0 = $contents_size_1;
  } else {
    var $marray_1 = $marray_0;
    var $remainder_size_0 = $51;
  }
  var $remainder_size_0;
  var $marray_1;
  HEAP32[$marray_1 >> 2] = $44;
  var $67 = $n_elements - 1 | 0;
  var $68 = ($67 | 0) == 0;
  L2406 : do {
    if ($68) {
      var $p_0_in_lcssa = $47;
      var $remainder_size_1_lcssa = $remainder_size_0;
    } else {
      var $69 = ($element_size_0 | 0) == 0;
      var $p_0_in3 = $47;
      var $remainder_size_14 = $remainder_size_0;
      var $i_15 = 0;
      while (1) {
        var $i_15;
        var $remainder_size_14;
        var $p_0_in3;
        do {
          if ($69) {
            var $73 = HEAP32[$sizes + ($i_15 << 2) >> 2];
            if ($73 >>> 0 < 11) {
              var $size_0 = 16;
              break;
            }
            var $size_0 = $73 + 11 & -8;
          } else {
            var $size_0 = $element_size_0;
          }
        } while (0);
        var $size_0;
        var $79 = $remainder_size_14 - $size_0 | 0;
        HEAP32[$p_0_in3 + 4 >> 2] = $size_0 | 3;
        var $83 = $p_0_in3 + $size_0 | 0;
        var $84 = $i_15 + 1 | 0;
        HEAP32[$marray_1 + ($84 << 2) >> 2] = $size_0 + ($p_0_in3 + 8) | 0;
        if (($84 | 0) == ($67 | 0)) {
          var $p_0_in_lcssa = $83;
          var $remainder_size_1_lcssa = $79;
          break L2406;
        } else {
          var $p_0_in3 = $83;
          var $remainder_size_14 = $79;
          var $i_15 = $84;
        }
      }
    }
  } while (0);
  var $remainder_size_1_lcssa;
  var $p_0_in_lcssa;
  HEAP32[$p_0_in_lcssa + 4 >> 2] = $remainder_size_1_lcssa | 3;
  var $_0 = $marray_1;
  var $_0;
  return $_0;
}
_ialloc["X"] = 1;
function _independent_comalloc($n_elements, $sizes, $chunks) {
  return _ialloc($n_elements, $sizes, 0, $chunks);
}
function _valloc($bytes) {
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  return _memalign(HEAP32[_mparams + 4 >> 2], $bytes);
}
function _pvalloc($bytes) {
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  var $5 = HEAP32[_mparams + 4 >> 2];
  return _memalign($5, $bytes - 1 + $5 & -$5);
}
function _malloc_trim($pad) {
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  return _sys_trim($pad);
}
function _mallinfo($agg_result) {
  _internal_mallinfo($agg_result);
  return;
}
function _internal_mallinfo($agg_result) {
  var $agg_result$s2 = $agg_result >> 2;
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  if ((HEAP32[__gm_ + 24 >> 2] | 0) == 0) {
    var $nm_0_0 = 0;
    var $nm_1_0 = 0;
    var $nm_9_0 = 0;
    var $nm_8_0 = 0;
    var $nm_4_0 = 0;
    var $nm_5_0 = 0;
    var $nm_7_0 = 0;
  } else {
    var $9 = HEAP32[__gm_ + 12 >> 2] + 40 | 0;
    var $10 = HEAP32[__gm_ + 24 >> 2];
    var $s_02 = __gm_ + 444 | 0;
    var $sum_03 = $9;
    var $mfree_04 = $9;
    var $nfree_05 = 1;
    while (1) {
      var $nfree_05;
      var $mfree_04;
      var $sum_03;
      var $s_02;
      var $12 = $s_02 | 0;
      var $13 = HEAP32[$12 >> 2];
      var $15 = $13 + 8 | 0;
      if (($15 & 7 | 0) == 0) {
        var $22 = 0;
      } else {
        var $22 = -$15 & 7;
      }
      var $22;
      var $24 = HEAP32[$12 >> 2];
      var $25 = $s_02 + 4 | 0;
      var $q_0_in = $13 + $22 | 0;
      var $nfree_1 = $nfree_05;
      var $mfree_1 = $mfree_04;
      var $sum_1 = $sum_03;
      while (1) {
        var $sum_1;
        var $mfree_1;
        var $nfree_1;
        var $q_0_in;
        if ($q_0_in >>> 0 < $24 >>> 0) {
          break;
        }
        if ($q_0_in >>> 0 >= ($24 + HEAP32[$25 >> 2] | 0) >>> 0 | ($q_0_in | 0) == ($10 | 0)) {
          break;
        }
        var $35 = $q_0_in + 4 | 0;
        var $36 = HEAP32[$35 >> 2];
        if (($36 | 0) == 7) {
          break;
        }
        var $39 = $36 & -8;
        if (($36 & 3 | 0) == 1) {
          var $nfree_2 = $nfree_1 + 1 | 0;
          var $mfree_2 = $39 + $mfree_1 | 0;
        } else {
          var $nfree_2 = $nfree_1;
          var $mfree_2 = $mfree_1;
        }
        var $mfree_2;
        var $nfree_2;
        var $q_0_in = $q_0_in + (HEAP32[$35 >> 2] & -8) | 0;
        var $nfree_1 = $nfree_2;
        var $mfree_1 = $mfree_2;
        var $sum_1 = $39 + $sum_1 | 0;
      }
      var $51 = HEAP32[$s_02 + 8 >> 2];
      if (($51 | 0) == 0) {
        break;
      } else {
        var $s_02 = $51;
        var $sum_03 = $sum_1;
        var $mfree_04 = $mfree_1;
        var $nfree_05 = $nfree_1;
      }
    }
    var $54 = HEAP32[__gm_ + 432 >> 2];
    var $nm_0_0 = $sum_1;
    var $nm_1_0 = $nfree_1;
    var $nm_9_0 = HEAP32[__gm_ + 12 >> 2];
    var $nm_8_0 = $mfree_1;
    var $nm_4_0 = $54 - $sum_1 | 0;
    var $nm_5_0 = HEAP32[__gm_ + 436 >> 2];
    var $nm_7_0 = $54 - $mfree_1 | 0;
  }
  var $nm_7_0;
  var $nm_5_0;
  var $nm_4_0;
  var $nm_8_0;
  var $nm_9_0;
  var $nm_1_0;
  var $nm_0_0;
  HEAP32[$agg_result$s2] = $nm_0_0;
  HEAP32[$agg_result$s2 + 1] = $nm_1_0;
  HEAP32[$agg_result$s2 + 2] = 0;
  HEAP32[$agg_result$s2 + 3] = 0;
  HEAP32[$agg_result$s2 + 4] = $nm_4_0;
  HEAP32[$agg_result$s2 + 5] = $nm_5_0;
  HEAP32[$agg_result$s2 + 6] = 0;
  HEAP32[$agg_result$s2 + 7] = $nm_7_0;
  HEAP32[$agg_result$s2 + 8] = $nm_8_0;
  HEAP32[$agg_result$s2 + 9] = $nm_9_0;
  return;
}
_internal_mallinfo["X"] = 1;
function _malloc_stats() {
  _internal_malloc_stats();
  return;
}
function _internal_malloc_stats() {
  var __stackBase__ = STACKTOP;
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  var $6 = (HEAP32[__gm_ + 24 >> 2] | 0) == 0;
  L2457 : do {
    if ($6) {
      var $maxfp_0 = 0;
      var $fp_0 = 0;
      var $used_3 = 0;
    } else {
      var $8 = HEAP32[__gm_ + 436 >> 2];
      var $9 = HEAP32[__gm_ + 432 >> 2];
      var $12 = HEAP32[__gm_ + 24 >> 2];
      var $s_03 = __gm_ + 444 | 0;
      var $used_04 = $9 - 40 - HEAP32[__gm_ + 12 >> 2] | 0;
      while (1) {
        var $used_04;
        var $s_03;
        var $14 = $s_03 | 0;
        var $15 = HEAP32[$14 >> 2];
        var $17 = $15 + 8 | 0;
        if (($17 & 7 | 0) == 0) {
          var $24 = 0;
        } else {
          var $24 = -$17 & 7;
        }
        var $24;
        var $26 = HEAP32[$14 >> 2];
        var $27 = $s_03 + 4 | 0;
        var $q_0_in = $15 + $24 | 0;
        var $used_1 = $used_04;
        while (1) {
          var $used_1;
          var $q_0_in;
          if ($q_0_in >>> 0 < $26 >>> 0) {
            break;
          }
          if ($q_0_in >>> 0 >= ($26 + HEAP32[$27 >> 2] | 0) >>> 0 | ($q_0_in | 0) == ($12 | 0)) {
            break;
          }
          var $37 = $q_0_in + 4 | 0;
          var $38 = HEAP32[$37 >> 2];
          if (($38 | 0) == 7) {
            break;
          }
          if (($38 & 3 | 0) == 1) {
            var $used_2 = $used_1 - ($38 & -8) | 0;
          } else {
            var $used_2 = $used_1;
          }
          var $used_2;
          var $q_0_in = $q_0_in + (HEAP32[$37 >> 2] & -8) | 0;
          var $used_1 = $used_2;
        }
        var $51 = HEAP32[$s_03 + 8 >> 2];
        if (($51 | 0) == 0) {
          var $maxfp_0 = $8;
          var $fp_0 = $9;
          var $used_3 = $used_1;
          break L2457;
        } else {
          var $s_03 = $51;
          var $used_04 = $used_1;
        }
      }
    }
  } while (0);
  var $used_3;
  var $fp_0;
  var $maxfp_0;
  _fprintf(HEAP32[_stderr >> 2], __str41 | 0, (tempInt = STACKTOP, STACKTOP += 4, HEAP32[tempInt >> 2] = $maxfp_0, tempInt));
  _fprintf(HEAP32[_stderr >> 2], __str142 | 0, (tempInt = STACKTOP, STACKTOP += 4, HEAP32[tempInt >> 2] = $fp_0, tempInt));
  _fprintf(HEAP32[_stderr >> 2], __str243 | 0, (tempInt = STACKTOP, STACKTOP += 4, HEAP32[tempInt >> 2] = $used_3, tempInt));
  STACKTOP = __stackBase__;
  return;
}
_internal_malloc_stats["X"] = 1;
function _mallopt($param_number, $value) {
  return _change_mparam($param_number, $value);
}
function _change_mparam($param_number, $value) {
  if ((HEAP32[_mparams >> 2] | 0) == 0) {
    _init_mparams();
  }
  do {
    if (($param_number | 0) == -3) {
      HEAP32[_mparams + 12 >> 2] = $value;
      var $_0 = 1;
    } else if (($param_number | 0) == -2) {
      if (HEAP32[_mparams + 4 >> 2] >>> 0 > $value >>> 0) {
        var $_0 = 0;
        break;
      }
      if (($value - 1 & $value | 0) != 0) {
        var $_0 = 0;
        break;
      }
      HEAP32[_mparams + 8 >> 2] = $value;
      var $_0 = 1;
    } else if (($param_number | 0) == -1) {
      HEAP32[_mparams + 16 >> 2] = $value;
      var $_0 = 1;
    } else {
      var $_0 = 0;
    }
  } while (0);
  var $_0;
  return $_0;
}
function _internal_realloc($oldmem, $bytes) {
  var $21$s2;
  var $8$s2;
  var label;
  if ($bytes >>> 0 > 4294967231) {
    HEAP32[___errno() >> 2] = 12;
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $5 = $oldmem - 8 | 0;
  var $6 = $5;
  var $8$s2 = ($oldmem - 4 | 0) >> 2;
  var $9 = HEAP32[$8$s2];
  var $10 = $9 & -8;
  var $_sum = $10 - 8 | 0;
  var $12 = $oldmem + $_sum | 0;
  if ($5 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
    _abort();
  }
  if (!(($9 & 3 | 0) != 1 & ($_sum | 0) > -8)) {
    _abort();
  }
  var $21$s2 = ($oldmem + ($10 - 4) | 0) >> 2;
  if ((HEAP32[$21$s2] & 1 | 0) == 0) {
    _abort();
  }
  if ($bytes >>> 0 < 11) {
    var $31 = 16;
  } else {
    var $31 = $bytes + 11 & -8;
  }
  var $31;
  var $32 = HEAP32[$8$s2];
  do {
    if (($32 & 3 | 0) == 0) {
      var $extra_0 = 0;
      var $newp_0 = _mmap_resize($6, $31);
      label = 1930;
      break;
    } else {
      if ($10 >>> 0 >= $31 >>> 0) {
        var $40 = $10 - $31 | 0;
        if ($40 >>> 0 <= 15) {
          var $extra_0 = 0;
          var $newp_0 = $6;
          label = 1930;
          break;
        }
        HEAP32[$8$s2] = $31 | $32 & 1 | 2;
        HEAP32[$oldmem + ($31 - 4) >> 2] = $40 | 3;
        HEAP32[$21$s2] = HEAP32[$21$s2] | 1;
        var $extra_0 = $oldmem + $31 | 0;
        var $newp_0 = $6;
        label = 1930;
        break;
      }
      if (($12 | 0) != (HEAP32[__gm_ + 24 >> 2] | 0)) {
        break;
      }
      var $57 = HEAP32[__gm_ + 12 >> 2] + $10 | 0;
      if ($57 >>> 0 <= $31 >>> 0) {
        break;
      }
      var $60 = $57 - $31 | 0;
      HEAP32[$8$s2] = $31 | $32 & 1 | 2;
      HEAP32[$oldmem + ($31 - 4) >> 2] = $60 | 1;
      HEAP32[__gm_ + 24 >> 2] = $oldmem + ($31 - 8) | 0;
      HEAP32[__gm_ + 12 >> 2] = $60;
      var $extra_0 = 0;
      var $newp_0 = $6;
      label = 1930;
      break;
    }
  } while (0);
  do {
    if (label == 1930) {
      var $newp_0;
      var $extra_0;
      if (($newp_0 | 0) == 0) {
        break;
      }
      if (($extra_0 | 0) != 0) {
        _free($extra_0);
      }
      var $_0 = $newp_0 + 8 | 0;
      var $_0;
      return $_0;
    }
  } while (0);
  var $77 = _malloc($bytes);
  if (($77 | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $84 = $10 - ((HEAP32[$8$s2] & 3 | 0) == 0 ? 8 : 4) | 0;
  _memcpy($77, $oldmem, $84 >>> 0 < $bytes >>> 0 ? $84 : $bytes, 1);
  _free($oldmem);
  var $_0 = $77;
  var $_0;
  return $_0;
}
_internal_realloc["X"] = 1;
function _init_mparams() {
  if ((HEAP32[_mparams >> 2] | 0) != 0) {
    return;
  }
  var $4 = _sysconf(8);
  if (($4 - 1 & $4 | 0) != 0) {
    _abort();
  }
  HEAP32[_mparams + 8 >> 2] = $4;
  HEAP32[_mparams + 4 >> 2] = $4;
  HEAP32[_mparams + 12 >> 2] = -1;
  HEAP32[_mparams + 16 >> 2] = 2097152;
  HEAP32[_mparams + 20 >> 2] = 0;
  HEAP32[__gm_ + 440 >> 2] = 0;
  var $12 = _time(0) & -16 ^ 1431655768;
  HEAP32[_mparams >> 2] = $12;
  return;
}
function _malloc_usable_size($mem) {
  if (($mem | 0) == 0) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $5 = HEAP32[$mem - 4 >> 2];
  var $6 = $5 & 3;
  if (($6 | 0) == 1) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  var $_0 = ($5 & -8) - (($6 | 0) == 0 ? 8 : 4) | 0;
  var $_0;
  return $_0;
}
function _mmap_resize($oldp, $nb) {
  var $3 = HEAP32[$oldp + 4 >> 2] & -8;
  if ($nb >>> 0 < 256) {
    var $_0 = 0;
    var $_0;
    return $_0;
  }
  do {
    if ($3 >>> 0 >= ($nb + 4 | 0) >>> 0) {
      if (($3 - $nb | 0) >>> 0 > HEAP32[_mparams + 8 >> 2] << 1 >>> 0) {
        break;
      } else {
        var $_0 = $oldp;
      }
      var $_0;
      return $_0;
    }
  } while (0);
  var $_0 = 0;
  var $_0;
  return $_0;
}
function _segment_holding($addr) {
  var $sp_0$s2;
  var label;
  var $sp_0 = __gm_ + 444 | 0, $sp_0$s2 = $sp_0 >> 2;
  while (1) {
    var $sp_0;
    var $3 = HEAP32[$sp_0$s2];
    if ($3 >>> 0 <= $addr >>> 0) {
      if (($3 + HEAP32[$sp_0$s2 + 1] | 0) >>> 0 > $addr >>> 0) {
        var $_0 = $sp_0;
        label = 1971;
        break;
      }
    }
    var $12 = HEAP32[$sp_0$s2 + 2];
    if (($12 | 0) == 0) {
      var $_0 = 0;
      label = 1972;
      break;
    } else {
      var $sp_0 = $12, $sp_0$s2 = $sp_0 >> 2;
    }
  }
  if (label == 1972) {
    var $_0;
    return $_0;
  } else if (label == 1971) {
    var $_0;
    return $_0;
  }
}
function _init_top($p, $psize) {
  var $1 = $p;
  var $3 = $p + 8 | 0;
  if (($3 & 7 | 0) == 0) {
    var $10 = 0;
  } else {
    var $10 = -$3 & 7;
  }
  var $10;
  var $13 = $psize - $10 | 0;
  HEAP32[__gm_ + 24 >> 2] = $1 + $10 | 0;
  HEAP32[__gm_ + 12 >> 2] = $13;
  HEAP32[$10 + ($1 + 4) >> 2] = $13 | 1;
  HEAP32[$psize + ($1 + 4) >> 2] = 40;
  HEAP32[__gm_ + 28 >> 2] = HEAP32[_mparams + 16 >> 2];
  return;
}
function _init_bins() {
  var $i_02 = 0;
  while (1) {
    var $i_02;
    var $2 = $i_02 << 1;
    var $4 = ($2 << 2) + __gm_ + 40 | 0;
    HEAP32[__gm_ + ($2 + 3 << 2) + 40 >> 2] = $4;
    HEAP32[__gm_ + ($2 + 2 << 2) + 40 >> 2] = $4;
    var $7 = $i_02 + 1 | 0;
    if (($7 | 0) == 32) {
      break;
    } else {
      var $i_02 = $7;
    }
  }
  return;
}
function _mmap_alloc() {
}
function _prepend_alloc($newbase, $oldbase, $nb) {
  var $R_1$s2;
  var $_sum$s2;
  var $19$s2;
  var $oldbase$s2 = $oldbase >> 2;
  var $newbase$s2 = $newbase >> 2;
  var label;
  var $2 = $newbase + 8 | 0;
  if (($2 & 7 | 0) == 0) {
    var $9 = 0;
  } else {
    var $9 = -$2 & 7;
  }
  var $9;
  var $12 = $oldbase + 8 | 0;
  if (($12 & 7 | 0) == 0) {
    var $19 = 0, $19$s2 = $19 >> 2;
  } else {
    var $19 = -$12 & 7, $19$s2 = $19 >> 2;
  }
  var $19;
  var $20 = $oldbase + $19 | 0;
  var $21 = $20;
  var $_sum = $9 + $nb | 0, $_sum$s2 = $_sum >> 2;
  var $25 = $newbase + $_sum | 0;
  var $26 = $25;
  var $27 = $20 - ($newbase + $9) - $nb | 0;
  HEAP32[($9 + 4 >> 2) + $newbase$s2] = $nb | 3;
  if (($21 | 0) == (HEAP32[__gm_ + 24 >> 2] | 0)) {
    var $35 = HEAP32[__gm_ + 12 >> 2] + $27 | 0;
    HEAP32[__gm_ + 12 >> 2] = $35;
    HEAP32[__gm_ + 24 >> 2] = $26;
    HEAP32[$_sum$s2 + ($newbase$s2 + 1)] = $35 | 1;
    var $_sum1819 = $9 | 8;
    var $336 = $newbase + $_sum1819 | 0;
    return $336;
  }
  if (($21 | 0) == (HEAP32[__gm_ + 20 >> 2] | 0)) {
    var $44 = HEAP32[__gm_ + 8 >> 2] + $27 | 0;
    HEAP32[__gm_ + 8 >> 2] = $44;
    HEAP32[__gm_ + 20 >> 2] = $26;
    HEAP32[$_sum$s2 + ($newbase$s2 + 1)] = $44 | 1;
    HEAP32[($44 >> 2) + $newbase$s2 + $_sum$s2] = $44;
    var $_sum1819 = $9 | 8;
    var $336 = $newbase + $_sum1819 | 0;
    return $336;
  }
  var $53 = HEAP32[$19$s2 + ($oldbase$s2 + 1)];
  if (($53 & 3 | 0) == 1) {
    var $57 = $53 & -8;
    var $58 = $53 >>> 3;
    var $59 = $53 >>> 0 < 256;
    L2584 : do {
      if ($59) {
        var $63 = HEAP32[(($19 | 8) >> 2) + $oldbase$s2];
        var $66 = HEAP32[$19$s2 + ($oldbase$s2 + 3)];
        if (($63 | 0) == ($66 | 0)) {
          HEAP32[__gm_ >> 2] = HEAP32[__gm_ >> 2] & (1 << $58 ^ -1);
          break;
        }
        var $77 = (($53 >>> 2 & 1073741822) << 2) + __gm_ + 40 | 0;
        do {
          if (($63 | 0) != ($77 | 0)) {
            if ($63 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
              break;
            }
            _abort();
          }
        } while (0);
        do {
          if (($66 | 0) != ($77 | 0)) {
            if ($66 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
              break;
            }
            _abort();
          }
        } while (0);
        HEAP32[$63 + 12 >> 2] = $66;
        HEAP32[$66 + 8 >> 2] = $63;
      } else {
        var $92 = $20;
        var $95 = HEAP32[(($19 | 24) >> 2) + $oldbase$s2];
        var $98 = HEAP32[$19$s2 + ($oldbase$s2 + 3)];
        var $99 = ($98 | 0) == ($92 | 0);
        L2598 : do {
          if ($99) {
            var $_sum67 = $19 | 16;
            var $113 = $_sum67 + ($oldbase + 4) | 0;
            var $114 = HEAP32[$113 >> 2];
            do {
              if (($114 | 0) == 0) {
                var $118 = $oldbase + $_sum67 | 0;
                var $119 = HEAP32[$118 >> 2];
                if (($119 | 0) == 0) {
                  var $R_1 = 0, $R_1$s2 = $R_1 >> 2;
                  break L2598;
                } else {
                  var $RP_0 = $118;
                  var $R_0 = $119;
                  break;
                }
              } else {
                var $RP_0 = $113;
                var $R_0 = $114;
              }
            } while (0);
            while (1) {
              var $R_0;
              var $RP_0;
              var $121 = $R_0 + 20 | 0;
              if ((HEAP32[$121 >> 2] | 0) == 0) {
                var $125 = $R_0 + 16 | 0;
                if ((HEAP32[$125 >> 2] | 0) == 0) {
                  break;
                } else {
                  var $CP_0 = $125;
                }
              } else {
                var $CP_0 = $121;
              }
              var $CP_0;
              var $RP_0 = $CP_0;
              var $R_0 = HEAP32[$CP_0 >> 2];
            }
            if ($RP_0 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
              _abort();
            } else {
              HEAP32[$RP_0 >> 2] = 0;
              var $R_1 = $R_0, $R_1$s2 = $R_1 >> 2;
              break;
            }
          } else {
            var $103 = HEAP32[(($19 | 8) >> 2) + $oldbase$s2];
            if ($103 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
              _abort();
            } else {
              HEAP32[$103 + 12 >> 2] = $98;
              HEAP32[$98 + 8 >> 2] = $103;
              var $R_1 = $98, $R_1$s2 = $R_1 >> 2;
              break;
            }
          }
        } while (0);
        var $R_1;
        if (($95 | 0) == 0) {
          break;
        }
        var $139 = $19 + ($oldbase + 28) | 0;
        var $141 = (HEAP32[$139 >> 2] << 2) + __gm_ + 304 | 0;
        do {
          if (($92 | 0) == (HEAP32[$141 >> 2] | 0)) {
            HEAP32[$141 >> 2] = $R_1;
            if (($R_1 | 0) != 0) {
              break;
            }
            HEAP32[__gm_ + 4 >> 2] = HEAP32[__gm_ + 4 >> 2] & (1 << HEAP32[$139 >> 2] ^ -1);
            break L2584;
          } else {
            if ($95 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
              _abort();
            }
            var $155 = $95 + 16 | 0;
            if ((HEAP32[$155 >> 2] | 0) == ($92 | 0)) {
              HEAP32[$155 >> 2] = $R_1;
            } else {
              HEAP32[$95 + 20 >> 2] = $R_1;
            }
            if (($R_1 | 0) == 0) {
              break L2584;
            }
          }
        } while (0);
        if ($R_1 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
          _abort();
        }
        HEAP32[$R_1$s2 + 6] = $95;
        var $_sum3132 = $19 | 16;
        var $172 = HEAP32[($_sum3132 >> 2) + $oldbase$s2];
        do {
          if (($172 | 0) != 0) {
            if ($172 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
              _abort();
            } else {
              HEAP32[$R_1$s2 + 4] = $172;
              HEAP32[$172 + 24 >> 2] = $R_1;
              break;
            }
          }
        } while (0);
        var $185 = HEAP32[($_sum3132 + 4 >> 2) + $oldbase$s2];
        if (($185 | 0) == 0) {
          break;
        }
        if ($185 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
          _abort();
        } else {
          HEAP32[$R_1$s2 + 5] = $185;
          HEAP32[$185 + 24 >> 2] = $R_1;
          break;
        }
      }
    } while (0);
    var $oldfirst_0 = $oldbase + ($57 | $19) | 0;
    var $qsize_0 = $57 + $27 | 0;
  } else {
    var $oldfirst_0 = $21;
    var $qsize_0 = $27;
  }
  var $qsize_0;
  var $oldfirst_0;
  var $201 = $oldfirst_0 + 4 | 0;
  HEAP32[$201 >> 2] = HEAP32[$201 >> 2] & -2;
  HEAP32[$_sum$s2 + ($newbase$s2 + 1)] = $qsize_0 | 1;
  HEAP32[($qsize_0 >> 2) + $newbase$s2 + $_sum$s2] = $qsize_0;
  if ($qsize_0 >>> 0 < 256) {
    var $213 = $qsize_0 >>> 2 & 1073741822;
    var $215 = ($213 << 2) + __gm_ + 40 | 0;
    var $216 = HEAP32[__gm_ >> 2];
    var $217 = 1 << ($qsize_0 >>> 3);
    do {
      if (($216 & $217 | 0) == 0) {
        HEAP32[__gm_ >> 2] = $216 | $217;
        var $F4_0 = $215;
      } else {
        var $224 = HEAP32[__gm_ + ($213 + 2 << 2) + 40 >> 2];
        if ($224 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
          var $F4_0 = $224;
          break;
        }
        _abort();
      }
    } while (0);
    var $F4_0;
    HEAP32[__gm_ + ($213 + 2 << 2) + 40 >> 2] = $26;
    HEAP32[$F4_0 + 12 >> 2] = $26;
    HEAP32[$_sum$s2 + ($newbase$s2 + 2)] = $F4_0;
    HEAP32[$_sum$s2 + ($newbase$s2 + 3)] = $215;
    var $_sum1819 = $9 | 8;
    var $336 = $newbase + $_sum1819 | 0;
    return $336;
  }
  var $237 = $25;
  var $238 = $qsize_0 >>> 8;
  do {
    if (($238 | 0) == 0) {
      var $I7_0 = 0;
    } else {
      if ($qsize_0 >>> 0 > 16777215) {
        var $I7_0 = 31;
        break;
      }
      var $245 = ($238 + 1048320 | 0) >>> 16 & 8;
      var $246 = $238 << $245;
      var $249 = ($246 + 520192 | 0) >>> 16 & 4;
      var $250 = $246 << $249;
      var $253 = ($250 + 245760 | 0) >>> 16 & 2;
      var $259 = 14 - ($249 | $245 | $253) + ($250 << $253 >>> 15) | 0;
      var $I7_0 = $qsize_0 >>> (($259 + 7 | 0) >>> 0) & 1 | $259 << 1;
    }
  } while (0);
  var $I7_0;
  var $266 = ($I7_0 << 2) + __gm_ + 304 | 0;
  HEAP32[$_sum$s2 + ($newbase$s2 + 7)] = $I7_0;
  HEAP32[$_sum$s2 + ($newbase$s2 + 5)] = 0;
  HEAP32[$_sum$s2 + ($newbase$s2 + 4)] = 0;
  var $273 = HEAP32[__gm_ + 4 >> 2];
  var $274 = 1 << $I7_0;
  if (($273 & $274 | 0) == 0) {
    HEAP32[__gm_ + 4 >> 2] = $273 | $274;
    HEAP32[$266 >> 2] = $237;
    HEAP32[$_sum$s2 + ($newbase$s2 + 6)] = $266;
    HEAP32[$_sum$s2 + ($newbase$s2 + 3)] = $237;
    HEAP32[$_sum$s2 + ($newbase$s2 + 2)] = $237;
    var $_sum1819 = $9 | 8;
    var $336 = $newbase + $_sum1819 | 0;
    return $336;
  }
  if (($I7_0 | 0) == 31) {
    var $293 = 0;
  } else {
    var $293 = 25 - ($I7_0 >>> 1) | 0;
  }
  var $293;
  var $K8_0 = $qsize_0 << $293;
  var $T_0 = HEAP32[$266 >> 2];
  while (1) {
    var $T_0;
    var $K8_0;
    if ((HEAP32[$T_0 + 4 >> 2] & -8 | 0) == ($qsize_0 | 0)) {
      break;
    }
    var $302 = ($K8_0 >>> 31 << 2) + $T_0 + 16 | 0;
    var $303 = HEAP32[$302 >> 2];
    if (($303 | 0) == 0) {
      label = 2047;
      break;
    } else {
      var $K8_0 = $K8_0 << 1;
      var $T_0 = $303;
    }
  }
  if (label == 2047) {
    if ($302 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
      _abort();
    }
    HEAP32[$302 >> 2] = $237;
    HEAP32[$_sum$s2 + ($newbase$s2 + 6)] = $T_0;
    HEAP32[$_sum$s2 + ($newbase$s2 + 3)] = $237;
    HEAP32[$_sum$s2 + ($newbase$s2 + 2)] = $237;
    var $_sum1819 = $9 | 8;
    var $336 = $newbase + $_sum1819 | 0;
    return $336;
  }
  var $319 = $T_0 + 8 | 0;
  var $320 = HEAP32[$319 >> 2];
  var $322 = HEAP32[__gm_ + 16 >> 2];
  if ($T_0 >>> 0 < $322 >>> 0) {
    _abort();
  }
  if ($320 >>> 0 < $322 >>> 0) {
    _abort();
  }
  HEAP32[$320 + 12 >> 2] = $237;
  HEAP32[$319 >> 2] = $237;
  HEAP32[$_sum$s2 + ($newbase$s2 + 2)] = $320;
  HEAP32[$_sum$s2 + ($newbase$s2 + 3)] = $T_0;
  HEAP32[$_sum$s2 + ($newbase$s2 + 6)] = 0;
  var $_sum1819 = $9 | 8;
  var $336 = $newbase + $_sum1819 | 0;
  return $336;
}
_prepend_alloc["X"] = 1;
function __ZNKSt9bad_alloc4whatEv($this) {
  return __str3 | 0;
}
function __ZNKSt20bad_array_new_length4whatEv($this) {
  return __str14 | 0;
}
function __ZSt15get_new_handlerv() {
  return tempValue = HEAP32[__ZL13__new_handler >> 2], HEAP32[__ZL13__new_handler >> 2] = tempValue, tempValue;
}
function __ZSt15set_new_handlerPFvvE($handler) {
  return tempValue = HEAP32[__ZL13__new_handler >> 2], HEAP32[__ZL13__new_handler >> 2] = $handler, tempValue;
}
function __ZNSt9bad_allocC2Ev($this) {
  HEAP32[$this >> 2] = __ZTVSt9bad_alloc + 8 | 0;
  return;
}
function __ZdlPv($ptr) {
  if (($ptr | 0) != 0) {
    _free($ptr);
  }
  return;
}
function __ZdlPvRKSt9nothrow_t($ptr, $0) {
  __ZdlPv($ptr);
  return;
}
function __ZdaPv($ptr) {
  __ZdlPv($ptr);
  return;
}
function __ZdaPvRKSt9nothrow_t($ptr, $0) {
  __ZdaPv($ptr);
  return;
}
function __ZNSt9bad_allocD0Ev($this) {
  __ZNSt9bad_allocD2Ev($this);
  __ZdlPv($this);
  return;
}
function __ZNSt9bad_allocD2Ev($this) {
  __ZNSt9exceptionD2Ev($this | 0);
  return;
}
function __ZNSt20bad_array_new_lengthC2Ev($this) {
  __ZNSt9bad_allocC2Ev($this | 0);
  HEAP32[$this >> 2] = __ZTVSt20bad_array_new_length + 8 | 0;
  return;
}
function __ZNSt20bad_array_new_lengthD0Ev($this) {
  __ZNSt9bad_allocD2Ev($this | 0);
  __ZdlPv($this);
  return;
}
function _add_segment($tbase, $tsize) {
  var $23$s2;
  var $1$s2;
  var label;
  var $1 = HEAP32[__gm_ + 24 >> 2], $1$s2 = $1 >> 2;
  var $2 = $1;
  var $3 = _segment_holding($2);
  var $5 = HEAP32[$3 >> 2];
  var $7 = HEAP32[$3 + 4 >> 2];
  var $8 = $5 + $7 | 0;
  var $10 = $5 + ($7 - 39) | 0;
  if (($10 & 7 | 0) == 0) {
    var $17 = 0;
  } else {
    var $17 = -$10 & 7;
  }
  var $17;
  var $18 = $5 + ($7 - 47) + $17 | 0;
  var $22 = $18 >>> 0 < ($1 + 16 | 0) >>> 0 ? $2 : $18;
  var $23 = $22 + 8 | 0, $23$s2 = $23 >> 2;
  _init_top($tbase, $tsize - 40 | 0);
  HEAP32[$22 + 4 >> 2] = 27;
  HEAP32[$23$s2] = HEAP32[__gm_ + 444 >> 2];
  HEAP32[$23$s2 + 1] = HEAP32[__gm_ + 448 >> 2];
  HEAP32[$23$s2 + 2] = HEAP32[__gm_ + 452 >> 2];
  HEAP32[$23$s2 + 3] = HEAP32[__gm_ + 456 >> 2];
  HEAP32[__gm_ + 444 >> 2] = $tbase;
  HEAP32[__gm_ + 448 >> 2] = $tsize;
  HEAP32[__gm_ + 456 >> 2] = 0;
  HEAP32[__gm_ + 452 >> 2] = $23;
  var $30 = $22 + 28 | 0;
  HEAP32[$30 >> 2] = 7;
  var $32 = ($22 + 32 | 0) >>> 0 < $8 >>> 0;
  L2701 : do {
    if ($32) {
      var $33 = $30;
      while (1) {
        var $33;
        var $34 = $33 + 4 | 0;
        HEAP32[$34 >> 2] = 7;
        if (($33 + 8 | 0) >>> 0 < $8 >>> 0) {
          var $33 = $34;
        } else {
          break L2701;
        }
      }
    }
  } while (0);
  if (($22 | 0) == ($2 | 0)) {
    return;
  }
  var $42 = $22 - $1 | 0;
  var $45 = $42 + ($2 + 4) | 0;
  HEAP32[$45 >> 2] = HEAP32[$45 >> 2] & -2;
  HEAP32[$1$s2 + 1] = $42 | 1;
  HEAP32[$2 + $42 >> 2] = $42;
  if ($42 >>> 0 < 256) {
    var $55 = $42 >>> 2 & 1073741822;
    var $57 = ($55 << 2) + __gm_ + 40 | 0;
    var $58 = HEAP32[__gm_ >> 2];
    var $59 = 1 << ($42 >>> 3);
    do {
      if (($58 & $59 | 0) == 0) {
        HEAP32[__gm_ >> 2] = $58 | $59;
        var $F_0 = $57;
      } else {
        var $66 = HEAP32[__gm_ + ($55 + 2 << 2) + 40 >> 2];
        if ($66 >>> 0 >= HEAP32[__gm_ + 16 >> 2] >>> 0) {
          var $F_0 = $66;
          break;
        }
        _abort();
      }
    } while (0);
    var $F_0;
    HEAP32[__gm_ + ($55 + 2 << 2) + 40 >> 2] = $1;
    HEAP32[$F_0 + 12 >> 2] = $1;
    HEAP32[$1$s2 + 2] = $F_0;
    HEAP32[$1$s2 + 3] = $57;
    return;
  }
  var $77 = $1;
  var $78 = $42 >>> 8;
  do {
    if (($78 | 0) == 0) {
      var $I1_0 = 0;
    } else {
      if ($42 >>> 0 > 16777215) {
        var $I1_0 = 31;
        break;
      }
      var $85 = ($78 + 1048320 | 0) >>> 16 & 8;
      var $86 = $78 << $85;
      var $89 = ($86 + 520192 | 0) >>> 16 & 4;
      var $90 = $86 << $89;
      var $93 = ($90 + 245760 | 0) >>> 16 & 2;
      var $99 = 14 - ($89 | $85 | $93) + ($90 << $93 >>> 15) | 0;
      var $I1_0 = $42 >>> (($99 + 7 | 0) >>> 0) & 1 | $99 << 1;
    }
  } while (0);
  var $I1_0;
  var $106 = ($I1_0 << 2) + __gm_ + 304 | 0;
  HEAP32[$1$s2 + 7] = $I1_0;
  HEAP32[$1$s2 + 5] = 0;
  HEAP32[$1$s2 + 4] = 0;
  var $110 = HEAP32[__gm_ + 4 >> 2];
  var $111 = 1 << $I1_0;
  if (($110 & $111 | 0) == 0) {
    HEAP32[__gm_ + 4 >> 2] = $110 | $111;
    HEAP32[$106 >> 2] = $77;
    HEAP32[$1$s2 + 6] = $106;
    HEAP32[$1$s2 + 3] = $1;
    HEAP32[$1$s2 + 2] = $1;
    return;
  }
  if (($I1_0 | 0) == 31) {
    var $126 = 0;
  } else {
    var $126 = 25 - ($I1_0 >>> 1) | 0;
  }
  var $126;
  var $K2_0 = $42 << $126;
  var $T_0 = HEAP32[$106 >> 2];
  while (1) {
    var $T_0;
    var $K2_0;
    if ((HEAP32[$T_0 + 4 >> 2] & -8 | 0) == ($42 | 0)) {
      break;
    }
    var $135 = ($K2_0 >>> 31 << 2) + $T_0 + 16 | 0;
    var $136 = HEAP32[$135 >> 2];
    if (($136 | 0) == 0) {
      label = 2101;
      break;
    } else {
      var $K2_0 = $K2_0 << 1;
      var $T_0 = $136;
    }
  }
  if (label == 2101) {
    if ($135 >>> 0 < HEAP32[__gm_ + 16 >> 2] >>> 0) {
      _abort();
    }
    HEAP32[$135 >> 2] = $77;
    HEAP32[$1$s2 + 6] = $T_0;
    HEAP32[$1$s2 + 3] = $1;
    HEAP32[$1$s2 + 2] = $1;
    return;
  }
  var $149 = $T_0 + 8 | 0;
  var $150 = HEAP32[$149 >> 2];
  var $152 = HEAP32[__gm_ + 16 >> 2];
  if ($T_0 >>> 0 < $152 >>> 0) {
    _abort();
  }
  if ($150 >>> 0 < $152 >>> 0) {
    _abort();
  }
  HEAP32[$150 + 12 >> 2] = $77;
  HEAP32[$149 >> 2] = $77;
  HEAP32[$1$s2 + 2] = $150;
  HEAP32[$1$s2 + 3] = $T_0;
  HEAP32[$1$s2 + 6] = 0;
  return;
}
_add_segment["X"] = 1;
function __Znwj($size) {
  var label;
  var $_size = ($size | 0) == 0 ? 1 : $size;
  while (1) {
    var $3 = _malloc($_size);
    if (($3 | 0) != 0) {
      label = 2125;
      break;
    }
    var $6 = __ZSt15get_new_handlerv();
    if (($6 | 0) == 0) {
      break;
    }
    FUNCTION_TABLE[$6]();
  }
  if (label == 2125) {
    return $3;
  }
  var $15 = ___cxa_allocate_exception(4);
  __ZNSt9bad_allocC2Ev($15);
  ___cxa_throw($15, __ZTISt9bad_alloc, 26);
}
function __ZnwjRKSt9nothrow_t($size, $0) {
  return __Znwj($size);
}
function __Znaj($size) {
  return __Znwj($size);
}
function __ZnajRKSt9nothrow_t($size, $nothrow) {
  return __Znaj($size);
}
function __ZSt17__throw_bad_allocv() {
  var $1 = ___cxa_allocate_exception(4);
  __ZNSt9bad_allocC2Ev($1);
  ___cxa_throw($1, __ZTISt9bad_alloc, 26);
}





// Note: For maximum-speed code, see "Optimizing Code" on the Emscripten wiki, https://github.com/kripken/emscripten/wiki/Optimizing-Code
// Note: Some Emscripten settings may limit the speed of the generated code.
// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;

// === Auto-generated postamble setup entry stuff ===

Module.callMain = function callMain(args) {
  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_STATIC) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_STATIC));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_STATIC);

  return _main(argc, argv, 0);
}


FUNCTION_TABLE = [0,0,__ZNSt20bad_array_new_lengthC2Ev,0,_enet_range_coder_decompress,0,__ZNSt20bad_array_new_lengthD0Ev,0,_free,0,_enet_range_coder_compress,0,__ZNKSt9bad_alloc4whatEv,0,__ZNKSt20bad_array_new_length4whatEv,0,_abort,0,_malloc,0,__ZNSt9bad_allocC2Ev,0,__ZNSt9bad_allocD0Ev,0,_packet_filter,0,__ZNSt9bad_allocD2Ev,0,_enet_range_coder_destroy,0]; Module["FUNCTION_TABLE"] = FUNCTION_TABLE;


function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return 0;
  }

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    var toRun = Module['preRun'];
    Module['preRun'] = [];
    for (var i = toRun.length-1; i >= 0; i--) {
      toRun[i]();
    }
    if (runDependencies > 0) {
      // a preRun added a dependency, run will be called later
      return 0;
    }
  }

  function doRun() {
    var ret = 0;
    calledRun = true;
    if (Module['_main']) {
      preMain();
      ret = Module.callMain(args);
      if (!Module['noExitRuntime']) {
        exitRuntime();
      }
    }
    if (Module['postRun']) {
      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
      while (Module['postRun'].length > 0) {
        Module['postRun'].pop()();
      }
    }
    return ret;
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
    return 0;
  } else {
    return doRun();
  }
}
Module['run'] = Module.run = run;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

initRuntime();

var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

if (shouldRunNow) {
  var ret = run();
}

// {{POST_RUN_ADDITIONS}}






  // {{MODULE_ADDITIONS}}


// EMSCRIPTEN_GENERATED_FUNCTIONS: ["_initialize_crc32","_sys_trim","_enet_socket_shutdown","_enet_host_bandwidth_limit","_enet_time_set","_enet_protocol_remove_sent_unreliable_commands","_enet_protocol_check_timeouts","_enet_socket_connect","__ZNSt9bad_allocC2Ev","_enet_host_check_events","_enet_protocol_receive_incoming_commands","_enet_range_coder_create","__ZNKSt9bad_alloc4whatEv","__ZdlPv","_enet_host_compress_with_range_coder","_enet_protocol_handle_disconnect","_jsapi_event_get_peer","_enet_socket_bind","_malloc_trim","_enet_peer_dispatch_incoming_unreliable_commands","__ZdlPvRKSt9nothrow_t","_malloc_usable_size","_enet_protocol_send_unreliable_outgoing_commands","_enet_peer_queue_outgoing_command","__ZdaPvRKSt9nothrow_t","_release_unused_segments","_free","_enet_packet_destroy","_malloc_stats","_enet_protocol_dispatch_state","_jsapi_host_get_receivedAddress","_enet_range_coder_decompress","_sys_alloc","_jsapi_host_get_socket","_enet_peer_ping_interval","_enet_host_compress","_jsapi_event_get_channelID","_change_mparam","_jsapi_host_get_receivedDataLength","_enet_initialize_with_callbacks","_enet_peer_queue_incoming_command","_jsapi_event_get_packet","_memalign","_enet_deinitialize","_enet_protocol_handle_send_unsequenced","_enet_address_set_host","_enet_protocol_handle_acknowledge","_enet_peer_timeout","_enet_malloc","_enet_packet_filter","_independent_calloc","_enet_protocol_handle_ping","_enet_socket_accept","_enet_peer_reset_outgoing_commands","_enet_socket_send","_enet_peer_reset","_enet_address_get_host","_jsapi_peer_get_channelCount","_pvalloc","_tmalloc_small","_jsapi_event_new","_packet_filter","_mmap_alloc","_enet_protocol_send_outgoing_commands","_enet_range_coder_compress","_enet_peer_remove_incoming_commands","_realloc","_enet_protocol_handle_send_reliable","_tmalloc_large","_enet_socket_wait","_jsapi_host_get_channelLimit","__ZNSt9bad_allocD2Ev","_enet_peer_throttle_configure","_enet_time_get","_enet_peer_reset_queues","_jsapi_event_free","_enet_peer_queue_acknowledgement","_enet_socket_destroy","_enet_host_connect","__ZNSt20bad_array_new_lengthC2Ev","_enet_host_bandwidth_throttle","_enet_free","_reflect_crc","__Znwj","__ZSt17__throw_bad_allocv","__ZNKSt20bad_array_new_length4whatEv","_enet_initialize","_jsapi_peer_get_data","_enet_peer_setup_outgoing_command","_enet_socket_set_option","_jsapi_enet_host_create","_independent_comalloc","_internal_mallinfo","_enet_protocol_remove_sent_reliable_command","__ZnwjRKSt9nothrow_t","_mmap_resize","_jsapi_packet_get_dataLength","_enet_host_destroy","_enet_host_create","_enet_protocol_notify_disconnect","_enet_range_coder_destroy","_enet_peer_dispatch_incoming_reliable_commands","_prepend_alloc","_enet_protocol_handle_bandwidth_limit","_ialloc","_enet_socket_create","_enet_peer_disconnect_now","_internal_memalign","_enet_packet_resize","_enet_peer_receive","_enet_peer_ping","_enet_crc32","_jsapi_init","_enet_list_insert","_mallopt","_enet_list_move","_enet_peer_send","_enet_peer_disconnect","_enet_protocol_handle_send_fragment","__Znaj","_enet_symbol_rescale","_init_bins","__ZNSt9bad_allocD0Ev","_malloc","_malloc_max_footprint","_enet_host_broadcast","_jsapi_event_get_type","_jsapi_packet_get_data","_valloc","_malloc_footprint","__ZNSt20bad_array_new_lengthD0Ev","_enet_socketset_select","_internal_malloc_stats","_enet_address_get_host_ip","_enet_list_remove","_enet_host_flush","_jsapi_peer_get_address","_enet_protocol_handle_throttle_configure","_calloc","_enet_protocol_dispatch_incoming_commands","_enet_list_size","_enet_list_clear","_init_top","__ZSt15set_new_handlerPFvvE","_jsapi_address_get_port","_mallinfo","_internal_realloc","__ZdaPv","_enet_protocol_command_size","_enet_peer_reset_incoming_commands","_jsapi_host_get_peerCount","_enet_protocol_handle_verify_connect","_init_mparams","_enet_socket_listen","_enet_protocol_send_acknowledgements","_enet_host_service","_jsapi_event_get_data","_segment_holding","_enet_protocol_handle_connect","_enet_protocol_notify_connect","_add_segment","_enet_packet_create","_jsapi_enet_host_connect","_enet_protocol_handle_incoming_commands","_jsapi_address_get_host","_enet_peer_disconnect_later","_enet_protocol_send_reliable_outgoing_commands","_enet_peer_throttle","_enet_host_channel_limit","__ZSt15get_new_handlerv","_jsapi_host_get_receivedData","__ZnajRKSt9nothrow_t","_enet_protocol_handle_send_unreliable_fragment","_enet_socket_receive","_enet_protocol_handle_send_unreliable"]


}).call(this);
